/*
 * --------------------------------------------------------------------------------
 * <copyright company="Aspose" file="model.ts">
 *   Copyright (c) 2025 Aspose.Words for Cloud
 * </copyright>
 * <summary>
 *   Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 * 
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 * 
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 * </summary>
 * --------------------------------------------------------------------------------
 */

import http = require("http");
import { v4 as uuidv4 } from 'uuid';
import { Readable } from "stream";
import { IncomingMessage } from 'http';
import request = require("request");
import { Configuration } from "../internal/configuration";
import { addQueryParameterToUrl, getBoundary, parseFilesCollection, findMultipartElement, parseMultipart } from "../internal/requestHelper";
import { ObjectSerializer } from "../internal/objectSerializer";
import { Encryptor, FileReference } from '../api';
import * as importedApiError from './apiError';
import * as importedAvailableFontsResponse from './availableFontsResponse';
import * as importedAzw3SaveOptionsData from './azw3SaveOptionsData';
import * as importedBaseEntry from './baseEntry';
import * as importedBaseEntryList from './baseEntryList';
import * as importedBmpSaveOptionsData from './bmpSaveOptionsData';
import * as importedBookmark from './bookmark';
import * as importedBookmarkData from './bookmarkData';
import * as importedBookmarkInsert from './bookmarkInsert';
import * as importedBookmarkResponse from './bookmarkResponse';
import * as importedBookmarks from './bookmarks';
import * as importedBookmarksOutlineLevelData from './bookmarksOutlineLevelData';
import * as importedBookmarksResponse from './bookmarksResponse';
import * as importedBorder from './border';
import * as importedBorderResponse from './borderResponse';
import * as importedBordersCollection from './bordersCollection';
import * as importedBordersResponse from './bordersResponse';
import * as importedClassificationResponse from './classificationResponse';
import * as importedClassificationResult from './classificationResult';
import * as importedComment from './comment';
import * as importedCommentBase from './commentBase';
import * as importedCommentInsert from './commentInsert';
import * as importedCommentLink from './commentLink';
import * as importedCommentRangeEnd from './commentRangeEnd';
import * as importedCommentRangeStart from './commentRangeStart';
import * as importedCommentResponse from './commentResponse';
import * as importedCommentsCollection from './commentsCollection';
import * as importedCommentsResponse from './commentsResponse';
import * as importedCommentUpdate from './commentUpdate';
import * as importedCompareData from './compareData';
import * as importedCompareOptions from './compareOptions';
import * as importedCompressOptions from './compressOptions';
import * as importedCompressResponse from './compressResponse';
import * as importedCsvDataLoadOptions from './csvDataLoadOptions';
import * as importedCustomXmlPart from './customXmlPart';
import * as importedCustomXmlPartInsert from './customXmlPartInsert';
import * as importedCustomXmlPartLink from './customXmlPartLink';
import * as importedCustomXmlPartResponse from './customXmlPartResponse';
import * as importedCustomXmlPartsCollection from './customXmlPartsCollection';
import * as importedCustomXmlPartsResponse from './customXmlPartsResponse';
import * as importedCustomXmlPartUpdate from './customXmlPartUpdate';
import * as importedDigitalSignatureDetails from './digitalSignatureDetails';
import * as importedDocmSaveOptionsData from './docmSaveOptionsData';
import * as importedDocSaveOptionsData from './docSaveOptionsData';
import * as importedDocument from './document';
import * as importedDocumentEntry from './documentEntry';
import * as importedDocumentEntryList from './documentEntryList';
import * as importedDocumentPosition from './documentPosition';
import * as importedDocumentProperties from './documentProperties';
import * as importedDocumentPropertiesResponse from './documentPropertiesResponse';
import * as importedDocumentProperty from './documentProperty';
import * as importedDocumentPropertyCreateOrUpdate from './documentPropertyCreateOrUpdate';
import * as importedDocumentPropertyResponse from './documentPropertyResponse';
import * as importedDocumentResponse from './documentResponse';
import * as importedDocumentStatData from './documentStatData';
import * as importedDocxSaveOptionsData from './docxSaveOptionsData';
import * as importedDotmSaveOptionsData from './dotmSaveOptionsData';
import * as importedDotSaveOptionsData from './dotSaveOptionsData';
import * as importedDotxSaveOptionsData from './dotxSaveOptionsData';
import * as importedDownsampleOptionsData from './downsampleOptionsData';
import * as importedDrawingObject from './drawingObject';
import * as importedDrawingObjectCollection from './drawingObjectCollection';
import * as importedDrawingObjectInsert from './drawingObjectInsert';
import * as importedDrawingObjectLink from './drawingObjectLink';
import * as importedDrawingObjectResponse from './drawingObjectResponse';
import * as importedDrawingObjectsResponse from './drawingObjectsResponse';
import * as importedDrawingObjectUpdate from './drawingObjectUpdate';
import * as importedEmfSaveOptionsData from './emfSaveOptionsData';
import * as importedEpsSaveOptionsData from './epsSaveOptionsData';
import * as importedEpubSaveOptionsData from './epubSaveOptionsData';
import * as importedError from './error';
import * as importedErrorDetails from './errorDetails';
import * as importedField from './field';
import * as importedFieldBase from './fieldBase';
import * as importedFieldCollection from './fieldCollection';
import * as importedFieldInsert from './fieldInsert';
import * as importedFieldLink from './fieldLink';
import * as importedFieldNames from './fieldNames';
import * as importedFieldNamesResponse from './fieldNamesResponse';
import * as importedFieldOptions from './fieldOptions';
import * as importedFieldResponse from './fieldResponse';
import * as importedFieldsResponse from './fieldsResponse';
import * as importedFieldUpdate from './fieldUpdate';
import * as importedFileLink from './fileLink';
import * as importedFileReference from './fileReference';
import * as importedFilesList from './filesList';
import * as importedFilesUploadResult from './filesUploadResult';
import * as importedFixedPageSaveOptionsData from './fixedPageSaveOptionsData';
import * as importedFlatOpcMacroSaveOptionsData from './flatOpcMacroSaveOptionsData';
import * as importedFlatOpcSaveOptionsData from './flatOpcSaveOptionsData';
import * as importedFlatOpcTemplateMacroSaveOptionsData from './flatOpcTemplateMacroSaveOptionsData';
import * as importedFlatOpcTemplateSaveOptionsData from './flatOpcTemplateSaveOptionsData';
import * as importedFont from './font';
import * as importedFontInfo from './fontInfo';
import * as importedFontResponse from './fontResponse';
import * as importedFootnote from './footnote';
import * as importedFootnoteBase from './footnoteBase';
import * as importedFootnoteCollection from './footnoteCollection';
import * as importedFootnoteInsert from './footnoteInsert';
import * as importedFootnoteLink from './footnoteLink';
import * as importedFootnoteResponse from './footnoteResponse';
import * as importedFootnotesResponse from './footnotesResponse';
import * as importedFootnotesStatData from './footnotesStatData';
import * as importedFootnoteUpdate from './footnoteUpdate';
import * as importedFormField from './formField';
import * as importedFormFieldCheckbox from './formFieldCheckbox';
import * as importedFormFieldCheckboxLink from './formFieldCheckboxLink';
import * as importedFormFieldCollection from './formFieldCollection';
import * as importedFormFieldDropDown from './formFieldDropDown';
import * as importedFormFieldDropDownLink from './formFieldDropDownLink';
import * as importedFormFieldResponse from './formFieldResponse';
import * as importedFormFieldsResponse from './formFieldsResponse';
import * as importedFormFieldTextInput from './formFieldTextInput';
import * as importedFormFieldTextInputLink from './formFieldTextInputLink';
import * as importedGifSaveOptionsData from './gifSaveOptionsData';
import * as importedHeaderFooter from './headerFooter';
import * as importedHeaderFooterLink from './headerFooterLink';
import * as importedHeaderFooterLinkCollection from './headerFooterLinkCollection';
import * as importedHeaderFooterResponse from './headerFooterResponse';
import * as importedHeaderFootersResponse from './headerFootersResponse';
import * as importedHtmlFixedSaveOptionsData from './htmlFixedSaveOptionsData';
import * as importedHtmlSaveOptionsData from './htmlSaveOptionsData';
import * as importedHyperlink from './hyperlink';
import * as importedHyperlinkResponse from './hyperlinkResponse';
import * as importedHyperlinks from './hyperlinks';
import * as importedHyperlinksResponse from './hyperlinksResponse';
import * as importedImageEntry from './imageEntry';
import * as importedImageEntryList from './imageEntryList';
import * as importedImageSaveOptionsData from './imageSaveOptionsData';
import * as importedInfoAdditionalItem from './infoAdditionalItem';
import * as importedInfoResponse from './infoResponse';
import * as importedJpegSaveOptionsData from './jpegSaveOptionsData';
import * as importedJsonDataLoadOptions from './jsonDataLoadOptions';
import * as importedLink from './link';
import * as importedLinkElement from './linkElement';
import * as importedListFormat from './listFormat';
import * as importedListFormatUpdate from './listFormatUpdate';
import * as importedListInfo from './listInfo';
import * as importedListInsert from './listInsert';
import * as importedListLevel from './listLevel';
import * as importedListLevels from './listLevels';
import * as importedListLevelUpdate from './listLevelUpdate';
import * as importedListResponse from './listResponse';
import * as importedLists from './lists';
import * as importedListsResponse from './listsResponse';
import * as importedListUpdate from './listUpdate';
import * as importedLoadWebDocumentData from './loadWebDocumentData';
import * as importedMarkdownSaveOptionsData from './markdownSaveOptionsData';
import * as importedMetafileRenderingOptionsData from './metafileRenderingOptionsData';
import * as importedMhtmlSaveOptionsData from './mhtmlSaveOptionsData';
import * as importedModificationOperationResult from './modificationOperationResult';
import * as importedNodeLink from './nodeLink';
import * as importedOdtSaveOptionsData from './odtSaveOptionsData';
import * as importedOfficeMathLink from './officeMathLink';
import * as importedOfficeMathObject from './officeMathObject';
import * as importedOfficeMathObjectResponse from './officeMathObjectResponse';
import * as importedOfficeMathObjectsCollection from './officeMathObjectsCollection';
import * as importedOfficeMathObjectsResponse from './officeMathObjectsResponse';
import * as importedOoxmlSaveOptionsData from './ooxmlSaveOptionsData';
import * as importedOpenXpsSaveOptionsData from './openXpsSaveOptionsData';
import * as importedOptimizationOptions from './optimizationOptions';
import * as importedOttSaveOptionsData from './ottSaveOptionsData';
import * as importedOutlineOptionsData from './outlineOptionsData';
import * as importedPageNumber from './pageNumber';
import * as importedPageSetup from './pageSetup';
import * as importedPageStatData from './pageStatData';
import * as importedParagraph from './paragraph';
import * as importedParagraphFormat from './paragraphFormat';
import * as importedParagraphFormatBase from './paragraphFormatBase';
import * as importedParagraphFormatResponse from './paragraphFormatResponse';
import * as importedParagraphFormatUpdate from './paragraphFormatUpdate';
import * as importedParagraphInsert from './paragraphInsert';
import * as importedParagraphLink from './paragraphLink';
import * as importedParagraphLinkCollection from './paragraphLinkCollection';
import * as importedParagraphLinkCollectionResponse from './paragraphLinkCollectionResponse';
import * as importedParagraphListFormatResponse from './paragraphListFormatResponse';
import * as importedParagraphResponse from './paragraphResponse';
import * as importedPclSaveOptionsData from './pclSaveOptionsData';
import * as importedPdfDigitalSignatureDetailsData from './pdfDigitalSignatureDetailsData';
import * as importedPdfEncryptionDetailsData from './pdfEncryptionDetailsData';
import * as importedPdfPermissions from './pdfPermissions';
import * as importedPdfSaveOptionsData from './pdfSaveOptionsData';
import * as importedPngSaveOptionsData from './pngSaveOptionsData';
import * as importedPosition from './position';
import * as importedPositionAfterNode from './positionAfterNode';
import * as importedPositionBeforeNode from './positionBeforeNode';
import * as importedPositionInsideNode from './positionInsideNode';
import * as importedPreferredWidth from './preferredWidth';
import * as importedProtectionData from './protectionData';
import * as importedProtectionDataResponse from './protectionDataResponse';
import * as importedProtectionRequest from './protectionRequest';
import * as importedProtectionRequestBase from './protectionRequestBase';
import * as importedProtectionRequestV2 from './protectionRequestV2';
import * as importedPsSaveOptionsData from './psSaveOptionsData';
import * as importedPublicKeyResponse from './publicKeyResponse';
import * as importedRangeDocument from './rangeDocument';
import * as importedRangeTextResponse from './rangeTextResponse';
import * as importedReplaceRange from './replaceRange';
import * as importedReplaceTextParameters from './replaceTextParameters';
import * as importedReplaceTextResponse from './replaceTextResponse';
import * as importedReportBuildOptions from './reportBuildOptions';
import * as importedReportEngineSettings from './reportEngineSettings';
import * as importedRevision from './revision';
import * as importedRevisionCollection from './revisionCollection';
import * as importedRevisionsModificationResponse from './revisionsModificationResponse';
import * as importedRevisionsResponse from './revisionsResponse';
import * as importedRtfSaveOptionsData from './rtfSaveOptionsData';
import * as importedRun from './run';
import * as importedRunBase from './runBase';
import * as importedRunInsert from './runInsert';
import * as importedRunLink from './runLink';
import * as importedRunResponse from './runResponse';
import * as importedRuns from './runs';
import * as importedRunsResponse from './runsResponse';
import * as importedRunUpdate from './runUpdate';
import * as importedSaveOptionsData from './saveOptionsData';
import * as importedSaveResponse from './saveResponse';
import * as importedSaveResult from './saveResult';
import * as importedSearchResponse from './searchResponse';
import * as importedSearchResult from './searchResult';
import * as importedSearchResultsCollection from './searchResultsCollection';
import * as importedSection from './section';
import * as importedSectionLink from './sectionLink';
import * as importedSectionLinkCollection from './sectionLinkCollection';
import * as importedSectionLinkCollectionResponse from './sectionLinkCollectionResponse';
import * as importedSectionPageSetupResponse from './sectionPageSetupResponse';
import * as importedSectionResponse from './sectionResponse';
import * as importedShading from './shading';
import * as importedSignature from './signature';
import * as importedSignatureCollectionResponse from './signatureCollectionResponse';
import * as importedSignOptions from './signOptions';
import * as importedSplitDocumentResponse from './splitDocumentResponse';
import * as importedSplitDocumentResult from './splitDocumentResult';
import * as importedStatDataResponse from './statDataResponse';
import * as importedStorageFile from './storageFile';
import * as importedStoryChildNodes from './storyChildNodes';
import * as importedStructuredDocumentTag from './structuredDocumentTag';
import * as importedStructuredDocumentTagBase from './structuredDocumentTagBase';
import * as importedStructuredDocumentTagCollection from './structuredDocumentTagCollection';
import * as importedStructuredDocumentTagInsert from './structuredDocumentTagInsert';
import * as importedStructuredDocumentTagListItem from './structuredDocumentTagListItem';
import * as importedStructuredDocumentTagResponse from './structuredDocumentTagResponse';
import * as importedStructuredDocumentTagsResponse from './structuredDocumentTagsResponse';
import * as importedStructuredDocumentTagUpdate from './structuredDocumentTagUpdate';
import * as importedStyle from './style';
import * as importedStyleApply from './styleApply';
import * as importedStyleCopy from './styleCopy';
import * as importedStyleInsert from './styleInsert';
import * as importedStyleResponse from './styleResponse';
import * as importedStylesResponse from './stylesResponse';
import * as importedStyleUpdate from './styleUpdate';
import * as importedSvgSaveOptionsData from './svgSaveOptionsData';
import * as importedTable from './table';
import * as importedTableCell from './tableCell';
import * as importedTableCellFormat from './tableCellFormat';
import * as importedTableCellFormatResponse from './tableCellFormatResponse';
import * as importedTableCellInsert from './tableCellInsert';
import * as importedTableCellResponse from './tableCellResponse';
import * as importedTableInsert from './tableInsert';
import * as importedTableLink from './tableLink';
import * as importedTableLinkCollection from './tableLinkCollection';
import * as importedTableLinkCollectionResponse from './tableLinkCollectionResponse';
import * as importedTableProperties from './tableProperties';
import * as importedTablePropertiesResponse from './tablePropertiesResponse';
import * as importedTableResponse from './tableResponse';
import * as importedTableRow from './tableRow';
import * as importedTableRowFormat from './tableRowFormat';
import * as importedTableRowFormatResponse from './tableRowFormatResponse';
import * as importedTableRowInsert from './tableRowInsert';
import * as importedTableRowResponse from './tableRowResponse';
import * as importedTabStop from './tabStop';
import * as importedTabStopBase from './tabStopBase';
import * as importedTabStopInsert from './tabStopInsert';
import * as importedTabStopsResponse from './tabStopsResponse';
import * as importedTextSaveOptionsData from './textSaveOptionsData';
import * as importedTiffSaveOptionsData from './tiffSaveOptionsData';
import * as importedTimeZoneInfoData from './timeZoneInfoData';
import * as importedTranslateNodeIdResponse from './translateNodeIdResponse';
import * as importedTxtSaveOptionsBaseData from './txtSaveOptionsBaseData';
import * as importedUserInformation from './userInformation';
import * as importedWatermarkDataBase from './watermarkDataBase';
import * as importedWatermarkDataImage from './watermarkDataImage';
import * as importedWatermarkDataText from './watermarkDataText';
import * as importedWatermarkText from './watermarkText';
import * as importedWordMLSaveOptionsData from './wordMLSaveOptionsData';
import * as importedWordsApiErrorResponse from './wordsApiErrorResponse';
import * as importedWordsApiLink from './wordsApiLink';
import * as importedWordsResponse from './wordsResponse';
import * as importedXamlFixedSaveOptionsData from './xamlFixedSaveOptionsData';
import * as importedXamlFlowPackSaveOptionsData from './xamlFlowPackSaveOptionsData';
import * as importedXamlFlowSaveOptionsData from './xamlFlowSaveOptionsData';
import * as importedXmlColor from './xmlColor';
import * as importedXmlDataLoadOptions from './xmlDataLoadOptions';
import * as importedXpsSaveOptionsData from './xpsSaveOptionsData';

export { AttributeInfo } from '../internal/attributeInfo';
export * from './apiError';
export * from './availableFontsResponse';
export * from './azw3SaveOptionsData';
export * from './baseEntry';
export * from './baseEntryList';
export * from './bmpSaveOptionsData';
export * from './bookmark';
export * from './bookmarkData';
export * from './bookmarkInsert';
export * from './bookmarkResponse';
export * from './bookmarks';
export * from './bookmarksOutlineLevelData';
export * from './bookmarksResponse';
export * from './border';
export * from './borderResponse';
export * from './bordersCollection';
export * from './bordersResponse';
export * from './classificationResponse';
export * from './classificationResult';
export * from './comment';
export * from './commentBase';
export * from './commentInsert';
export * from './commentLink';
export * from './commentRangeEnd';
export * from './commentRangeStart';
export * from './commentResponse';
export * from './commentsCollection';
export * from './commentsResponse';
export * from './commentUpdate';
export * from './compareData';
export * from './compareOptions';
export * from './compressOptions';
export * from './compressResponse';
export * from './csvDataLoadOptions';
export * from './customXmlPart';
export * from './customXmlPartInsert';
export * from './customXmlPartLink';
export * from './customXmlPartResponse';
export * from './customXmlPartsCollection';
export * from './customXmlPartsResponse';
export * from './customXmlPartUpdate';
export * from './digitalSignatureDetails';
export * from './docmSaveOptionsData';
export * from './docSaveOptionsData';
export * from './document';
export * from './documentEntry';
export * from './documentEntryList';
export * from './documentPosition';
export * from './documentProperties';
export * from './documentPropertiesResponse';
export * from './documentProperty';
export * from './documentPropertyCreateOrUpdate';
export * from './documentPropertyResponse';
export * from './documentResponse';
export * from './documentStatData';
export * from './docxSaveOptionsData';
export * from './dotmSaveOptionsData';
export * from './dotSaveOptionsData';
export * from './dotxSaveOptionsData';
export * from './downsampleOptionsData';
export * from './drawingObject';
export * from './drawingObjectCollection';
export * from './drawingObjectInsert';
export * from './drawingObjectLink';
export * from './drawingObjectResponse';
export * from './drawingObjectsResponse';
export * from './drawingObjectUpdate';
export * from './emfSaveOptionsData';
export * from './epsSaveOptionsData';
export * from './epubSaveOptionsData';
export * from './error';
export * from './errorDetails';
export * from './field';
export * from './fieldBase';
export * from './fieldCollection';
export * from './fieldInsert';
export * from './fieldLink';
export * from './fieldNames';
export * from './fieldNamesResponse';
export * from './fieldOptions';
export * from './fieldResponse';
export * from './fieldsResponse';
export * from './fieldUpdate';
export * from './fileLink';
export * from './fileReference';
export * from './filesList';
export * from './filesUploadResult';
export * from './fixedPageSaveOptionsData';
export * from './flatOpcMacroSaveOptionsData';
export * from './flatOpcSaveOptionsData';
export * from './flatOpcTemplateMacroSaveOptionsData';
export * from './flatOpcTemplateSaveOptionsData';
export * from './font';
export * from './fontInfo';
export * from './fontResponse';
export * from './footnote';
export * from './footnoteBase';
export * from './footnoteCollection';
export * from './footnoteInsert';
export * from './footnoteLink';
export * from './footnoteResponse';
export * from './footnotesResponse';
export * from './footnotesStatData';
export * from './footnoteUpdate';
export * from './formField';
export * from './formFieldCheckbox';
export * from './formFieldCheckboxLink';
export * from './formFieldCollection';
export * from './formFieldDropDown';
export * from './formFieldDropDownLink';
export * from './formFieldResponse';
export * from './formFieldsResponse';
export * from './formFieldTextInput';
export * from './formFieldTextInputLink';
export * from './gifSaveOptionsData';
export * from './headerFooter';
export * from './headerFooterLink';
export * from './headerFooterLinkCollection';
export * from './headerFooterResponse';
export * from './headerFootersResponse';
export * from './htmlFixedSaveOptionsData';
export * from './htmlSaveOptionsData';
export * from './hyperlink';
export * from './hyperlinkResponse';
export * from './hyperlinks';
export * from './hyperlinksResponse';
export * from './imageEntry';
export * from './imageEntryList';
export * from './imageSaveOptionsData';
export * from './infoAdditionalItem';
export * from './infoResponse';
export * from './jpegSaveOptionsData';
export * from './jsonDataLoadOptions';
export * from './link';
export * from './linkElement';
export * from './listFormat';
export * from './listFormatUpdate';
export * from './listInfo';
export * from './listInsert';
export * from './listLevel';
export * from './listLevels';
export * from './listLevelUpdate';
export * from './listResponse';
export * from './lists';
export * from './listsResponse';
export * from './listUpdate';
export * from './loadWebDocumentData';
export * from './markdownSaveOptionsData';
export * from './metafileRenderingOptionsData';
export * from './mhtmlSaveOptionsData';
export * from './modificationOperationResult';
export * from './nodeLink';
export * from './odtSaveOptionsData';
export * from './officeMathLink';
export * from './officeMathObject';
export * from './officeMathObjectResponse';
export * from './officeMathObjectsCollection';
export * from './officeMathObjectsResponse';
export * from './ooxmlSaveOptionsData';
export * from './openXpsSaveOptionsData';
export * from './optimizationOptions';
export * from './ottSaveOptionsData';
export * from './outlineOptionsData';
export * from './pageNumber';
export * from './pageSetup';
export * from './pageStatData';
export * from './paragraph';
export * from './paragraphFormat';
export * from './paragraphFormatBase';
export * from './paragraphFormatResponse';
export * from './paragraphFormatUpdate';
export * from './paragraphInsert';
export * from './paragraphLink';
export * from './paragraphLinkCollection';
export * from './paragraphLinkCollectionResponse';
export * from './paragraphListFormatResponse';
export * from './paragraphResponse';
export * from './pclSaveOptionsData';
export * from './pdfDigitalSignatureDetailsData';
export * from './pdfEncryptionDetailsData';
export * from './pdfPermissions';
export * from './pdfSaveOptionsData';
export * from './pngSaveOptionsData';
export * from './position';
export * from './positionAfterNode';
export * from './positionBeforeNode';
export * from './positionInsideNode';
export * from './preferredWidth';
export * from './protectionData';
export * from './protectionDataResponse';
export * from './protectionRequest';
export * from './protectionRequestBase';
export * from './protectionRequestV2';
export * from './psSaveOptionsData';
export * from './publicKeyResponse';
export * from './rangeDocument';
export * from './rangeTextResponse';
export * from './replaceRange';
export * from './replaceTextParameters';
export * from './replaceTextResponse';
export * from './reportBuildOptions';
export * from './reportEngineSettings';
export * from './revision';
export * from './revisionCollection';
export * from './revisionsModificationResponse';
export * from './revisionsResponse';
export * from './rtfSaveOptionsData';
export * from './run';
export * from './runBase';
export * from './runInsert';
export * from './runLink';
export * from './runResponse';
export * from './runs';
export * from './runsResponse';
export * from './runUpdate';
export * from './saveOptionsData';
export * from './saveResponse';
export * from './saveResult';
export * from './searchResponse';
export * from './searchResult';
export * from './searchResultsCollection';
export * from './section';
export * from './sectionLink';
export * from './sectionLinkCollection';
export * from './sectionLinkCollectionResponse';
export * from './sectionPageSetupResponse';
export * from './sectionResponse';
export * from './shading';
export * from './signature';
export * from './signatureCollectionResponse';
export * from './signOptions';
export * from './splitDocumentResponse';
export * from './splitDocumentResult';
export * from './statDataResponse';
export * from './storageFile';
export * from './storyChildNodes';
export * from './structuredDocumentTag';
export * from './structuredDocumentTagBase';
export * from './structuredDocumentTagCollection';
export * from './structuredDocumentTagInsert';
export * from './structuredDocumentTagListItem';
export * from './structuredDocumentTagResponse';
export * from './structuredDocumentTagsResponse';
export * from './structuredDocumentTagUpdate';
export * from './style';
export * from './styleApply';
export * from './styleCopy';
export * from './styleInsert';
export * from './styleResponse';
export * from './stylesResponse';
export * from './styleUpdate';
export * from './svgSaveOptionsData';
export * from './table';
export * from './tableCell';
export * from './tableCellFormat';
export * from './tableCellFormatResponse';
export * from './tableCellInsert';
export * from './tableCellResponse';
export * from './tableInsert';
export * from './tableLink';
export * from './tableLinkCollection';
export * from './tableLinkCollectionResponse';
export * from './tableProperties';
export * from './tablePropertiesResponse';
export * from './tableResponse';
export * from './tableRow';
export * from './tableRowFormat';
export * from './tableRowFormatResponse';
export * from './tableRowInsert';
export * from './tableRowResponse';
export * from './tabStop';
export * from './tabStopBase';
export * from './tabStopInsert';
export * from './tabStopsResponse';
export * from './textSaveOptionsData';
export * from './tiffSaveOptionsData';
export * from './timeZoneInfoData';
export * from './translateNodeIdResponse';
export * from './txtSaveOptionsBaseData';
export * from './userInformation';
export * from './watermarkDataBase';
export * from './watermarkDataImage';
export * from './watermarkDataText';
export * from './watermarkText';
export * from './wordMLSaveOptionsData';
export * from './wordsApiErrorResponse';
export * from './wordsApiLink';
export * from './wordsResponse';
export * from './xamlFixedSaveOptionsData';
export * from './xamlFlowPackSaveOptionsData';
export * from './xamlFlowSaveOptionsData';
export * from './xmlColor';
export * from './xmlDataLoadOptions';
export * from './xpsSaveOptionsData';

/**
 * WordsIncomingMessage
 */
export class WordsIncomingMessage<T> {
    /**
     * Gets or sets raw response
     */
    public response: IncomingMessage;

    /**
     * Get or set parsed response
     */
    public body: T;
}

const enumsMap = {
    "Border.BorderTypeEnum": importedBorder.Border.BorderTypeEnum,
    "Border.LineStyleEnum": importedBorder.Border.LineStyleEnum,
    "CompareOptions.GranularityEnum": importedCompareOptions.CompareOptions.GranularityEnum,
    "CompareOptions.TargetEnum": importedCompareOptions.CompareOptions.TargetEnum,
    "Document.SourceFormatEnum": importedDocument.Document.SourceFormatEnum,
    "DocumentEntry.ImportFormatModeEnum": importedDocumentEntry.DocumentEntry.ImportFormatModeEnum,
    "DrawingObject.RelativeHorizontalPositionEnum": importedDrawingObject.DrawingObject.RelativeHorizontalPositionEnum,
    "DrawingObject.RelativeVerticalPositionEnum": importedDrawingObject.DrawingObject.RelativeVerticalPositionEnum,
    "DrawingObject.WrapTypeEnum": importedDrawingObject.DrawingObject.WrapTypeEnum,
    "DrawingObjectInsert.RelativeHorizontalPositionEnum": importedDrawingObjectInsert.DrawingObjectInsert.RelativeHorizontalPositionEnum,
    "DrawingObjectInsert.RelativeVerticalPositionEnum": importedDrawingObjectInsert.DrawingObjectInsert.RelativeVerticalPositionEnum,
    "DrawingObjectInsert.WrapTypeEnum": importedDrawingObjectInsert.DrawingObjectInsert.WrapTypeEnum,
    "DrawingObjectUpdate.RelativeHorizontalPositionEnum": importedDrawingObjectUpdate.DrawingObjectUpdate.RelativeHorizontalPositionEnum,
    "DrawingObjectUpdate.RelativeVerticalPositionEnum": importedDrawingObjectUpdate.DrawingObjectUpdate.RelativeVerticalPositionEnum,
    "DrawingObjectUpdate.WrapTypeEnum": importedDrawingObjectUpdate.DrawingObjectUpdate.WrapTypeEnum,
    "FieldOptions.FieldIndexFormatEnum": importedFieldOptions.FieldOptions.FieldIndexFormatEnum,
    "FieldOptions.FieldUpdateCultureSourceEnum": importedFieldOptions.FieldOptions.FieldUpdateCultureSourceEnum,
    "FileReference.SourceEnum": importedFileReference.FileReference.SourceEnum,
    "FixedPageSaveOptionsData.ColorModeEnum": importedFixedPageSaveOptionsData.FixedPageSaveOptionsData.ColorModeEnum,
    "FixedPageSaveOptionsData.NumeralFormatEnum": importedFixedPageSaveOptionsData.FixedPageSaveOptionsData.NumeralFormatEnum,
    "Font.StyleIdentifierEnum": importedFont.Font.StyleIdentifierEnum,
    "Font.TextEffectEnum": importedFont.Font.TextEffectEnum,
    "Font.UnderlineEnum": importedFont.Font.UnderlineEnum,
    "Footnote.FootnoteTypeEnum": importedFootnote.Footnote.FootnoteTypeEnum,
    "FootnoteBase.FootnoteTypeEnum": importedFootnoteBase.FootnoteBase.FootnoteTypeEnum,
    "FormFieldTextInput.TextInputTypeEnum": importedFormFieldTextInput.FormFieldTextInput.TextInputTypeEnum,
    "HeaderFooterLink.TypeEnum": importedHeaderFooterLink.HeaderFooterLink.TypeEnum,
    "HtmlFixedSaveOptionsData.FontFormatEnum": importedHtmlFixedSaveOptionsData.HtmlFixedSaveOptionsData.FontFormatEnum,
    "HtmlFixedSaveOptionsData.PageHorizontalAlignmentEnum": importedHtmlFixedSaveOptionsData.HtmlFixedSaveOptionsData.PageHorizontalAlignmentEnum,
    "HtmlSaveOptionsData.CssStyleSheetTypeEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.CssStyleSheetTypeEnum,
    "HtmlSaveOptionsData.DocumentSplitCriteriaEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.DocumentSplitCriteriaEnum,
    "HtmlSaveOptionsData.ExportHeadersFootersModeEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.ExportHeadersFootersModeEnum,
    "HtmlSaveOptionsData.ExportListLabelsEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.ExportListLabelsEnum,
    "HtmlSaveOptionsData.HtmlVersionEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.HtmlVersionEnum,
    "HtmlSaveOptionsData.MetafileFormatEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.MetafileFormatEnum,
    "HtmlSaveOptionsData.OfficeMathOutputModeEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.OfficeMathOutputModeEnum,
    "HtmlSaveOptionsData.TableWidthOutputModeEnum": importedHtmlSaveOptionsData.HtmlSaveOptionsData.TableWidthOutputModeEnum,
    "ImageSaveOptionsData.ImageColorModeEnum": importedImageSaveOptionsData.ImageSaveOptionsData.ImageColorModeEnum,
    "ImageSaveOptionsData.PixelFormatEnum": importedImageSaveOptionsData.ImageSaveOptionsData.PixelFormatEnum,
    "JsonDataLoadOptions.SimpleValueParseModeEnum": importedJsonDataLoadOptions.JsonDataLoadOptions.SimpleValueParseModeEnum,
    "ListInsert.TemplateEnum": importedListInsert.ListInsert.TemplateEnum,
    "ListLevel.NumberStyleEnum": importedListLevel.ListLevel.NumberStyleEnum,
    "ListLevel.AlignmentEnum": importedListLevel.ListLevel.AlignmentEnum,
    "ListLevel.TrailingCharacterEnum": importedListLevel.ListLevel.TrailingCharacterEnum,
    "ListLevelUpdate.NumberStyleEnum": importedListLevelUpdate.ListLevelUpdate.NumberStyleEnum,
    "ListLevelUpdate.AlignmentEnum": importedListLevelUpdate.ListLevelUpdate.AlignmentEnum,
    "ListLevelUpdate.TrailingCharacterEnum": importedListLevelUpdate.ListLevelUpdate.TrailingCharacterEnum,
    "MarkdownSaveOptionsData.TableContentAlignmentEnum": importedMarkdownSaveOptionsData.MarkdownSaveOptionsData.TableContentAlignmentEnum,
    "MetafileRenderingOptionsData.EmfPlusDualRenderingModeEnum": importedMetafileRenderingOptionsData.MetafileRenderingOptionsData.EmfPlusDualRenderingModeEnum,
    "MetafileRenderingOptionsData.RenderingModeEnum": importedMetafileRenderingOptionsData.MetafileRenderingOptionsData.RenderingModeEnum,
    "OdtSaveOptionsData.MeasureUnitEnum": importedOdtSaveOptionsData.OdtSaveOptionsData.MeasureUnitEnum,
    "OfficeMathObject.DisplayTypeEnum": importedOfficeMathObject.OfficeMathObject.DisplayTypeEnum,
    "OfficeMathObject.JustificationEnum": importedOfficeMathObject.OfficeMathObject.JustificationEnum,
    "OfficeMathObject.MathObjectTypeEnum": importedOfficeMathObject.OfficeMathObject.MathObjectTypeEnum,
    "OoxmlSaveOptionsData.ComplianceEnum": importedOoxmlSaveOptionsData.OoxmlSaveOptionsData.ComplianceEnum,
    "OoxmlSaveOptionsData.CompressionLevelEnum": importedOoxmlSaveOptionsData.OoxmlSaveOptionsData.CompressionLevelEnum,
    "OptimizationOptions.MsWordVersionEnum": importedOptimizationOptions.OptimizationOptions.MsWordVersionEnum,
    "PageSetup.BorderAppliesToEnum": importedPageSetup.PageSetup.BorderAppliesToEnum,
    "PageSetup.BorderDistanceFromEnum": importedPageSetup.PageSetup.BorderDistanceFromEnum,
    "PageSetup.LineNumberRestartModeEnum": importedPageSetup.PageSetup.LineNumberRestartModeEnum,
    "PageSetup.OrientationEnum": importedPageSetup.PageSetup.OrientationEnum,
    "PageSetup.PageNumberStyleEnum": importedPageSetup.PageSetup.PageNumberStyleEnum,
    "PageSetup.PaperSizeEnum": importedPageSetup.PageSetup.PaperSizeEnum,
    "PageSetup.SectionStartEnum": importedPageSetup.PageSetup.SectionStartEnum,
    "PageSetup.VerticalAlignmentEnum": importedPageSetup.PageSetup.VerticalAlignmentEnum,
    "ParagraphFormatBase.AlignmentEnum": importedParagraphFormatBase.ParagraphFormatBase.AlignmentEnum,
    "ParagraphFormatBase.DropCapPositionEnum": importedParagraphFormatBase.ParagraphFormatBase.DropCapPositionEnum,
    "ParagraphFormatBase.LineSpacingRuleEnum": importedParagraphFormatBase.ParagraphFormatBase.LineSpacingRuleEnum,
    "ParagraphFormatBase.OutlineLevelEnum": importedParagraphFormatBase.ParagraphFormatBase.OutlineLevelEnum,
    "ParagraphFormatBase.StyleIdentifierEnum": importedParagraphFormatBase.ParagraphFormatBase.StyleIdentifierEnum,
    "PdfDigitalSignatureDetailsData.HashAlgorithmEnum": importedPdfDigitalSignatureDetailsData.PdfDigitalSignatureDetailsData.HashAlgorithmEnum,
    "PdfPermissions": importedPdfPermissions.PdfPermissions,
    "PdfSaveOptionsData.AttachmentsEmbeddingModeEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.AttachmentsEmbeddingModeEnum,
    "PdfSaveOptionsData.ComplianceEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.ComplianceEnum,
    "PdfSaveOptionsData.CustomPropertiesExportEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.CustomPropertiesExportEnum,
    "PdfSaveOptionsData.FontEmbeddingModeEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.FontEmbeddingModeEnum,
    "PdfSaveOptionsData.HeaderFooterBookmarksExportModeEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.HeaderFooterBookmarksExportModeEnum,
    "PdfSaveOptionsData.ImageColorSpaceExportModeEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.ImageColorSpaceExportModeEnum,
    "PdfSaveOptionsData.PageModeEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.PageModeEnum,
    "PdfSaveOptionsData.TextCompressionEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.TextCompressionEnum,
    "PdfSaveOptionsData.ZoomBehaviorEnum": importedPdfSaveOptionsData.PdfSaveOptionsData.ZoomBehaviorEnum,
    "PreferredWidth.TypeEnum": importedPreferredWidth.PreferredWidth.TypeEnum,
    "ProtectionData.ProtectionTypeEnum": importedProtectionData.ProtectionData.ProtectionTypeEnum,
    "ProtectionRequestV2.ProtectionTypeEnum": importedProtectionRequestV2.ProtectionRequestV2.ProtectionTypeEnum,
    "ReplaceRange.TextTypeEnum": importedReplaceRange.ReplaceRange.TextTypeEnum,
    "ReportBuildOptions": importedReportBuildOptions.ReportBuildOptions,
    "ReportEngineSettings.DataSourceTypeEnum": importedReportEngineSettings.ReportEngineSettings.DataSourceTypeEnum,
    "SaveOptionsData.Dml3DEffectsRenderingModeEnum": importedSaveOptionsData.SaveOptionsData.Dml3DEffectsRenderingModeEnum,
    "SaveOptionsData.DmlEffectsRenderingModeEnum": importedSaveOptionsData.SaveOptionsData.DmlEffectsRenderingModeEnum,
    "SaveOptionsData.DmlRenderingModeEnum": importedSaveOptionsData.SaveOptionsData.DmlRenderingModeEnum,
    "SaveOptionsData.ImlRenderingModeEnum": importedSaveOptionsData.SaveOptionsData.ImlRenderingModeEnum,
    "Shading.TextureEnum": importedShading.Shading.TextureEnum,
    "StructuredDocumentTag.LevelEnum": importedStructuredDocumentTag.StructuredDocumentTag.LevelEnum,
    "StructuredDocumentTag.SdtTypeEnum": importedStructuredDocumentTag.StructuredDocumentTag.SdtTypeEnum,
    "StructuredDocumentTagBase.AppearanceEnum": importedStructuredDocumentTagBase.StructuredDocumentTagBase.AppearanceEnum,
    "StructuredDocumentTagBase.DateStorageFormatEnum": importedStructuredDocumentTagBase.StructuredDocumentTagBase.DateStorageFormatEnum,
    "StructuredDocumentTagBase.CalendarTypeEnum": importedStructuredDocumentTagBase.StructuredDocumentTagBase.CalendarTypeEnum,
    "StructuredDocumentTagInsert.LevelEnum": importedStructuredDocumentTagInsert.StructuredDocumentTagInsert.LevelEnum,
    "StructuredDocumentTagInsert.SdtTypeEnum": importedStructuredDocumentTagInsert.StructuredDocumentTagInsert.SdtTypeEnum,
    "Style.TypeEnum": importedStyle.Style.TypeEnum,
    "Style.StyleIdentifierEnum": importedStyle.Style.StyleIdentifierEnum,
    "StyleInsert.StyleTypeEnum": importedStyleInsert.StyleInsert.StyleTypeEnum,
    "SvgSaveOptionsData.TextOutputModeEnum": importedSvgSaveOptionsData.SvgSaveOptionsData.TextOutputModeEnum,
    "TableCellFormat.HorizontalMergeEnum": importedTableCellFormat.TableCellFormat.HorizontalMergeEnum,
    "TableCellFormat.OrientationEnum": importedTableCellFormat.TableCellFormat.OrientationEnum,
    "TableCellFormat.VerticalAlignmentEnum": importedTableCellFormat.TableCellFormat.VerticalAlignmentEnum,
    "TableCellFormat.VerticalMergeEnum": importedTableCellFormat.TableCellFormat.VerticalMergeEnum,
    "TableProperties.AlignmentEnum": importedTableProperties.TableProperties.AlignmentEnum,
    "TableProperties.StyleIdentifierEnum": importedTableProperties.TableProperties.StyleIdentifierEnum,
    "TableProperties.StyleOptionsEnum": importedTableProperties.TableProperties.StyleOptionsEnum,
    "TableProperties.TextWrappingEnum": importedTableProperties.TableProperties.TextWrappingEnum,
    "TableRowFormat.HeightRuleEnum": importedTableRowFormat.TableRowFormat.HeightRuleEnum,
    "TabStopBase.AlignmentEnum": importedTabStopBase.TabStopBase.AlignmentEnum,
    "TabStopBase.LeaderEnum": importedTabStopBase.TabStopBase.LeaderEnum,
    "TextSaveOptionsData.OfficeMathExportModeEnum": importedTextSaveOptionsData.TextSaveOptionsData.OfficeMathExportModeEnum,
    "TiffSaveOptionsData.TiffBinarizationMethodEnum": importedTiffSaveOptionsData.TiffSaveOptionsData.TiffBinarizationMethodEnum,
    "TiffSaveOptionsData.TiffCompressionEnum": importedTiffSaveOptionsData.TiffSaveOptionsData.TiffCompressionEnum,
    "TxtSaveOptionsBaseData.ExportHeadersFootersModeEnum": importedTxtSaveOptionsBaseData.TxtSaveOptionsBaseData.ExportHeadersFootersModeEnum,
    "WatermarkDataText.LayoutEnum": importedWatermarkDataText.WatermarkDataText.LayoutEnum,

};

const typeMap = {
    FileReference: importedFileReference.FileReference,
    ApiError: importedApiError.ApiError,
    AvailableFontsResponse: importedAvailableFontsResponse.AvailableFontsResponse,
    Azw3SaveOptionsData: importedAzw3SaveOptionsData.Azw3SaveOptionsData,
    BmpSaveOptionsData: importedBmpSaveOptionsData.BmpSaveOptionsData,
    Bookmark: importedBookmark.Bookmark,
    BookmarkData: importedBookmarkData.BookmarkData,
    BookmarkInsert: importedBookmarkInsert.BookmarkInsert,
    BookmarkResponse: importedBookmarkResponse.BookmarkResponse,
    Bookmarks: importedBookmarks.Bookmarks,
    BookmarksOutlineLevelData: importedBookmarksOutlineLevelData.BookmarksOutlineLevelData,
    BookmarksResponse: importedBookmarksResponse.BookmarksResponse,
    Border: importedBorder.Border,
    BorderResponse: importedBorderResponse.BorderResponse,
    BordersCollection: importedBordersCollection.BordersCollection,
    BordersResponse: importedBordersResponse.BordersResponse,
    ClassificationResponse: importedClassificationResponse.ClassificationResponse,
    ClassificationResult: importedClassificationResult.ClassificationResult,
    Comment: importedComment.Comment,
    CommentInsert: importedCommentInsert.CommentInsert,
    CommentLink: importedCommentLink.CommentLink,
    CommentRangeEnd: importedCommentRangeEnd.CommentRangeEnd,
    CommentRangeStart: importedCommentRangeStart.CommentRangeStart,
    CommentResponse: importedCommentResponse.CommentResponse,
    CommentsCollection: importedCommentsCollection.CommentsCollection,
    CommentsResponse: importedCommentsResponse.CommentsResponse,
    CommentUpdate: importedCommentUpdate.CommentUpdate,
    CompareData: importedCompareData.CompareData,
    CompareOptions: importedCompareOptions.CompareOptions,
    CompressOptions: importedCompressOptions.CompressOptions,
    CompressResponse: importedCompressResponse.CompressResponse,
    CsvDataLoadOptions: importedCsvDataLoadOptions.CsvDataLoadOptions,
    CustomXmlPart: importedCustomXmlPart.CustomXmlPart,
    CustomXmlPartInsert: importedCustomXmlPartInsert.CustomXmlPartInsert,
    CustomXmlPartLink: importedCustomXmlPartLink.CustomXmlPartLink,
    CustomXmlPartResponse: importedCustomXmlPartResponse.CustomXmlPartResponse,
    CustomXmlPartsCollection: importedCustomXmlPartsCollection.CustomXmlPartsCollection,
    CustomXmlPartsResponse: importedCustomXmlPartsResponse.CustomXmlPartsResponse,
    CustomXmlPartUpdate: importedCustomXmlPartUpdate.CustomXmlPartUpdate,
    DigitalSignatureDetails: importedDigitalSignatureDetails.DigitalSignatureDetails,
    DocmSaveOptionsData: importedDocmSaveOptionsData.DocmSaveOptionsData,
    DocSaveOptionsData: importedDocSaveOptionsData.DocSaveOptionsData,
    Document: importedDocument.Document,
    DocumentEntry: importedDocumentEntry.DocumentEntry,
    DocumentEntryList: importedDocumentEntryList.DocumentEntryList,
    DocumentPosition: importedDocumentPosition.DocumentPosition,
    DocumentProperties: importedDocumentProperties.DocumentProperties,
    DocumentPropertiesResponse: importedDocumentPropertiesResponse.DocumentPropertiesResponse,
    DocumentProperty: importedDocumentProperty.DocumentProperty,
    DocumentPropertyCreateOrUpdate: importedDocumentPropertyCreateOrUpdate.DocumentPropertyCreateOrUpdate,
    DocumentPropertyResponse: importedDocumentPropertyResponse.DocumentPropertyResponse,
    DocumentResponse: importedDocumentResponse.DocumentResponse,
    DocumentStatData: importedDocumentStatData.DocumentStatData,
    DocxSaveOptionsData: importedDocxSaveOptionsData.DocxSaveOptionsData,
    DotmSaveOptionsData: importedDotmSaveOptionsData.DotmSaveOptionsData,
    DotSaveOptionsData: importedDotSaveOptionsData.DotSaveOptionsData,
    DotxSaveOptionsData: importedDotxSaveOptionsData.DotxSaveOptionsData,
    DownsampleOptionsData: importedDownsampleOptionsData.DownsampleOptionsData,
    DrawingObject: importedDrawingObject.DrawingObject,
    DrawingObjectCollection: importedDrawingObjectCollection.DrawingObjectCollection,
    DrawingObjectInsert: importedDrawingObjectInsert.DrawingObjectInsert,
    DrawingObjectLink: importedDrawingObjectLink.DrawingObjectLink,
    DrawingObjectResponse: importedDrawingObjectResponse.DrawingObjectResponse,
    DrawingObjectsResponse: importedDrawingObjectsResponse.DrawingObjectsResponse,
    DrawingObjectUpdate: importedDrawingObjectUpdate.DrawingObjectUpdate,
    EmfSaveOptionsData: importedEmfSaveOptionsData.EmfSaveOptionsData,
    EpsSaveOptionsData: importedEpsSaveOptionsData.EpsSaveOptionsData,
    EpubSaveOptionsData: importedEpubSaveOptionsData.EpubSaveOptionsData,
    Error: importedError.Error,
    ErrorDetails: importedErrorDetails.ErrorDetails,
    Field: importedField.Field,
    FieldCollection: importedFieldCollection.FieldCollection,
    FieldInsert: importedFieldInsert.FieldInsert,
    FieldLink: importedFieldLink.FieldLink,
    FieldNames: importedFieldNames.FieldNames,
    FieldNamesResponse: importedFieldNamesResponse.FieldNamesResponse,
    FieldOptions: importedFieldOptions.FieldOptions,
    FieldResponse: importedFieldResponse.FieldResponse,
    FieldsResponse: importedFieldsResponse.FieldsResponse,
    FieldUpdate: importedFieldUpdate.FieldUpdate,
    FileLink: importedFileLink.FileLink,
    FilesList: importedFilesList.FilesList,
    FilesUploadResult: importedFilesUploadResult.FilesUploadResult,
    FlatOpcMacroSaveOptionsData: importedFlatOpcMacroSaveOptionsData.FlatOpcMacroSaveOptionsData,
    FlatOpcSaveOptionsData: importedFlatOpcSaveOptionsData.FlatOpcSaveOptionsData,
    FlatOpcTemplateMacroSaveOptionsData: importedFlatOpcTemplateMacroSaveOptionsData.FlatOpcTemplateMacroSaveOptionsData,
    FlatOpcTemplateSaveOptionsData: importedFlatOpcTemplateSaveOptionsData.FlatOpcTemplateSaveOptionsData,
    Font: importedFont.Font,
    FontInfo: importedFontInfo.FontInfo,
    FontResponse: importedFontResponse.FontResponse,
    Footnote: importedFootnote.Footnote,
    FootnoteCollection: importedFootnoteCollection.FootnoteCollection,
    FootnoteInsert: importedFootnoteInsert.FootnoteInsert,
    FootnoteLink: importedFootnoteLink.FootnoteLink,
    FootnoteResponse: importedFootnoteResponse.FootnoteResponse,
    FootnotesResponse: importedFootnotesResponse.FootnotesResponse,
    FootnotesStatData: importedFootnotesStatData.FootnotesStatData,
    FootnoteUpdate: importedFootnoteUpdate.FootnoteUpdate,
    FormFieldCheckbox: importedFormFieldCheckbox.FormFieldCheckbox,
    FormFieldCheckboxLink: importedFormFieldCheckboxLink.FormFieldCheckboxLink,
    FormFieldCollection: importedFormFieldCollection.FormFieldCollection,
    FormFieldDropDown: importedFormFieldDropDown.FormFieldDropDown,
    FormFieldDropDownLink: importedFormFieldDropDownLink.FormFieldDropDownLink,
    FormFieldResponse: importedFormFieldResponse.FormFieldResponse,
    FormFieldsResponse: importedFormFieldsResponse.FormFieldsResponse,
    FormFieldTextInput: importedFormFieldTextInput.FormFieldTextInput,
    FormFieldTextInputLink: importedFormFieldTextInputLink.FormFieldTextInputLink,
    GifSaveOptionsData: importedGifSaveOptionsData.GifSaveOptionsData,
    HeaderFooter: importedHeaderFooter.HeaderFooter,
    HeaderFooterLink: importedHeaderFooterLink.HeaderFooterLink,
    HeaderFooterLinkCollection: importedHeaderFooterLinkCollection.HeaderFooterLinkCollection,
    HeaderFooterResponse: importedHeaderFooterResponse.HeaderFooterResponse,
    HeaderFootersResponse: importedHeaderFootersResponse.HeaderFootersResponse,
    HtmlFixedSaveOptionsData: importedHtmlFixedSaveOptionsData.HtmlFixedSaveOptionsData,
    HtmlSaveOptionsData: importedHtmlSaveOptionsData.HtmlSaveOptionsData,
    Hyperlink: importedHyperlink.Hyperlink,
    HyperlinkResponse: importedHyperlinkResponse.HyperlinkResponse,
    Hyperlinks: importedHyperlinks.Hyperlinks,
    HyperlinksResponse: importedHyperlinksResponse.HyperlinksResponse,
    ImageEntry: importedImageEntry.ImageEntry,
    ImageEntryList: importedImageEntryList.ImageEntryList,
    InfoAdditionalItem: importedInfoAdditionalItem.InfoAdditionalItem,
    InfoResponse: importedInfoResponse.InfoResponse,
    JpegSaveOptionsData: importedJpegSaveOptionsData.JpegSaveOptionsData,
    JsonDataLoadOptions: importedJsonDataLoadOptions.JsonDataLoadOptions,
    Link: importedLink.Link,
    LinkElement: importedLinkElement.LinkElement,
    ListFormat: importedListFormat.ListFormat,
    ListFormatUpdate: importedListFormatUpdate.ListFormatUpdate,
    ListInfo: importedListInfo.ListInfo,
    ListInsert: importedListInsert.ListInsert,
    ListLevel: importedListLevel.ListLevel,
    ListLevels: importedListLevels.ListLevels,
    ListLevelUpdate: importedListLevelUpdate.ListLevelUpdate,
    ListResponse: importedListResponse.ListResponse,
    Lists: importedLists.Lists,
    ListsResponse: importedListsResponse.ListsResponse,
    ListUpdate: importedListUpdate.ListUpdate,
    LoadWebDocumentData: importedLoadWebDocumentData.LoadWebDocumentData,
    MarkdownSaveOptionsData: importedMarkdownSaveOptionsData.MarkdownSaveOptionsData,
    MetafileRenderingOptionsData: importedMetafileRenderingOptionsData.MetafileRenderingOptionsData,
    MhtmlSaveOptionsData: importedMhtmlSaveOptionsData.MhtmlSaveOptionsData,
    ModificationOperationResult: importedModificationOperationResult.ModificationOperationResult,
    NodeLink: importedNodeLink.NodeLink,
    OdtSaveOptionsData: importedOdtSaveOptionsData.OdtSaveOptionsData,
    OfficeMathLink: importedOfficeMathLink.OfficeMathLink,
    OfficeMathObject: importedOfficeMathObject.OfficeMathObject,
    OfficeMathObjectResponse: importedOfficeMathObjectResponse.OfficeMathObjectResponse,
    OfficeMathObjectsCollection: importedOfficeMathObjectsCollection.OfficeMathObjectsCollection,
    OfficeMathObjectsResponse: importedOfficeMathObjectsResponse.OfficeMathObjectsResponse,
    OpenXpsSaveOptionsData: importedOpenXpsSaveOptionsData.OpenXpsSaveOptionsData,
    OptimizationOptions: importedOptimizationOptions.OptimizationOptions,
    OttSaveOptionsData: importedOttSaveOptionsData.OttSaveOptionsData,
    OutlineOptionsData: importedOutlineOptionsData.OutlineOptionsData,
    PageNumber: importedPageNumber.PageNumber,
    PageSetup: importedPageSetup.PageSetup,
    PageStatData: importedPageStatData.PageStatData,
    Paragraph: importedParagraph.Paragraph,
    ParagraphFormat: importedParagraphFormat.ParagraphFormat,
    ParagraphFormatResponse: importedParagraphFormatResponse.ParagraphFormatResponse,
    ParagraphFormatUpdate: importedParagraphFormatUpdate.ParagraphFormatUpdate,
    ParagraphInsert: importedParagraphInsert.ParagraphInsert,
    ParagraphLink: importedParagraphLink.ParagraphLink,
    ParagraphLinkCollection: importedParagraphLinkCollection.ParagraphLinkCollection,
    ParagraphLinkCollectionResponse: importedParagraphLinkCollectionResponse.ParagraphLinkCollectionResponse,
    ParagraphListFormatResponse: importedParagraphListFormatResponse.ParagraphListFormatResponse,
    ParagraphResponse: importedParagraphResponse.ParagraphResponse,
    PclSaveOptionsData: importedPclSaveOptionsData.PclSaveOptionsData,
    PdfDigitalSignatureDetailsData: importedPdfDigitalSignatureDetailsData.PdfDigitalSignatureDetailsData,
    PdfEncryptionDetailsData: importedPdfEncryptionDetailsData.PdfEncryptionDetailsData,
    PdfPermissions: importedPdfPermissions.PdfPermissions,
    PdfSaveOptionsData: importedPdfSaveOptionsData.PdfSaveOptionsData,
    PngSaveOptionsData: importedPngSaveOptionsData.PngSaveOptionsData,
    PositionAfterNode: importedPositionAfterNode.PositionAfterNode,
    PositionBeforeNode: importedPositionBeforeNode.PositionBeforeNode,
    PositionInsideNode: importedPositionInsideNode.PositionInsideNode,
    PreferredWidth: importedPreferredWidth.PreferredWidth,
    ProtectionData: importedProtectionData.ProtectionData,
    ProtectionDataResponse: importedProtectionDataResponse.ProtectionDataResponse,
    ProtectionRequest: importedProtectionRequest.ProtectionRequest,
    ProtectionRequestV2: importedProtectionRequestV2.ProtectionRequestV2,
    PsSaveOptionsData: importedPsSaveOptionsData.PsSaveOptionsData,
    PublicKeyResponse: importedPublicKeyResponse.PublicKeyResponse,
    RangeDocument: importedRangeDocument.RangeDocument,
    RangeTextResponse: importedRangeTextResponse.RangeTextResponse,
    ReplaceRange: importedReplaceRange.ReplaceRange,
    ReplaceTextParameters: importedReplaceTextParameters.ReplaceTextParameters,
    ReplaceTextResponse: importedReplaceTextResponse.ReplaceTextResponse,
    ReportBuildOptions: importedReportBuildOptions.ReportBuildOptions,
    ReportEngineSettings: importedReportEngineSettings.ReportEngineSettings,
    Revision: importedRevision.Revision,
    RevisionCollection: importedRevisionCollection.RevisionCollection,
    RevisionsModificationResponse: importedRevisionsModificationResponse.RevisionsModificationResponse,
    RevisionsResponse: importedRevisionsResponse.RevisionsResponse,
    RtfSaveOptionsData: importedRtfSaveOptionsData.RtfSaveOptionsData,
    Run: importedRun.Run,
    RunInsert: importedRunInsert.RunInsert,
    RunLink: importedRunLink.RunLink,
    RunResponse: importedRunResponse.RunResponse,
    Runs: importedRuns.Runs,
    RunsResponse: importedRunsResponse.RunsResponse,
    RunUpdate: importedRunUpdate.RunUpdate,
    SaveResponse: importedSaveResponse.SaveResponse,
    SaveResult: importedSaveResult.SaveResult,
    SearchResponse: importedSearchResponse.SearchResponse,
    SearchResult: importedSearchResult.SearchResult,
    SearchResultsCollection: importedSearchResultsCollection.SearchResultsCollection,
    Section: importedSection.Section,
    SectionLink: importedSectionLink.SectionLink,
    SectionLinkCollection: importedSectionLinkCollection.SectionLinkCollection,
    SectionLinkCollectionResponse: importedSectionLinkCollectionResponse.SectionLinkCollectionResponse,
    SectionPageSetupResponse: importedSectionPageSetupResponse.SectionPageSetupResponse,
    SectionResponse: importedSectionResponse.SectionResponse,
    Shading: importedShading.Shading,
    Signature: importedSignature.Signature,
    SignatureCollectionResponse: importedSignatureCollectionResponse.SignatureCollectionResponse,
    SignOptions: importedSignOptions.SignOptions,
    SplitDocumentResponse: importedSplitDocumentResponse.SplitDocumentResponse,
    SplitDocumentResult: importedSplitDocumentResult.SplitDocumentResult,
    StatDataResponse: importedStatDataResponse.StatDataResponse,
    StorageFile: importedStorageFile.StorageFile,
    StoryChildNodes: importedStoryChildNodes.StoryChildNodes,
    StructuredDocumentTag: importedStructuredDocumentTag.StructuredDocumentTag,
    StructuredDocumentTagCollection: importedStructuredDocumentTagCollection.StructuredDocumentTagCollection,
    StructuredDocumentTagInsert: importedStructuredDocumentTagInsert.StructuredDocumentTagInsert,
    StructuredDocumentTagListItem: importedStructuredDocumentTagListItem.StructuredDocumentTagListItem,
    StructuredDocumentTagResponse: importedStructuredDocumentTagResponse.StructuredDocumentTagResponse,
    StructuredDocumentTagsResponse: importedStructuredDocumentTagsResponse.StructuredDocumentTagsResponse,
    StructuredDocumentTagUpdate: importedStructuredDocumentTagUpdate.StructuredDocumentTagUpdate,
    Style: importedStyle.Style,
    StyleApply: importedStyleApply.StyleApply,
    StyleCopy: importedStyleCopy.StyleCopy,
    StyleInsert: importedStyleInsert.StyleInsert,
    StyleResponse: importedStyleResponse.StyleResponse,
    StylesResponse: importedStylesResponse.StylesResponse,
    StyleUpdate: importedStyleUpdate.StyleUpdate,
    SvgSaveOptionsData: importedSvgSaveOptionsData.SvgSaveOptionsData,
    Table: importedTable.Table,
    TableCell: importedTableCell.TableCell,
    TableCellFormat: importedTableCellFormat.TableCellFormat,
    TableCellFormatResponse: importedTableCellFormatResponse.TableCellFormatResponse,
    TableCellInsert: importedTableCellInsert.TableCellInsert,
    TableCellResponse: importedTableCellResponse.TableCellResponse,
    TableInsert: importedTableInsert.TableInsert,
    TableLink: importedTableLink.TableLink,
    TableLinkCollection: importedTableLinkCollection.TableLinkCollection,
    TableLinkCollectionResponse: importedTableLinkCollectionResponse.TableLinkCollectionResponse,
    TableProperties: importedTableProperties.TableProperties,
    TablePropertiesResponse: importedTablePropertiesResponse.TablePropertiesResponse,
    TableResponse: importedTableResponse.TableResponse,
    TableRow: importedTableRow.TableRow,
    TableRowFormat: importedTableRowFormat.TableRowFormat,
    TableRowFormatResponse: importedTableRowFormatResponse.TableRowFormatResponse,
    TableRowInsert: importedTableRowInsert.TableRowInsert,
    TableRowResponse: importedTableRowResponse.TableRowResponse,
    TabStop: importedTabStop.TabStop,
    TabStopInsert: importedTabStopInsert.TabStopInsert,
    TabStopsResponse: importedTabStopsResponse.TabStopsResponse,
    TextSaveOptionsData: importedTextSaveOptionsData.TextSaveOptionsData,
    TiffSaveOptionsData: importedTiffSaveOptionsData.TiffSaveOptionsData,
    TimeZoneInfoData: importedTimeZoneInfoData.TimeZoneInfoData,
    TranslateNodeIdResponse: importedTranslateNodeIdResponse.TranslateNodeIdResponse,
    UserInformation: importedUserInformation.UserInformation,
    WatermarkDataImage: importedWatermarkDataImage.WatermarkDataImage,
    WatermarkDataText: importedWatermarkDataText.WatermarkDataText,
    WatermarkText: importedWatermarkText.WatermarkText,
    WordMLSaveOptionsData: importedWordMLSaveOptionsData.WordMLSaveOptionsData,
    WordsApiErrorResponse: importedWordsApiErrorResponse.WordsApiErrorResponse,
    WordsApiLink: importedWordsApiLink.WordsApiLink,
    WordsResponse: importedWordsResponse.WordsResponse,
    XamlFixedSaveOptionsData: importedXamlFixedSaveOptionsData.XamlFixedSaveOptionsData,
    XamlFlowPackSaveOptionsData: importedXamlFlowPackSaveOptionsData.XamlFlowPackSaveOptionsData,
    XamlFlowSaveOptionsData: importedXamlFlowSaveOptionsData.XamlFlowSaveOptionsData,
    XmlColor: importedXmlColor.XmlColor,
    XmlDataLoadOptions: importedXmlDataLoadOptions.XmlDataLoadOptions,
    XpsSaveOptionsData: importedXpsSaveOptionsData.XpsSaveOptionsData
};

/**
 * Request interface.
 */
export interface RequestInterface {
	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	createRequestOptions(configuration: Configuration, encryptor: Encryptor) : Promise<request.OptionsWithUri>;

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any;
}

/**
 * Create unique request id
 */
export function createUid(): string {
    return uuidv4();
}

export {enumsMap, typeMap};

/**
 * Request model for AcceptAllRevisions operation.
 * Accepts all revisions in the document.
 */
export class AcceptAllRevisionsRequest implements RequestInterface {

    public constructor(init?: Partial< AcceptAllRevisionsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/revisions/acceptAll"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling acceptAllRevisions.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling acceptAllRevisions.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RevisionsModificationResponse");
	}
}

/**
 * Request model for AcceptAllRevisionsOnline operation.
 * Accepts all revisions in the document.
 */
export class AcceptAllRevisionsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< AcceptAllRevisionsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/revisions/acceptAll"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling acceptAllRevisionsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling acceptAllRevisionsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new AcceptAllRevisionsOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "RevisionsModificationResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for AppendDocument operation.
 * Appends documents to the original document.
 */
export class AppendDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< AppendDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * <see cref="BaseEntryList"/> with a list of entries to append.
     */
    public documentList: importedBaseEntryList.BaseEntryList;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/appendDocument"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling appendDocument.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling appendDocument.');
        }
        // verify required parameter 'this.documentList' is not undefined
        if (this.documentList === undefined) {
            throw new Error('Required parameter "this.documentList" was undefined when calling appendDocument.');
        }

        // verify required parameter 'this.documentList' is not null
        if (this.documentList === null) {
            throw new Error('Required parameter "this.documentList" was null when calling appendDocument.');
        }
        this.documentList?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.documentList !== undefined) {
            let _obj = ObjectSerializer.serialize(this.documentList, this.documentList.constructor.name === "Object" ? "importedBaseEntryList.BaseEntryList" : this.documentList.constructor.name);
            formParams.push(['DocumentList', JSON.stringify(_obj), 'application/json']);
            this.documentList.collectFilesContent(filesContent);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for AppendDocumentOnline operation.
 * Appends documents to the original document.
 */
export class AppendDocumentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< AppendDocumentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * Original document.
     */
    public document: Readable;

    /**
     * <see cref="BaseEntryList"/> with a list of entries to append.
     */
    public documentList: importedBaseEntryList.BaseEntryList;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/appendDocument"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling appendDocumentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling appendDocumentOnline.');
        }
        // verify required parameter 'this.documentList' is not undefined
        if (this.documentList === undefined) {
            throw new Error('Required parameter "this.documentList" was undefined when calling appendDocumentOnline.');
        }

        // verify required parameter 'this.documentList' is not null
        if (this.documentList === null) {
            throw new Error('Required parameter "this.documentList" was null when calling appendDocumentOnline.');
        }
        this.documentList?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.documentList !== undefined) {
            let _obj = ObjectSerializer.serialize(this.documentList, this.documentList.constructor.name === "Object" ? "importedBaseEntryList.BaseEntryList" : this.documentList.constructor.name);
            formParams.push(['DocumentList', JSON.stringify(_obj), 'application/json']);
            this.documentList.collectFilesContent(filesContent);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new AppendDocumentOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for ApplyStyleToDocumentElement operation.
 * Applies a style to the document node.
 */
export class ApplyStyleToDocumentElementRequest implements RequestInterface {

    public constructor(init?: Partial< ApplyStyleToDocumentElementRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree, that supports styles: ParagraphFormat, List, ListLevel, Table.
     */
    public styledNodePath: string;

    /**
     * Style to apply.
     */
    public styleApply: importedStyleApply.StyleApply;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{styledNodePath}/style"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "styledNodePath" + "}", (this.styledNodePath !== null && this.styledNodePath !== undefined) ? "/" + String(this.styledNodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling applyStyleToDocumentElement.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling applyStyleToDocumentElement.');
        }
        // verify required parameter 'this.styledNodePath' is not undefined
        if (this.styledNodePath === undefined) {
            throw new Error('Required parameter "this.styledNodePath" was undefined when calling applyStyleToDocumentElement.');
        }

        // verify required parameter 'this.styledNodePath' is not null
        if (this.styledNodePath === null) {
            throw new Error('Required parameter "this.styledNodePath" was null when calling applyStyleToDocumentElement.');
        }
        // verify required parameter 'this.styleApply' is not undefined
        if (this.styleApply === undefined) {
            throw new Error('Required parameter "this.styleApply" was undefined when calling applyStyleToDocumentElement.');
        }

        // verify required parameter 'this.styleApply' is not null
        if (this.styleApply === null) {
            throw new Error('Required parameter "this.styleApply" was null when calling applyStyleToDocumentElement.');
        }
        this.styleApply?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.styleApply !== undefined) {
            let _obj = ObjectSerializer.serialize(this.styleApply, this.styleApply.constructor.name === "Object" ? "importedStyleApply.StyleApply" : this.styleApply.constructor.name);
            formParams.push(['StyleApply', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "WordsResponse");
	}
}

/**
 * Request model for ApplyStyleToDocumentElementOnline operation.
 * Applies a style to the document node.
 */
export class ApplyStyleToDocumentElementOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< ApplyStyleToDocumentElementOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree, that supports styles: ParagraphFormat, List, ListLevel, Table.
     */
    public styledNodePath: string;

    /**
     * Style to apply.
     */
    public styleApply: importedStyleApply.StyleApply;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{styledNodePath}/style"
            .replace("/{" + "styledNodePath" + "}", (this.styledNodePath !== null && this.styledNodePath !== undefined) ? "/" + String(this.styledNodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling applyStyleToDocumentElementOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling applyStyleToDocumentElementOnline.');
        }
        // verify required parameter 'this.styledNodePath' is not undefined
        if (this.styledNodePath === undefined) {
            throw new Error('Required parameter "this.styledNodePath" was undefined when calling applyStyleToDocumentElementOnline.');
        }

        // verify required parameter 'this.styledNodePath' is not null
        if (this.styledNodePath === null) {
            throw new Error('Required parameter "this.styledNodePath" was null when calling applyStyleToDocumentElementOnline.');
        }
        // verify required parameter 'this.styleApply' is not undefined
        if (this.styleApply === undefined) {
            throw new Error('Required parameter "this.styleApply" was undefined when calling applyStyleToDocumentElementOnline.');
        }

        // verify required parameter 'this.styleApply' is not null
        if (this.styleApply === null) {
            throw new Error('Required parameter "this.styleApply" was null when calling applyStyleToDocumentElementOnline.');
        }
        this.styleApply?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.styleApply !== undefined) {
            let _obj = ObjectSerializer.serialize(this.styleApply, this.styleApply.constructor.name === "Object" ? "importedStyleApply.StyleApply" : this.styleApply.constructor.name);
            formParams.push(['StyleApply', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new ApplyStyleToDocumentElementOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "WordsResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for BuildReport operation.
 * Executes the report generation process using the specified document template and the external data source in XML, JSON or CSV format.
 */
export class BuildReportRequest implements RequestInterface {

    public constructor(init?: Partial< BuildReportRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * A string providing a data to populate the specified template. The string must be of one of the following types: xml, json, csv.
     */
    public data: string;

    /**
     * An object providing a settings of report engine.
     */
    public reportEngineSettings: importedReportEngineSettings.ReportEngineSettings;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The filename of the output document. If this parameter is omitted, the result will be saved with autogenerated name.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/buildReport"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling buildReport.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling buildReport.');
        }
        // verify required parameter 'this.data' is not undefined
        if (this.data === undefined) {
            throw new Error('Required parameter "this.data" was undefined when calling buildReport.');
        }

        // verify required parameter 'this.data' is not null
        if (this.data === null) {
            throw new Error('Required parameter "this.data" was null when calling buildReport.');
        }
        // verify required parameter 'this.reportEngineSettings' is not undefined
        if (this.reportEngineSettings === undefined) {
            throw new Error('Required parameter "this.reportEngineSettings" was undefined when calling buildReport.');
        }

        // verify required parameter 'this.reportEngineSettings' is not null
        if (this.reportEngineSettings === null) {
            throw new Error('Required parameter "this.reportEngineSettings" was null when calling buildReport.');
        }
        this.reportEngineSettings?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.data !== undefined) {
            formParams.push(['Data', this.data, 'text/plain']);
        }
        if (this.reportEngineSettings !== undefined) {
            let _obj = ObjectSerializer.serialize(this.reportEngineSettings, this.reportEngineSettings.constructor.name === "Object" ? "importedReportEngineSettings.ReportEngineSettings" : this.reportEngineSettings.constructor.name);
            formParams.push(['ReportEngineSettings', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for BuildReportOnline operation.
 * Executes the report generation process online using the specified document template and the external data source in XML, JSON or CSV format.
 */
export class BuildReportOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< BuildReportOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * File with template.
     */
    public template: Readable;

    /**
     * A string providing a data to populate the specified template. The string must be of one of the following types: xml, json, csv.
     */
    public data: string;

    /**
     * An object providing a settings of report engine.
     */
    public reportEngineSettings: importedReportEngineSettings.ReportEngineSettings;

    /**
     * The filename of the output document, that will be used when the resulting document has a dynamic field {filename}. If it is not set, the "template" will be used instead.
     */
    public documentFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/buildReport"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.template' is not undefined
        if (this.template === undefined) {
            throw new Error('Required parameter "this.template" was undefined when calling buildReportOnline.');
        }

        // verify required parameter 'this.template' is not null
        if (this.template === null) {
            throw new Error('Required parameter "this.template" was null when calling buildReportOnline.');
        }
        // verify required parameter 'this.data' is not undefined
        if (this.data === undefined) {
            throw new Error('Required parameter "this.data" was undefined when calling buildReportOnline.');
        }

        // verify required parameter 'this.data' is not null
        if (this.data === null) {
            throw new Error('Required parameter "this.data" was null when calling buildReportOnline.');
        }
        // verify required parameter 'this.reportEngineSettings' is not undefined
        if (this.reportEngineSettings === undefined) {
            throw new Error('Required parameter "this.reportEngineSettings" was undefined when calling buildReportOnline.');
        }

        // verify required parameter 'this.reportEngineSettings' is not null
        if (this.reportEngineSettings === null) {
            throw new Error('Required parameter "this.reportEngineSettings" was null when calling buildReportOnline.');
        }
        this.reportEngineSettings?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "documentFileName", this.documentFileName, _encryptor);
        if (this.template !== undefined) {
            formParams.push(['Template', this.template, 'application/octet-stream']);
        }
        if (this.data !== undefined) {
            formParams.push(['Data', this.data, 'text/plain']);
        }
        if (this.reportEngineSettings !== undefined) {
            let _obj = ObjectSerializer.serialize(this.reportEngineSettings, this.reportEngineSettings.constructor.name === "Object" ? "importedReportEngineSettings.ReportEngineSettings" : this.reportEngineSettings.constructor.name);
            formParams.push(['ReportEngineSettings', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for Classify operation.
 * Runs a multi-class text classification for the specified raw text.
 */
export class ClassifyRequest implements RequestInterface {

    public constructor(init?: Partial< ClassifyRequest >) {
        Object.assign(this, init);
    }

    /**
     * The text to classify.
     */
    public text: string;

    /**
     * The number of the best classes to return.
     */
    public bestClassesCount: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/classify"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.text' is not undefined
        if (this.text === undefined) {
            throw new Error('Required parameter "this.text" was undefined when calling classify.');
        }

        // verify required parameter 'this.text' is not null
        if (this.text === null) {
            throw new Error('Required parameter "this.text" was null when calling classify.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "bestClassesCount", this.bestClassesCount, _encryptor);
        if (this.text !== undefined) {
            formParams.push(['Text', this.text, 'text/plain']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ClassificationResponse");
	}
}

/**
 * Request model for ClassifyDocument operation.
 * Runs a multi-class text classification for the document.
 */
export class ClassifyDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< ClassifyDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document name.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The number of the best classes to return.
     */
    public bestClassesCount: string;

    /**
     * The taxonomy to use.
     */
    public taxonomy: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/classify"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling classifyDocument.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling classifyDocument.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "bestClassesCount", this.bestClassesCount, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "taxonomy", this.taxonomy, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ClassificationResponse");
	}
}

/**
 * Request model for ClassifyDocumentOnline operation.
 * Runs a multi-class text classification for the document.
 */
export class ClassifyDocumentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< ClassifyDocumentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The number of the best classes to return.
     */
    public bestClassesCount: string;

    /**
     * The taxonomy to use.
     */
    public taxonomy: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/classify"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling classifyDocumentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling classifyDocumentOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "bestClassesCount", this.bestClassesCount, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "taxonomy", this.taxonomy, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ClassificationResponse");
	}
}

/**
 * Request model for CompareDocument operation.
 * Compares two documents.
 */
export class CompareDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< CompareDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Compare data.
     */
    public compareData: importedCompareData.CompareData;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/compareDocument"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling compareDocument.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling compareDocument.');
        }
        // verify required parameter 'this.compareData' is not undefined
        if (this.compareData === undefined) {
            throw new Error('Required parameter "this.compareData" was undefined when calling compareDocument.');
        }

        // verify required parameter 'this.compareData' is not null
        if (this.compareData === null) {
            throw new Error('Required parameter "this.compareData" was null when calling compareDocument.');
        }
        this.compareData?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.compareData !== undefined) {
            let _obj = ObjectSerializer.serialize(this.compareData, this.compareData.constructor.name === "Object" ? "importedCompareData.CompareData" : this.compareData.constructor.name);
            formParams.push(['CompareData', JSON.stringify(_obj), 'application/json']);
            this.compareData.collectFilesContent(filesContent);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for CompareDocumentOnline operation.
 * Compares two documents.
 */
export class CompareDocumentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< CompareDocumentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Compare data.
     */
    public compareData: importedCompareData.CompareData;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/compareDocument"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling compareDocumentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling compareDocumentOnline.');
        }
        // verify required parameter 'this.compareData' is not undefined
        if (this.compareData === undefined) {
            throw new Error('Required parameter "this.compareData" was undefined when calling compareDocumentOnline.');
        }

        // verify required parameter 'this.compareData' is not null
        if (this.compareData === null) {
            throw new Error('Required parameter "this.compareData" was null when calling compareDocumentOnline.');
        }
        this.compareData?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.compareData !== undefined) {
            let _obj = ObjectSerializer.serialize(this.compareData, this.compareData.constructor.name === "Object" ? "importedCompareData.CompareData" : this.compareData.constructor.name);
            formParams.push(['CompareData', JSON.stringify(_obj), 'application/json']);
            this.compareData.collectFilesContent(filesContent);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new CompareDocumentOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for CompressDocument operation.
 * Compress and resize images inside the document.
 * The default settings allows to reduce the size of the document without any visible degradation of images quality.
 */
export class CompressDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< CompressDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Options for compress the document.
     */
    public compressOptions: importedCompressOptions.CompressOptions;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/compress"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling compressDocument.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling compressDocument.');
        }
        // verify required parameter 'this.compressOptions' is not undefined
        if (this.compressOptions === undefined) {
            throw new Error('Required parameter "this.compressOptions" was undefined when calling compressDocument.');
        }

        // verify required parameter 'this.compressOptions' is not null
        if (this.compressOptions === null) {
            throw new Error('Required parameter "this.compressOptions" was null when calling compressDocument.');
        }
        this.compressOptions?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.compressOptions !== undefined) {
            let _obj = ObjectSerializer.serialize(this.compressOptions, this.compressOptions.constructor.name === "Object" ? "importedCompressOptions.CompressOptions" : this.compressOptions.constructor.name);
            formParams.push(['CompressOptions', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CompressResponse");
	}
}

/**
 * Request model for CompressDocumentOnline operation.
 * Compress and resize images inside the document.
 * The default settings allows to reduce the size of the document without any visible degradation of images quality.
 */
export class CompressDocumentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< CompressDocumentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Options for compress the document.
     */
    public compressOptions: importedCompressOptions.CompressOptions;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/compress"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling compressDocumentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling compressDocumentOnline.');
        }
        // verify required parameter 'this.compressOptions' is not undefined
        if (this.compressOptions === undefined) {
            throw new Error('Required parameter "this.compressOptions" was undefined when calling compressDocumentOnline.');
        }

        // verify required parameter 'this.compressOptions' is not null
        if (this.compressOptions === null) {
            throw new Error('Required parameter "this.compressOptions" was null when calling compressDocumentOnline.');
        }
        this.compressOptions?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.compressOptions !== undefined) {
            let _obj = ObjectSerializer.serialize(this.compressOptions, this.compressOptions.constructor.name === "Object" ? "importedCompressOptions.CompressOptions" : this.compressOptions.constructor.name);
            formParams.push(['CompressOptions', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new CompressDocumentOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "CompressResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for ConvertDocument operation.
 * Converts a document on a local drive to the specified format.
 */
export class ConvertDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< ConvertDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * Converting document.
     */
    public document: Readable;

    /**
     * The format to convert.
     */
    public format: string;

    /**
     * The path to the output document on a local storage.
     */
    public outPath: string;

    /**
     * The filename of the output document, that will be used when the resulting document has a dynamic field {filename}. If it is not set, the "sourceFilename" will be used instead.
     */
    public fileNameFieldValue: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/convert"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling convertDocument.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling convertDocument.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling convertDocument.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling convertDocument.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fileNameFieldValue", this.fileNameFieldValue, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for CopyFile operation.
 * Copy file.
 */
export class CopyFileRequest implements RequestInterface {

    public constructor(init?: Partial< CopyFileRequest >) {
        Object.assign(this, init);
    }

    /**
     * Destination file path.
     */
    public destPath: string;

    /**
     * Source file's path e.g. '/Folder 1/file.ext' or '/Bucket/Folder 1/file.ext'.
     */
    public srcPath: string;

    /**
     * Source storage name.
     */
    public srcStorageName: string;

    /**
     * Destination storage name.
     */
    public destStorageName: string;

    /**
     * File version ID to copy.
     */
    public versionId: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/storage/file/copy/{srcPath}"
            .replace("/{" + "srcPath" + "}", (this.srcPath !== null && this.srcPath !== undefined) ? "/" + String(this.srcPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.destPath' is not undefined
        if (this.destPath === undefined) {
            throw new Error('Required parameter "this.destPath" was undefined when calling copyFile.');
        }

        // verify required parameter 'this.destPath' is not null
        if (this.destPath === null) {
            throw new Error('Required parameter "this.destPath" was null when calling copyFile.');
        }
        // verify required parameter 'this.srcPath' is not undefined
        if (this.srcPath === undefined) {
            throw new Error('Required parameter "this.srcPath" was undefined when calling copyFile.');
        }

        // verify required parameter 'this.srcPath' is not null
        if (this.srcPath === null) {
            throw new Error('Required parameter "this.srcPath" was null when calling copyFile.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for CopyFolder operation.
 * Copy folder.
 */
export class CopyFolderRequest implements RequestInterface {

    public constructor(init?: Partial< CopyFolderRequest >) {
        Object.assign(this, init);
    }

    /**
     * Destination folder path e.g. '/dst'.
     */
    public destPath: string;

    /**
     * Source folder path e.g. /Folder1.
     */
    public srcPath: string;

    /**
     * Source storage name.
     */
    public srcStorageName: string;

    /**
     * Destination storage name.
     */
    public destStorageName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/storage/folder/copy/{srcPath}"
            .replace("/{" + "srcPath" + "}", (this.srcPath !== null && this.srcPath !== undefined) ? "/" + String(this.srcPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.destPath' is not undefined
        if (this.destPath === undefined) {
            throw new Error('Required parameter "this.destPath" was undefined when calling copyFolder.');
        }

        // verify required parameter 'this.destPath' is not null
        if (this.destPath === null) {
            throw new Error('Required parameter "this.destPath" was null when calling copyFolder.');
        }
        // verify required parameter 'this.srcPath' is not undefined
        if (this.srcPath === undefined) {
            throw new Error('Required parameter "this.srcPath" was undefined when calling copyFolder.');
        }

        // verify required parameter 'this.srcPath' is not null
        if (this.srcPath === null) {
            throw new Error('Required parameter "this.srcPath" was null when calling copyFolder.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for CopyStyle operation.
 * Makes a copy of the style in the document.
 */
export class CopyStyleRequest implements RequestInterface {

    public constructor(init?: Partial< CopyStyleRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Style to copy.
     */
    public styleCopy: importedStyleCopy.StyleCopy;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles/copy"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling copyStyle.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling copyStyle.');
        }
        // verify required parameter 'this.styleCopy' is not undefined
        if (this.styleCopy === undefined) {
            throw new Error('Required parameter "this.styleCopy" was undefined when calling copyStyle.');
        }

        // verify required parameter 'this.styleCopy' is not null
        if (this.styleCopy === null) {
            throw new Error('Required parameter "this.styleCopy" was null when calling copyStyle.');
        }
        this.styleCopy?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.styleCopy !== undefined) {
            let _obj = ObjectSerializer.serialize(this.styleCopy, this.styleCopy.constructor.name === "Object" ? "importedStyleCopy.StyleCopy" : this.styleCopy.constructor.name);
            formParams.push(['StyleCopy', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
	}
}

/**
 * Request model for CopyStyleOnline operation.
 * Makes a copy of the style in the document.
 */
export class CopyStyleOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< CopyStyleOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Style to copy.
     */
    public styleCopy: importedStyleCopy.StyleCopy;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/styles/copy"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling copyStyleOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling copyStyleOnline.');
        }
        // verify required parameter 'this.styleCopy' is not undefined
        if (this.styleCopy === undefined) {
            throw new Error('Required parameter "this.styleCopy" was undefined when calling copyStyleOnline.');
        }

        // verify required parameter 'this.styleCopy' is not null
        if (this.styleCopy === null) {
            throw new Error('Required parameter "this.styleCopy" was null when calling copyStyleOnline.');
        }
        this.styleCopy?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.styleCopy !== undefined) {
            let _obj = ObjectSerializer.serialize(this.styleCopy, this.styleCopy.constructor.name === "Object" ? "importedStyleCopy.StyleCopy" : this.styleCopy.constructor.name);
            formParams.push(['StyleCopy', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new CopyStyleOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "StyleResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for CopyStylesFromTemplate operation.
 * Copies styles from the origin document to the target document.
 */
export class CopyStylesFromTemplateRequest implements RequestInterface {

    public constructor(init?: Partial< CopyStylesFromTemplateRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the target document.
     */
    public name: string;

    /**
     * The filename of the origin document.
     */
    public templateName: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles/copy_from"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling copyStylesFromTemplate.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling copyStylesFromTemplate.');
        }
        // verify required parameter 'this.templateName' is not undefined
        if (this.templateName === undefined) {
            throw new Error('Required parameter "this.templateName" was undefined when calling copyStylesFromTemplate.');
        }

        // verify required parameter 'this.templateName' is not null
        if (this.templateName === null) {
            throw new Error('Required parameter "this.templateName" was null when calling copyStylesFromTemplate.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "templateName", this.templateName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "WordsResponse");
	}
}

/**
 * Request model for CreateDocument operation.
 * Creates a new document in cloud storage in the format, determined by the file extension.
 * Supported all save format extensions.
 */
export class CreateDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< CreateDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the document.
     */
    public fileName: string;

    /**
     * The path to the document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/create"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.fileName' is not undefined
        if (this.fileName === undefined) {
            throw new Error('Required parameter "this.fileName" was undefined when calling createDocument.');
        }

        // verify required parameter 'this.fileName' is not null
        if (this.fileName === null) {
            throw new Error('Required parameter "this.fileName" was null when calling createDocument.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fileName", this.fileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for CreateFolder operation.
 * Create the folder.
 */
export class CreateFolderRequest implements RequestInterface {

    public constructor(init?: Partial< CreateFolderRequest >) {
        Object.assign(this, init);
    }

    /**
     * Target folder's path e.g. Folder1/Folder2/. The folders will be created recursively.
     */
    public path: string;

    /**
     * Storage name.
     */
    public storageName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/storage/folder/{path}"
            .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.path' is not undefined
        if (this.path === undefined) {
            throw new Error('Required parameter "this.path" was undefined when calling createFolder.');
        }

        // verify required parameter 'this.path' is not null
        if (this.path === null) {
            throw new Error('Required parameter "this.path" was null when calling createFolder.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for CreateOrUpdateDocumentProperty operation.
 * Adds a new or updates an existing document property.
 */
export class CreateOrUpdateDocumentPropertyRequest implements RequestInterface {

    public constructor(init?: Partial< CreateOrUpdateDocumentPropertyRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The name of the property.
     */
    public propertyName: string;

    /**
     * The property with new value.
     */
    public property: importedDocumentPropertyCreateOrUpdate.DocumentPropertyCreateOrUpdate;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/documentProperties/{propertyName}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling createOrUpdateDocumentProperty.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling createOrUpdateDocumentProperty.');
        }
        // verify required parameter 'this.propertyName' is not undefined
        if (this.propertyName === undefined) {
            throw new Error('Required parameter "this.propertyName" was undefined when calling createOrUpdateDocumentProperty.');
        }

        // verify required parameter 'this.propertyName' is not null
        if (this.propertyName === null) {
            throw new Error('Required parameter "this.propertyName" was null when calling createOrUpdateDocumentProperty.');
        }
        // verify required parameter 'this.property' is not undefined
        if (this.property === undefined) {
            throw new Error('Required parameter "this.property" was undefined when calling createOrUpdateDocumentProperty.');
        }

        // verify required parameter 'this.property' is not null
        if (this.property === null) {
            throw new Error('Required parameter "this.property" was null when calling createOrUpdateDocumentProperty.');
        }
        this.property?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.property !== undefined) {
            let _obj = ObjectSerializer.serialize(this.property, this.property.constructor.name === "Object" ? "importedDocumentPropertyCreateOrUpdate.DocumentPropertyCreateOrUpdate" : this.property.constructor.name);
            formParams.push(['Property', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentPropertyResponse");
	}
}

/**
 * Request model for CreateOrUpdateDocumentPropertyOnline operation.
 * Adds a new or updates an existing document property.
 */
export class CreateOrUpdateDocumentPropertyOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< CreateOrUpdateDocumentPropertyOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The name of the property.
     */
    public propertyName: string;

    /**
     * The property with new value.
     */
    public property: importedDocumentPropertyCreateOrUpdate.DocumentPropertyCreateOrUpdate;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/documentProperties/{propertyName}"
            .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling createOrUpdateDocumentPropertyOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling createOrUpdateDocumentPropertyOnline.');
        }
        // verify required parameter 'this.propertyName' is not undefined
        if (this.propertyName === undefined) {
            throw new Error('Required parameter "this.propertyName" was undefined when calling createOrUpdateDocumentPropertyOnline.');
        }

        // verify required parameter 'this.propertyName' is not null
        if (this.propertyName === null) {
            throw new Error('Required parameter "this.propertyName" was null when calling createOrUpdateDocumentPropertyOnline.');
        }
        // verify required parameter 'this.property' is not undefined
        if (this.property === undefined) {
            throw new Error('Required parameter "this.property" was undefined when calling createOrUpdateDocumentPropertyOnline.');
        }

        // verify required parameter 'this.property' is not null
        if (this.property === null) {
            throw new Error('Required parameter "this.property" was null when calling createOrUpdateDocumentPropertyOnline.');
        }
        this.property?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.property !== undefined) {
            let _obj = ObjectSerializer.serialize(this.property, this.property.constructor.name === "Object" ? "importedDocumentPropertyCreateOrUpdate.DocumentPropertyCreateOrUpdate" : this.property.constructor.name);
            formParams.push(['Property', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new CreateOrUpdateDocumentPropertyOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentPropertyResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for DeleteAllParagraphTabStops operation.
 * Removes paragraph tab stops from the document node.
 */
export class DeleteAllParagraphTabStopsRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteAllParagraphTabStopsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/tabstops"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteAllParagraphTabStops.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteAllParagraphTabStops.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteAllParagraphTabStops.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteAllParagraphTabStops.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TabStopsResponse");
	}
}

/**
 * Request model for DeleteAllParagraphTabStopsOnline operation.
 * Removes paragraph tab stops from the document node.
 */
export class DeleteAllParagraphTabStopsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteAllParagraphTabStopsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/paragraphs/{index}/tabstops"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteAllParagraphTabStopsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteAllParagraphTabStopsOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteAllParagraphTabStopsOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteAllParagraphTabStopsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new DeleteAllParagraphTabStopsOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "TabStopsResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for DeleteBookmark operation.
 * Removes a bookmark from the document.
 */
export class DeleteBookmarkRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteBookmarkRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The name of the bookmark.
     */
    public bookmarkName: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks/{bookmarkName}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteBookmark.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteBookmark.');
        }
        // verify required parameter 'this.bookmarkName' is not undefined
        if (this.bookmarkName === undefined) {
            throw new Error('Required parameter "this.bookmarkName" was undefined when calling deleteBookmark.');
        }

        // verify required parameter 'this.bookmarkName' is not null
        if (this.bookmarkName === null) {
            throw new Error('Required parameter "this.bookmarkName" was null when calling deleteBookmark.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteBookmarkOnline operation.
 * Removes a bookmark from the document.
 */
export class DeleteBookmarkOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteBookmarkOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The name of the bookmark.
     */
    public bookmarkName: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/bookmarks/{bookmarkName}"
            .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteBookmarkOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteBookmarkOnline.');
        }
        // verify required parameter 'this.bookmarkName' is not undefined
        if (this.bookmarkName === undefined) {
            throw new Error('Required parameter "this.bookmarkName" was undefined when calling deleteBookmarkOnline.');
        }

        // verify required parameter 'this.bookmarkName' is not null
        if (this.bookmarkName === null) {
            throw new Error('Required parameter "this.bookmarkName" was null when calling deleteBookmarkOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteBookmarks operation.
 * Removes all bookmarks from the document.
 */
export class DeleteBookmarksRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteBookmarksRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteBookmarks.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteBookmarks.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteBookmarksOnline operation.
 * Removes all bookmarks from the document.
 */
export class DeleteBookmarksOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteBookmarksOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/bookmarks"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteBookmarksOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteBookmarksOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteBorder operation.
 * Removes a border from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
export class DeleteBorderRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteBorderRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Border type.
     */
    public borderType: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/borders/{borderType}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteBorder.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteBorder.');
        }
        // verify required parameter 'this.borderType' is not undefined
        if (this.borderType === undefined) {
            throw new Error('Required parameter "this.borderType" was undefined when calling deleteBorder.');
        }

        // verify required parameter 'this.borderType' is not null
        if (this.borderType === null) {
            throw new Error('Required parameter "this.borderType" was null when calling deleteBorder.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BorderResponse");
	}
}

/**
 * Request model for DeleteBorderOnline operation.
 * Removes a border from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
export class DeleteBorderOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteBorderOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Border type.
     */
    public borderType: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/borders/{borderType}"
            .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteBorderOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteBorderOnline.');
        }
        // verify required parameter 'this.borderType' is not undefined
        if (this.borderType === undefined) {
            throw new Error('Required parameter "this.borderType" was undefined when calling deleteBorderOnline.');
        }

        // verify required parameter 'this.borderType' is not null
        if (this.borderType === null) {
            throw new Error('Required parameter "this.borderType" was null when calling deleteBorderOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new DeleteBorderOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "BorderResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for DeleteBorders operation.
 * Removes borders from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
export class DeleteBordersRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteBordersRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/borders"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteBorders.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteBorders.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BordersResponse");
	}
}

/**
 * Request model for DeleteBordersOnline operation.
 * Removes borders from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
export class DeleteBordersOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteBordersOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/borders"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteBordersOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteBordersOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new DeleteBordersOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "BordersResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for DeleteComment operation.
 * Removes a comment from the document.
 */
export class DeleteCommentRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteCommentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the comment.
     */
    public commentIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments/{commentIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteComment.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteComment.');
        }
        // verify required parameter 'this.commentIndex' is not undefined
        if (this.commentIndex === undefined) {
            throw new Error('Required parameter "this.commentIndex" was undefined when calling deleteComment.');
        }

        // verify required parameter 'this.commentIndex' is not null
        if (this.commentIndex === null) {
            throw new Error('Required parameter "this.commentIndex" was null when calling deleteComment.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteCommentOnline operation.
 * Removes a comment from the document.
 */
export class DeleteCommentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteCommentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the comment.
     */
    public commentIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/comments/{commentIndex}"
            .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteCommentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteCommentOnline.');
        }
        // verify required parameter 'this.commentIndex' is not undefined
        if (this.commentIndex === undefined) {
            throw new Error('Required parameter "this.commentIndex" was undefined when calling deleteCommentOnline.');
        }

        // verify required parameter 'this.commentIndex' is not null
        if (this.commentIndex === null) {
            throw new Error('Required parameter "this.commentIndex" was null when calling deleteCommentOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteComments operation.
 * Removes all comments from the document.
 */
export class DeleteCommentsRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteCommentsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteComments.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteComments.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteCommentsOnline operation.
 * Removes all comments from the document.
 */
export class DeleteCommentsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteCommentsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/comments"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteCommentsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteCommentsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteCustomXmlPart operation.
 * Removes the custom xml part from the document.
 */
export class DeleteCustomXmlPartRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteCustomXmlPartRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the custom xml part. This index is the number of the entry in the collection of custom xml parts, not the ID of the part.
     */
    public customXmlPartIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts/{customXmlPartIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteCustomXmlPart.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteCustomXmlPart.');
        }
        // verify required parameter 'this.customXmlPartIndex' is not undefined
        if (this.customXmlPartIndex === undefined) {
            throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling deleteCustomXmlPart.');
        }

        // verify required parameter 'this.customXmlPartIndex' is not null
        if (this.customXmlPartIndex === null) {
            throw new Error('Required parameter "this.customXmlPartIndex" was null when calling deleteCustomXmlPart.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteCustomXmlPartOnline operation.
 * Removes the custom xml part from the document.
 */
export class DeleteCustomXmlPartOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteCustomXmlPartOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the custom xml part. This index is the number of the entry in the collection of custom xml parts, not the ID of the part.
     */
    public customXmlPartIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/customXmlParts/{customXmlPartIndex}"
            .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteCustomXmlPartOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteCustomXmlPartOnline.');
        }
        // verify required parameter 'this.customXmlPartIndex' is not undefined
        if (this.customXmlPartIndex === undefined) {
            throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling deleteCustomXmlPartOnline.');
        }

        // verify required parameter 'this.customXmlPartIndex' is not null
        if (this.customXmlPartIndex === null) {
            throw new Error('Required parameter "this.customXmlPartIndex" was null when calling deleteCustomXmlPartOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteCustomXmlParts operation.
 * Removes all custom xml parts from the document.
 */
export class DeleteCustomXmlPartsRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteCustomXmlPartsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteCustomXmlParts.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteCustomXmlParts.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteCustomXmlPartsOnline operation.
 * Removes all custom xml parts from the document.
 */
export class DeleteCustomXmlPartsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteCustomXmlPartsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/customXmlParts"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteCustomXmlPartsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteCustomXmlPartsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteDocumentProperty operation.
 * Removes a document property.
 */
export class DeleteDocumentPropertyRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteDocumentPropertyRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The name of the property.
     */
    public propertyName: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/documentProperties/{propertyName}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteDocumentProperty.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteDocumentProperty.');
        }
        // verify required parameter 'this.propertyName' is not undefined
        if (this.propertyName === undefined) {
            throw new Error('Required parameter "this.propertyName" was undefined when calling deleteDocumentProperty.');
        }

        // verify required parameter 'this.propertyName' is not null
        if (this.propertyName === null) {
            throw new Error('Required parameter "this.propertyName" was null when calling deleteDocumentProperty.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteDocumentPropertyOnline operation.
 * Removes a document property.
 */
export class DeleteDocumentPropertyOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteDocumentPropertyOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The name of the property.
     */
    public propertyName: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/documentProperties/{propertyName}"
            .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteDocumentPropertyOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteDocumentPropertyOnline.');
        }
        // verify required parameter 'this.propertyName' is not undefined
        if (this.propertyName === undefined) {
            throw new Error('Required parameter "this.propertyName" was undefined when calling deleteDocumentPropertyOnline.');
        }

        // verify required parameter 'this.propertyName' is not null
        if (this.propertyName === null) {
            throw new Error('Required parameter "this.propertyName" was null when calling deleteDocumentPropertyOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteDrawingObject operation.
 * Removes a DrawingObject from the document node.
 */
export class DeleteDrawingObjectRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteDrawingObjectRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteDrawingObject.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteDrawingObject.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteDrawingObject.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteDrawingObject.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteDrawingObjectOnline operation.
 * Removes a DrawingObject from the document node.
 */
export class DeleteDrawingObjectOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteDrawingObjectOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/drawingObjects/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteDrawingObjectOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteDrawingObjectOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteDrawingObjectOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteDrawingObjectOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteField operation.
 * Removes a field from the document node.
 */
export class DeleteFieldRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteFieldRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteField.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteField.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteField.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteField.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteFieldOnline operation.
 * Removes a field from the document node.
 */
export class DeleteFieldOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteFieldOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/fields/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteFieldOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteFieldOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteFieldOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteFieldOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteFields operation.
 * Removes fields from the document node.
 */
export class DeleteFieldsRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteFieldsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteFields.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteFields.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteFieldsOnline operation.
 * Removes fields from the document node.
 */
export class DeleteFieldsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteFieldsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/fields"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteFieldsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteFieldsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteFile operation.
 * Delete file.
 */
export class DeleteFileRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteFileRequest >) {
        Object.assign(this, init);
    }

    /**
     * Path of the file including the file name and extension e.g. /folder1/file.ext.
     */
    public path: string;

    /**
     * Storage name.
     */
    public storageName: string;

    /**
     * File version ID to delete.
     */
    public versionId: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/storage/file/{path}"
            .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.path' is not undefined
        if (this.path === undefined) {
            throw new Error('Required parameter "this.path" was undefined when calling deleteFile.');
        }

        // verify required parameter 'this.path' is not null
        if (this.path === null) {
            throw new Error('Required parameter "this.path" was null when calling deleteFile.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteFolder operation.
 * Delete folder.
 */
export class DeleteFolderRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteFolderRequest >) {
        Object.assign(this, init);
    }

    /**
     * Folder path e.g. '/folder'.
     */
    public path: string;

    /**
     * Storage name.
     */
    public storageName: string;

    /**
     * Enable to delete folders, subfolders and files.
     */
    public recursive: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/storage/folder/{path}"
            .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.path' is not undefined
        if (this.path === undefined) {
            throw new Error('Required parameter "this.path" was undefined when calling deleteFolder.');
        }

        // verify required parameter 'this.path' is not null
        if (this.path === null) {
            throw new Error('Required parameter "this.path" was null when calling deleteFolder.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "recursive", this.recursive, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteFootnote operation.
 * Removes a footnote from the document node.
 */
export class DeleteFootnoteRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteFootnoteRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/footnotes/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteFootnote.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteFootnote.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteFootnote.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteFootnote.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteFootnoteOnline operation.
 * Removes a footnote from the document node.
 */
export class DeleteFootnoteOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteFootnoteOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/footnotes/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteFootnoteOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteFootnoteOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteFootnoteOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteFootnoteOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteFormField operation.
 * Removes a form field from the document node.
 */
export class DeleteFormFieldRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteFormFieldRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/formfields/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteFormField.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteFormField.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteFormField.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteFormField.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteFormFieldOnline operation.
 * Removes a form field from the document node.
 */
export class DeleteFormFieldOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteFormFieldOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/formfields/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteFormFieldOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteFormFieldOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteFormFieldOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteFormFieldOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteHeaderFooter operation.
 * Removes a HeaderFooter object from the document section.
 */
export class DeleteHeaderFooterRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteHeaderFooterRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the section in the document tree.
     */
    public sectionPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{sectionPath}/headersfooters/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteHeaderFooter.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteHeaderFooter.');
        }
        // verify required parameter 'this.sectionPath' is not undefined
        if (this.sectionPath === undefined) {
            throw new Error('Required parameter "this.sectionPath" was undefined when calling deleteHeaderFooter.');
        }

        // verify required parameter 'this.sectionPath' is not null
        if (this.sectionPath === null) {
            throw new Error('Required parameter "this.sectionPath" was null when calling deleteHeaderFooter.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteHeaderFooter.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteHeaderFooter.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteHeaderFooterOnline operation.
 * Removes a HeaderFooter object from the document section.
 */
export class DeleteHeaderFooterOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteHeaderFooterOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the section in the document tree.
     */
    public sectionPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{sectionPath}/headersfooters/{index}"
            .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteHeaderFooterOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteHeaderFooterOnline.');
        }
        // verify required parameter 'this.sectionPath' is not undefined
        if (this.sectionPath === undefined) {
            throw new Error('Required parameter "this.sectionPath" was undefined when calling deleteHeaderFooterOnline.');
        }

        // verify required parameter 'this.sectionPath' is not null
        if (this.sectionPath === null) {
            throw new Error('Required parameter "this.sectionPath" was null when calling deleteHeaderFooterOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteHeaderFooterOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteHeaderFooterOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteHeadersFooters operation.
 * Removes HeaderFooter objects from the document section.
 */
export class DeleteHeadersFootersRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteHeadersFootersRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the section in the document tree.
     */
    public sectionPath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

    /**
     * The list of HeaderFooter types.
     */
    public headersFootersTypes: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{sectionPath}/headersfooters"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteHeadersFooters.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteHeadersFooters.');
        }
        // verify required parameter 'this.sectionPath' is not undefined
        if (this.sectionPath === undefined) {
            throw new Error('Required parameter "this.sectionPath" was undefined when calling deleteHeadersFooters.');
        }

        // verify required parameter 'this.sectionPath' is not null
        if (this.sectionPath === null) {
            throw new Error('Required parameter "this.sectionPath" was null when calling deleteHeadersFooters.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "headersFootersTypes", this.headersFootersTypes, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteHeadersFootersOnline operation.
 * Removes HeaderFooter objects from the document section.
 */
export class DeleteHeadersFootersOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteHeadersFootersOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the section in the document tree.
     */
    public sectionPath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

    /**
     * The list of HeaderFooter types.
     */
    public headersFootersTypes: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{sectionPath}/headersfooters"
            .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteHeadersFootersOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteHeadersFootersOnline.');
        }
        // verify required parameter 'this.sectionPath' is not undefined
        if (this.sectionPath === undefined) {
            throw new Error('Required parameter "this.sectionPath" was undefined when calling deleteHeadersFootersOnline.');
        }

        // verify required parameter 'this.sectionPath' is not null
        if (this.sectionPath === null) {
            throw new Error('Required parameter "this.sectionPath" was null when calling deleteHeadersFootersOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "headersFootersTypes", this.headersFootersTypes, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteMacros operation.
 * Removes macros from the document.
 */
export class DeleteMacrosRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteMacrosRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/macros"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteMacros.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteMacros.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteMacrosOnline operation.
 * Removes macros from the document.
 */
export class DeleteMacrosOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteMacrosOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/macros"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteMacrosOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteMacrosOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteOfficeMathObject operation.
 * Removes an OfficeMath object from the document node.
 */
export class DeleteOfficeMathObjectRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteOfficeMathObjectRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/OfficeMathObjects/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteOfficeMathObject.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteOfficeMathObject.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteOfficeMathObject.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteOfficeMathObject.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteOfficeMathObjectOnline operation.
 * Removes an OfficeMath object from the document node.
 */
export class DeleteOfficeMathObjectOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteOfficeMathObjectOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/OfficeMathObjects/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteOfficeMathObjectOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteOfficeMathObjectOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteOfficeMathObjectOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteOfficeMathObjectOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteOfficeMathObjects operation.
 * Removes all office math objects from the document.
 */
export class DeleteOfficeMathObjectsRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteOfficeMathObjectsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/OfficeMathObjects"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteOfficeMathObjects.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteOfficeMathObjects.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteOfficeMathObjectsOnline operation.
 * Removes all office math objects from the document.
 */
export class DeleteOfficeMathObjectsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteOfficeMathObjectsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/OfficeMathObjects"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteOfficeMathObjectsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteOfficeMathObjectsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteParagraph operation.
 * Removes a paragraph from the document node.
 */
export class DeleteParagraphRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteParagraphRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteParagraph.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteParagraph.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteParagraph.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteParagraph.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteParagraphListFormat operation.
 * Removes the formatting properties of a paragraph list from the document node.
 */
export class DeleteParagraphListFormatRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteParagraphListFormatRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/listFormat"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteParagraphListFormat.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteParagraphListFormat.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteParagraphListFormat.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteParagraphListFormat.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphListFormatResponse");
	}
}

/**
 * Request model for DeleteParagraphListFormatOnline operation.
 * Removes the formatting properties of a paragraph list from the document node.
 */
export class DeleteParagraphListFormatOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteParagraphListFormatOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/paragraphs/{index}/listFormat"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteParagraphListFormatOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteParagraphListFormatOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteParagraphListFormatOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteParagraphListFormatOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new DeleteParagraphListFormatOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "ParagraphListFormatResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for DeleteParagraphOnline operation.
 * Removes a paragraph from the document node.
 */
export class DeleteParagraphOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteParagraphOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/paragraphs/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteParagraphOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteParagraphOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteParagraphOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteParagraphOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteParagraphTabStop operation.
 * Removes a paragraph tab stop from the document node.
 */
export class DeleteParagraphTabStopRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteParagraphTabStopRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The position of a tab stop to remove.
     */
    public position: number;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/tabstop"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteParagraphTabStop.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteParagraphTabStop.');
        }
        // verify required parameter 'this.position' is not undefined
        if (this.position === undefined) {
            throw new Error('Required parameter "this.position" was undefined when calling deleteParagraphTabStop.');
        }

        // verify required parameter 'this.position' is not null
        if (this.position === null) {
            throw new Error('Required parameter "this.position" was null when calling deleteParagraphTabStop.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteParagraphTabStop.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteParagraphTabStop.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "position", this.position, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TabStopsResponse");
	}
}

/**
 * Request model for DeleteParagraphTabStopOnline operation.
 * Removes a paragraph tab stop from the document node.
 */
export class DeleteParagraphTabStopOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteParagraphTabStopOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The position of a tab stop to remove.
     */
    public position: number;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/paragraphs/{index}/tabstop"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteParagraphTabStopOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteParagraphTabStopOnline.');
        }
        // verify required parameter 'this.position' is not undefined
        if (this.position === undefined) {
            throw new Error('Required parameter "this.position" was undefined when calling deleteParagraphTabStopOnline.');
        }

        // verify required parameter 'this.position' is not null
        if (this.position === null) {
            throw new Error('Required parameter "this.position" was null when calling deleteParagraphTabStopOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteParagraphTabStopOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteParagraphTabStopOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "position", this.position, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new DeleteParagraphTabStopOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "TabStopsResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for DeleteRun operation.
 * Removes a Run object from the paragraph.
 */
export class DeleteRunRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteRunRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteRun.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteRun.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling deleteRun.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling deleteRun.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteRun.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteRun.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteRunOnline operation.
 * Removes a Run object from the paragraph.
 */
export class DeleteRunOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteRunOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{paragraphPath}/runs/{index}"
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteRunOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteRunOnline.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling deleteRunOnline.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling deleteRunOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteRunOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteRunOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteSection operation.
 * Removes a section from the document.
 */
export class DeleteSectionRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteSectionRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteSection.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteSection.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling deleteSection.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling deleteSection.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteSectionOnline operation.
 * Removes a section from the document.
 */
export class DeleteSectionOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteSectionOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/sections/{sectionIndex}"
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteSectionOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteSectionOnline.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling deleteSectionOnline.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling deleteSectionOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteStructuredDocumentTag operation.
 * Removes a StructuredDocumentTag (SDT) from the document node.
 */
export class DeleteStructuredDocumentTagRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteStructuredDocumentTagRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/sdt/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteStructuredDocumentTag.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteStructuredDocumentTag.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteStructuredDocumentTag.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteStructuredDocumentTag.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteStructuredDocumentTagOnline operation.
 * Removes a StructuredDocumentTag (SDT) from the document node.
 */
export class DeleteStructuredDocumentTagOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteStructuredDocumentTagOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/sdt/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteStructuredDocumentTagOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteStructuredDocumentTagOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteStructuredDocumentTagOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteStructuredDocumentTagOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteTable operation.
 * Removes a table from the document node.
 */
export class DeleteTableRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteTableRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteTable.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteTable.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteTable.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteTable.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteTableCell operation.
 * Removes a cell from the table row.
 */
export class DeleteTableCellRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteTableCellRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the table row in the document tree.
     */
    public tableRowPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tableRowPath}/cells/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteTableCell.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteTableCell.');
        }
        // verify required parameter 'this.tableRowPath' is not undefined
        if (this.tableRowPath === undefined) {
            throw new Error('Required parameter "this.tableRowPath" was undefined when calling deleteTableCell.');
        }

        // verify required parameter 'this.tableRowPath' is not null
        if (this.tableRowPath === null) {
            throw new Error('Required parameter "this.tableRowPath" was null when calling deleteTableCell.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteTableCell.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteTableCell.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteTableCellOnline operation.
 * Removes a cell from the table row.
 */
export class DeleteTableCellOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteTableCellOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the table row in the document tree.
     */
    public tableRowPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{tableRowPath}/cells/{index}"
            .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteTableCellOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteTableCellOnline.');
        }
        // verify required parameter 'this.tableRowPath' is not undefined
        if (this.tableRowPath === undefined) {
            throw new Error('Required parameter "this.tableRowPath" was undefined when calling deleteTableCellOnline.');
        }

        // verify required parameter 'this.tableRowPath' is not null
        if (this.tableRowPath === null) {
            throw new Error('Required parameter "this.tableRowPath" was null when calling deleteTableCellOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteTableCellOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteTableCellOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteTableOnline operation.
 * Removes a table from the document node.
 */
export class DeleteTableOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteTableOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{nodePath}/tables/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteTableOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteTableOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteTableOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteTableOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteTableRow operation.
 * Removes a row from the table.
 */
export class DeleteTableRowRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteTableRowRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the table in the document tree.
     */
    public tablePath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tablePath}/rows/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteTableRow.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteTableRow.');
        }
        // verify required parameter 'this.tablePath' is not undefined
        if (this.tablePath === undefined) {
            throw new Error('Required parameter "this.tablePath" was undefined when calling deleteTableRow.');
        }

        // verify required parameter 'this.tablePath' is not null
        if (this.tablePath === null) {
            throw new Error('Required parameter "this.tablePath" was null when calling deleteTableRow.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteTableRow.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteTableRow.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for DeleteTableRowOnline operation.
 * Removes a row from the table.
 */
export class DeleteTableRowOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteTableRowOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the table in the document tree.
     */
    public tablePath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/{tablePath}/rows/{index}"
            .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteTableRowOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteTableRowOnline.');
        }
        // verify required parameter 'this.tablePath' is not undefined
        if (this.tablePath === undefined) {
            throw new Error('Required parameter "this.tablePath" was undefined when calling deleteTableRowOnline.');
        }

        // verify required parameter 'this.tablePath' is not null
        if (this.tablePath === null) {
            throw new Error('Required parameter "this.tablePath" was null when calling deleteTableRowOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling deleteTableRowOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling deleteTableRowOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for DeleteWatermark operation.
 * Removes a watermark from the document.
 */
export class DeleteWatermarkRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteWatermarkRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/watermarks/deleteLast"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling deleteWatermark.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling deleteWatermark.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for DeleteWatermarkOnline operation.
 * Removes a watermark from the document.
 */
export class DeleteWatermarkOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< DeleteWatermarkOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/watermarks/deleteLast"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling deleteWatermarkOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling deleteWatermarkOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new DeleteWatermarkOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for DownloadFile operation.
 * Download file.
 */
export class DownloadFileRequest implements RequestInterface {

    public constructor(init?: Partial< DownloadFileRequest >) {
        Object.assign(this, init);
    }

    /**
     * Path of the file including the file name and extension e.g. /folder1/file.ext.
     */
    public path: string;

    /**
     * Storage name.
     */
    public storageName: string;

    /**
     * File version ID to download.
     */
    public versionId: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/storage/file/{path}"
            .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.path' is not undefined
        if (this.path === undefined) {
            throw new Error('Required parameter "this.path" was undefined when calling downloadFile.');
        }

        // verify required parameter 'this.path' is not null
        if (this.path === null) {
            throw new Error('Required parameter "this.path" was null when calling downloadFile.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for ExecuteMailMerge operation.
 * Executes a Mail Merge operation.
 */
export class ExecuteMailMergeRequest implements RequestInterface {

    public constructor(init?: Partial< ExecuteMailMergeRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Mail merge data.
     */
    public data: string;

    /**
     * Field options.
     */
    public options: importedFieldOptions.FieldOptions;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The flag indicating whether to execute Mail Merge operation with regions.
     */
    public withRegions: boolean;

    /**
     * The data file.
     */
    public mailMergeDataFile: string;

    /**
     * The cleanup options.
     */
    public cleanup: string;

    /**
     * The flag indicating whether paragraph with TableStart or TableEnd field should be fully included into mail merge region or particular range between TableStart and TableEnd fields. The default value is true.
     */
    public useWholeParagraphAsRegion: boolean;

    /**
     * The flag indicating whether fields in whole document are updated while executing of a mail merge with regions.
     */
    public mergeWholeDocument: boolean;

    /**
     * The filename of the output document. If this parameter is omitted, the result will be saved with autogenerated name.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/MailMerge"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling executeMailMerge.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling executeMailMerge.');
        }
        this.options?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "withRegions", this.withRegions, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "mailMergeDataFile", this.mailMergeDataFile, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "cleanup", this.cleanup, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "useWholeParagraphAsRegion", this.useWholeParagraphAsRegion, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "mergeWholeDocument", this.mergeWholeDocument, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.data !== undefined) {
            formParams.push(['Data', this.data, 'text/plain']);
        }
        if (this.options !== undefined) {
            let _obj = ObjectSerializer.serialize(this.options, this.options.constructor.name === "Object" ? "importedFieldOptions.FieldOptions" : this.options.constructor.name);
            formParams.push(['Options', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for ExecuteMailMergeOnline operation.
 * Executes a Mail Merge operation online.
 */
export class ExecuteMailMergeOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< ExecuteMailMergeOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * File with template.
     */
    public template: Readable;

    /**
     * File with mailmerge data.
     */
    public data: Readable;

    /**
     * Field options.
     */
    public options: importedFieldOptions.FieldOptions;

    /**
     * The flag indicating whether to execute Mail Merge operation with regions.
     */
    public withRegions: boolean;

    /**
     * The flag indicating whether fields in whole document are updated while executing of a mail merge with regions.
     */
    public mergeWholeDocument: boolean;

    /**
     * The cleanup options.
     */
    public cleanup: string;

    /**
     * The filename of the output document, that will be used when the resulting document has a dynamic field {filename}. If it is not set, the "template" will be used instead.
     */
    public documentFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/MailMerge"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.template' is not undefined
        if (this.template === undefined) {
            throw new Error('Required parameter "this.template" was undefined when calling executeMailMergeOnline.');
        }

        // verify required parameter 'this.template' is not null
        if (this.template === null) {
            throw new Error('Required parameter "this.template" was null when calling executeMailMergeOnline.');
        }
        // verify required parameter 'this.data' is not undefined
        if (this.data === undefined) {
            throw new Error('Required parameter "this.data" was undefined when calling executeMailMergeOnline.');
        }

        // verify required parameter 'this.data' is not null
        if (this.data === null) {
            throw new Error('Required parameter "this.data" was null when calling executeMailMergeOnline.');
        }
        this.options?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "withRegions", this.withRegions, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "mergeWholeDocument", this.mergeWholeDocument, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "cleanup", this.cleanup, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "documentFileName", this.documentFileName, _encryptor);
        if (this.template !== undefined) {
            formParams.push(['Template', this.template, 'application/octet-stream']);
        }
        if (this.data !== undefined) {
            formParams.push(['Data', this.data, 'application/octet-stream']);
        }
        if (this.options !== undefined) {
            let _obj = ObjectSerializer.serialize(this.options, this.options.constructor.name === "Object" ? "importedFieldOptions.FieldOptions" : this.options.constructor.name);
            formParams.push(['Options', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for GetAllRevisions operation.
 * Get all information about revisions.
 */
export class GetAllRevisionsRequest implements RequestInterface {

    public constructor(init?: Partial< GetAllRevisionsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/revisions/getAll"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getAllRevisions.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getAllRevisions.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RevisionsResponse");
	}
}

/**
 * Request model for GetAllRevisionsOnline operation.
 * Get all information about revisions.
 */
export class GetAllRevisionsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetAllRevisionsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/revisions/getAll"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getAllRevisionsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getAllRevisionsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RevisionsResponse");
	}
}

/**
 * Request model for GetAvailableFonts operation.
 * Reads available fonts from the document.
 */
export class GetAvailableFontsRequest implements RequestInterface {

    public constructor(init?: Partial< GetAvailableFontsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The folder in cloud storage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/fonts/available"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "AvailableFontsResponse");
	}
}

/**
 * Request model for GetBookmarkByName operation.
 * Reads a bookmark, specified by name, from the document.
 */
export class GetBookmarkByNameRequest implements RequestInterface {

    public constructor(init?: Partial< GetBookmarkByNameRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The name of the bookmark.
     */
    public bookmarkName: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks/{bookmarkName}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getBookmarkByName.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getBookmarkByName.');
        }
        // verify required parameter 'this.bookmarkName' is not undefined
        if (this.bookmarkName === undefined) {
            throw new Error('Required parameter "this.bookmarkName" was undefined when calling getBookmarkByName.');
        }

        // verify required parameter 'this.bookmarkName' is not null
        if (this.bookmarkName === null) {
            throw new Error('Required parameter "this.bookmarkName" was null when calling getBookmarkByName.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarkResponse");
	}
}

/**
 * Request model for GetBookmarkByNameOnline operation.
 * Reads a bookmark, specified by name, from the document.
 */
export class GetBookmarkByNameOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetBookmarkByNameOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The name of the bookmark.
     */
    public bookmarkName: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/bookmarks/{bookmarkName}"
            .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getBookmarkByNameOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getBookmarkByNameOnline.');
        }
        // verify required parameter 'this.bookmarkName' is not undefined
        if (this.bookmarkName === undefined) {
            throw new Error('Required parameter "this.bookmarkName" was undefined when calling getBookmarkByNameOnline.');
        }

        // verify required parameter 'this.bookmarkName' is not null
        if (this.bookmarkName === null) {
            throw new Error('Required parameter "this.bookmarkName" was null when calling getBookmarkByNameOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarkResponse");
	}
}

/**
 * Request model for GetBookmarks operation.
 * Reads bookmarks from the document.
 */
export class GetBookmarksRequest implements RequestInterface {

    public constructor(init?: Partial< GetBookmarksRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getBookmarks.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getBookmarks.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarksResponse");
	}
}

/**
 * Request model for GetBookmarksOnline operation.
 * Reads bookmarks from the document.
 */
export class GetBookmarksOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetBookmarksOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/bookmarks"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getBookmarksOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getBookmarksOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarksResponse");
	}
}

/**
 * Request model for GetBorder operation.
 * Reads a border from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
export class GetBorderRequest implements RequestInterface {

    public constructor(init?: Partial< GetBorderRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Border type.
     */
    public borderType: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/borders/{borderType}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getBorder.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getBorder.');
        }
        // verify required parameter 'this.borderType' is not undefined
        if (this.borderType === undefined) {
            throw new Error('Required parameter "this.borderType" was undefined when calling getBorder.');
        }

        // verify required parameter 'this.borderType' is not null
        if (this.borderType === null) {
            throw new Error('Required parameter "this.borderType" was null when calling getBorder.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BorderResponse");
	}
}

/**
 * Request model for GetBorderOnline operation.
 * Reads a border from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
export class GetBorderOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetBorderOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Border type.
     */
    public borderType: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/borders/{borderType}"
            .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getBorderOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getBorderOnline.');
        }
        // verify required parameter 'this.borderType' is not undefined
        if (this.borderType === undefined) {
            throw new Error('Required parameter "this.borderType" was undefined when calling getBorderOnline.');
        }

        // verify required parameter 'this.borderType' is not null
        if (this.borderType === null) {
            throw new Error('Required parameter "this.borderType" was null when calling getBorderOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BorderResponse");
	}
}

/**
 * Request model for GetBorders operation.
 * Reads borders from the document node.
 */
export class GetBordersRequest implements RequestInterface {

    public constructor(init?: Partial< GetBordersRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/borders"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getBorders.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getBorders.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BordersResponse");
	}
}

/**
 * Request model for GetBordersOnline operation.
 * Reads borders from the document node.
 */
export class GetBordersOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetBordersOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/borders"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getBordersOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getBordersOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BordersResponse");
	}
}

/**
 * Request model for GetComment operation.
 * Reads a comment from the document.
 */
export class GetCommentRequest implements RequestInterface {

    public constructor(init?: Partial< GetCommentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the comment.
     */
    public commentIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments/{commentIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getComment.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getComment.');
        }
        // verify required parameter 'this.commentIndex' is not undefined
        if (this.commentIndex === undefined) {
            throw new Error('Required parameter "this.commentIndex" was undefined when calling getComment.');
        }

        // verify required parameter 'this.commentIndex' is not null
        if (this.commentIndex === null) {
            throw new Error('Required parameter "this.commentIndex" was null when calling getComment.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentResponse");
	}
}

/**
 * Request model for GetCommentOnline operation.
 * Reads a comment from the document.
 */
export class GetCommentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetCommentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the comment.
     */
    public commentIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/comments/{commentIndex}"
            .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getCommentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getCommentOnline.');
        }
        // verify required parameter 'this.commentIndex' is not undefined
        if (this.commentIndex === undefined) {
            throw new Error('Required parameter "this.commentIndex" was undefined when calling getCommentOnline.');
        }

        // verify required parameter 'this.commentIndex' is not null
        if (this.commentIndex === null) {
            throw new Error('Required parameter "this.commentIndex" was null when calling getCommentOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentResponse");
	}
}

/**
 * Request model for GetComments operation.
 * Reads comments from the document.
 */
export class GetCommentsRequest implements RequestInterface {

    public constructor(init?: Partial< GetCommentsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getComments.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getComments.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentsResponse");
	}
}

/**
 * Request model for GetCommentsOnline operation.
 * Reads comments from the document.
 */
export class GetCommentsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetCommentsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/comments"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getCommentsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getCommentsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentsResponse");
	}
}

/**
 * Request model for GetCustomXmlPart operation.
 * Reads the custom xml part from the document.
 */
export class GetCustomXmlPartRequest implements RequestInterface {

    public constructor(init?: Partial< GetCustomXmlPartRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the custom xml part. This index is the number of the entry in the collection of custom xml parts, not the ID of the part.
     */
    public customXmlPartIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts/{customXmlPartIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getCustomXmlPart.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getCustomXmlPart.');
        }
        // verify required parameter 'this.customXmlPartIndex' is not undefined
        if (this.customXmlPartIndex === undefined) {
            throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling getCustomXmlPart.');
        }

        // verify required parameter 'this.customXmlPartIndex' is not null
        if (this.customXmlPartIndex === null) {
            throw new Error('Required parameter "this.customXmlPartIndex" was null when calling getCustomXmlPart.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartResponse");
	}
}

/**
 * Request model for GetCustomXmlPartOnline operation.
 * Reads the custom xml part from the document.
 */
export class GetCustomXmlPartOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetCustomXmlPartOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the custom xml part. This index is the number of the entry in the collection of custom xml parts, not the ID of the part.
     */
    public customXmlPartIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/customXmlParts/{customXmlPartIndex}"
            .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getCustomXmlPartOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getCustomXmlPartOnline.');
        }
        // verify required parameter 'this.customXmlPartIndex' is not undefined
        if (this.customXmlPartIndex === undefined) {
            throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling getCustomXmlPartOnline.');
        }

        // verify required parameter 'this.customXmlPartIndex' is not null
        if (this.customXmlPartIndex === null) {
            throw new Error('Required parameter "this.customXmlPartIndex" was null when calling getCustomXmlPartOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartResponse");
	}
}

/**
 * Request model for GetCustomXmlParts operation.
 * Reads custom xml parts from the document.
 */
export class GetCustomXmlPartsRequest implements RequestInterface {

    public constructor(init?: Partial< GetCustomXmlPartsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getCustomXmlParts.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getCustomXmlParts.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartsResponse");
	}
}

/**
 * Request model for GetCustomXmlPartsOnline operation.
 * Reads custom xml parts from the document.
 */
export class GetCustomXmlPartsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetCustomXmlPartsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/customXmlParts"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getCustomXmlPartsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getCustomXmlPartsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartsResponse");
	}
}

/**
 * Request model for GetDocument operation.
 * Reads common information from the document.
 */
export class GetDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public documentName: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{documentName}"
            .replace("/{" + "documentName" + "}", (this.documentName !== null && this.documentName !== undefined) ? "/" + String(this.documentName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.documentName' is not undefined
        if (this.documentName === undefined) {
            throw new Error('Required parameter "this.documentName" was undefined when calling getDocument.');
        }

        // verify required parameter 'this.documentName' is not null
        if (this.documentName === null) {
            throw new Error('Required parameter "this.documentName" was null when calling getDocument.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for GetDocumentDrawingObjectByIndex operation.
 * Reads a DrawingObject from the document node.
 */
export class GetDocumentDrawingObjectByIndexRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentDrawingObjectByIndexRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentDrawingObjectByIndex.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentDrawingObjectByIndex.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectByIndex.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectByIndex.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectResponse");
	}
}

/**
 * Request model for GetDocumentDrawingObjectByIndexOnline operation.
 * Reads a DrawingObject from the document node.
 */
export class GetDocumentDrawingObjectByIndexOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentDrawingObjectByIndexOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/drawingObjects/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getDocumentDrawingObjectByIndexOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getDocumentDrawingObjectByIndexOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectByIndexOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectByIndexOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectResponse");
	}
}

/**
 * Request model for GetDocumentDrawingObjectImageData operation.
 * Reads image data of a DrawingObject from the document node.
 */
export class GetDocumentDrawingObjectImageDataRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentDrawingObjectImageDataRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}/imageData"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentDrawingObjectImageData.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentDrawingObjectImageData.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectImageData.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectImageData.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for GetDocumentDrawingObjectImageDataOnline operation.
 * Reads image data of a DrawingObject from the document node.
 */
export class GetDocumentDrawingObjectImageDataOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentDrawingObjectImageDataOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/drawingObjects/{index}/imageData"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getDocumentDrawingObjectImageDataOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getDocumentDrawingObjectImageDataOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectImageDataOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectImageDataOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for GetDocumentDrawingObjectOleData operation.
 * Reads OLE data of a DrawingObject from the document node.
 */
export class GetDocumentDrawingObjectOleDataRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentDrawingObjectOleDataRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}/oleData"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentDrawingObjectOleData.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentDrawingObjectOleData.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectOleData.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectOleData.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for GetDocumentDrawingObjectOleDataOnline operation.
 * Reads OLE data of a DrawingObject from the document node.
 */
export class GetDocumentDrawingObjectOleDataOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentDrawingObjectOleDataOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/drawingObjects/{index}/oleData"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getDocumentDrawingObjectOleDataOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getDocumentDrawingObjectOleDataOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getDocumentDrawingObjectOleDataOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getDocumentDrawingObjectOleDataOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for GetDocumentDrawingObjects operation.
 * Reads DrawingObjects from the document node.
 */
export class GetDocumentDrawingObjectsRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentDrawingObjectsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentDrawingObjects.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentDrawingObjects.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectsResponse");
	}
}

/**
 * Request model for GetDocumentDrawingObjectsOnline operation.
 * Reads DrawingObjects from the document node.
 */
export class GetDocumentDrawingObjectsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentDrawingObjectsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/drawingObjects"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getDocumentDrawingObjectsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getDocumentDrawingObjectsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectsResponse");
	}
}

/**
 * Request model for GetDocumentFieldNames operation.
 * Reads merge field names from the document.
 */
export class GetDocumentFieldNamesRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentFieldNamesRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The flag indicating whether to use non merge fields. If true, result includes "mustache" field names.
     */
    public useNonMergeFields: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/mailMerge/FieldNames"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentFieldNames.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentFieldNames.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "useNonMergeFields", this.useNonMergeFields, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldNamesResponse");
	}
}

/**
 * Request model for GetDocumentFieldNamesOnline operation.
 * Reads merge field names from the document.
 */
export class GetDocumentFieldNamesOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentFieldNamesOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The template document.
     */
    public template: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The flag indicating whether to use non merge fields. If true, result includes "mustache" field names.
     */
    public useNonMergeFields: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/mailMerge/FieldNames"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.template' is not undefined
        if (this.template === undefined) {
            throw new Error('Required parameter "this.template" was undefined when calling getDocumentFieldNamesOnline.');
        }

        // verify required parameter 'this.template' is not null
        if (this.template === null) {
            throw new Error('Required parameter "this.template" was null when calling getDocumentFieldNamesOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "useNonMergeFields", this.useNonMergeFields, _encryptor);
        if (this.template !== undefined) {
            formParams.push(['Template', this.template, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldNamesResponse");
	}
}

/**
 * Request model for GetDocumentHyperlinkByIndex operation.
 * Reads a hyperlink from the document.
 */
export class GetDocumentHyperlinkByIndexRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentHyperlinkByIndexRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the hyperlink.
     */
    public hyperlinkIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/hyperlinks/{hyperlinkIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "hyperlinkIndex" + "}", (this.hyperlinkIndex !== null && this.hyperlinkIndex !== undefined) ? "/" + String(this.hyperlinkIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentHyperlinkByIndex.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentHyperlinkByIndex.');
        }
        // verify required parameter 'this.hyperlinkIndex' is not undefined
        if (this.hyperlinkIndex === undefined) {
            throw new Error('Required parameter "this.hyperlinkIndex" was undefined when calling getDocumentHyperlinkByIndex.');
        }

        // verify required parameter 'this.hyperlinkIndex' is not null
        if (this.hyperlinkIndex === null) {
            throw new Error('Required parameter "this.hyperlinkIndex" was null when calling getDocumentHyperlinkByIndex.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HyperlinkResponse");
	}
}

/**
 * Request model for GetDocumentHyperlinkByIndexOnline operation.
 * Reads a hyperlink from the document.
 */
export class GetDocumentHyperlinkByIndexOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentHyperlinkByIndexOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the hyperlink.
     */
    public hyperlinkIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/hyperlinks/{hyperlinkIndex}"
            .replace("/{" + "hyperlinkIndex" + "}", (this.hyperlinkIndex !== null && this.hyperlinkIndex !== undefined) ? "/" + String(this.hyperlinkIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getDocumentHyperlinkByIndexOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getDocumentHyperlinkByIndexOnline.');
        }
        // verify required parameter 'this.hyperlinkIndex' is not undefined
        if (this.hyperlinkIndex === undefined) {
            throw new Error('Required parameter "this.hyperlinkIndex" was undefined when calling getDocumentHyperlinkByIndexOnline.');
        }

        // verify required parameter 'this.hyperlinkIndex' is not null
        if (this.hyperlinkIndex === null) {
            throw new Error('Required parameter "this.hyperlinkIndex" was null when calling getDocumentHyperlinkByIndexOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HyperlinkResponse");
	}
}

/**
 * Request model for GetDocumentHyperlinks operation.
 * Reads hyperlinks from the document.
 */
export class GetDocumentHyperlinksRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentHyperlinksRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/hyperlinks"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentHyperlinks.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentHyperlinks.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HyperlinksResponse");
	}
}

/**
 * Request model for GetDocumentHyperlinksOnline operation.
 * Reads hyperlinks from the document.
 */
export class GetDocumentHyperlinksOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentHyperlinksOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/hyperlinks"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getDocumentHyperlinksOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getDocumentHyperlinksOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HyperlinksResponse");
	}
}

/**
 * Request model for GetDocumentProperties operation.
 * Reads document properties.
 */
export class GetDocumentPropertiesRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentPropertiesRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/documentProperties"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentProperties.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentProperties.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentPropertiesResponse");
	}
}

/**
 * Request model for GetDocumentPropertiesOnline operation.
 * Reads document properties.
 */
export class GetDocumentPropertiesOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentPropertiesOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/documentProperties"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getDocumentPropertiesOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getDocumentPropertiesOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentPropertiesResponse");
	}
}

/**
 * Request model for GetDocumentProperty operation.
 * Reads a document property.
 */
export class GetDocumentPropertyRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentPropertyRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The name of the property.
     */
    public propertyName: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/documentProperties/{propertyName}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentProperty.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentProperty.');
        }
        // verify required parameter 'this.propertyName' is not undefined
        if (this.propertyName === undefined) {
            throw new Error('Required parameter "this.propertyName" was undefined when calling getDocumentProperty.');
        }

        // verify required parameter 'this.propertyName' is not null
        if (this.propertyName === null) {
            throw new Error('Required parameter "this.propertyName" was null when calling getDocumentProperty.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentPropertyResponse");
	}
}

/**
 * Request model for GetDocumentPropertyOnline operation.
 * Reads a document property.
 */
export class GetDocumentPropertyOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentPropertyOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The name of the property.
     */
    public propertyName: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/documentProperties/{propertyName}"
            .replace("/{" + "propertyName" + "}", (this.propertyName !== null && this.propertyName !== undefined) ? "/" + String(this.propertyName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getDocumentPropertyOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getDocumentPropertyOnline.');
        }
        // verify required parameter 'this.propertyName' is not undefined
        if (this.propertyName === undefined) {
            throw new Error('Required parameter "this.propertyName" was undefined when calling getDocumentPropertyOnline.');
        }

        // verify required parameter 'this.propertyName' is not null
        if (this.propertyName === null) {
            throw new Error('Required parameter "this.propertyName" was null when calling getDocumentPropertyOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentPropertyResponse");
	}
}

/**
 * Request model for GetDocumentProtection operation.
 * Reads protection properties from the document.
 */
export class GetDocumentProtectionRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentProtectionRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/protection"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentProtection.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentProtection.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ProtectionDataResponse");
	}
}

/**
 * Request model for GetDocumentProtectionOnline operation.
 * Reads protection properties from the document.
 */
export class GetDocumentProtectionOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentProtectionOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/protection"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getDocumentProtectionOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getDocumentProtectionOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ProtectionDataResponse");
	}
}

/**
 * Request model for GetDocumentStatistics operation.
 * Reads document statistics.
 */
export class GetDocumentStatisticsRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentStatisticsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The flag indicating whether to include comments from the WordCount. The default value is "false".
     */
    public includeComments: boolean;

    /**
     * The flag indicating whether to include footnotes from the WordCount. The default value is "false".
     */
    public includeFootnotes: boolean;

    /**
     * The flag indicating whether to include shape's text from the WordCount. The default value is "false".
     */
    public includeTextInShapes: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/statistics"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentStatistics.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentStatistics.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "includeComments", this.includeComments, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "includeFootnotes", this.includeFootnotes, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "includeTextInShapes", this.includeTextInShapes, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StatDataResponse");
	}
}

/**
 * Request model for GetDocumentStatisticsOnline operation.
 * Reads document statistics.
 */
export class GetDocumentStatisticsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentStatisticsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The flag indicating whether to include comments from the WordCount. The default value is "false".
     */
    public includeComments: boolean;

    /**
     * The flag indicating whether to include footnotes from the WordCount. The default value is "false".
     */
    public includeFootnotes: boolean;

    /**
     * The flag indicating whether to include shape's text from the WordCount. The default value is "false".
     */
    public includeTextInShapes: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/statistics"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getDocumentStatisticsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getDocumentStatisticsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "includeComments", this.includeComments, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "includeFootnotes", this.includeFootnotes, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "includeTextInShapes", this.includeTextInShapes, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StatDataResponse");
	}
}

/**
 * Request model for GetDocumentWithFormat operation.
 * Converts a document in cloud storage to the specified format.
 */
export class GetDocumentWithFormatRequest implements RequestInterface {

    public constructor(init?: Partial< GetDocumentWithFormatRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The destination format.
     */
    public format: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The path to the output document.
     */
    public outPath: string;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getDocumentWithFormat.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getDocumentWithFormat.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling getDocumentWithFormat.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling getDocumentWithFormat.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "outPath", this.outPath, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for GetField operation.
 * Reads a field from the document node.
 */
export class GetFieldRequest implements RequestInterface {

    public constructor(init?: Partial< GetFieldRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getField.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getField.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getField.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getField.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldResponse");
	}
}

/**
 * Request model for GetFieldOnline operation.
 * Reads a field from the document node.
 */
export class GetFieldOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetFieldOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/fields/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getFieldOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getFieldOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getFieldOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getFieldOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldResponse");
	}
}

/**
 * Request model for GetFields operation.
 * Reads fields from the document node.
 */
export class GetFieldsRequest implements RequestInterface {

    public constructor(init?: Partial< GetFieldsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getFields.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getFields.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldsResponse");
	}
}

/**
 * Request model for GetFieldsOnline operation.
 * Reads fields from the document node.
 */
export class GetFieldsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetFieldsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/fields"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getFieldsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getFieldsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldsResponse");
	}
}

/**
 * Request model for GetFilesList operation.
 * Get all files and folders within a folder.
 */
export class GetFilesListRequest implements RequestInterface {

    public constructor(init?: Partial< GetFilesListRequest >) {
        Object.assign(this, init);
    }

    /**
     * Folder path e.g. '/folder'.
     */
    public path: string;

    /**
     * Storage name.
     */
    public storageName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/storage/folder/{path}"
            .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.path' is not undefined
        if (this.path === undefined) {
            throw new Error('Required parameter "this.path" was undefined when calling getFilesList.');
        }

        // verify required parameter 'this.path' is not null
        if (this.path === null) {
            throw new Error('Required parameter "this.path" was null when calling getFilesList.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FilesList");
	}
}

/**
 * Request model for GetFootnote operation.
 * Reads a footnote from the document node.
 */
export class GetFootnoteRequest implements RequestInterface {

    public constructor(init?: Partial< GetFootnoteRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/footnotes/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getFootnote.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getFootnote.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getFootnote.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getFootnote.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnoteResponse");
	}
}

/**
 * Request model for GetFootnoteOnline operation.
 * Reads a footnote from the document node.
 */
export class GetFootnoteOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetFootnoteOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/footnotes/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getFootnoteOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getFootnoteOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getFootnoteOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getFootnoteOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnoteResponse");
	}
}

/**
 * Request model for GetFootnotes operation.
 * Reads footnotes from the document node.
 */
export class GetFootnotesRequest implements RequestInterface {

    public constructor(init?: Partial< GetFootnotesRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/footnotes"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getFootnotes.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getFootnotes.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnotesResponse");
	}
}

/**
 * Request model for GetFootnotesOnline operation.
 * Reads footnotes from the document node.
 */
export class GetFootnotesOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetFootnotesOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/footnotes"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getFootnotesOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getFootnotesOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnotesResponse");
	}
}

/**
 * Request model for GetFormField operation.
 * Reads a form field from the document node.
 */
export class GetFormFieldRequest implements RequestInterface {

    public constructor(init?: Partial< GetFormFieldRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/formfields/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getFormField.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getFormField.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getFormField.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getFormField.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldResponse");
	}
}

/**
 * Request model for GetFormFieldOnline operation.
 * Reads a form field from the document node.
 */
export class GetFormFieldOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetFormFieldOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/formfields/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getFormFieldOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getFormFieldOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getFormFieldOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getFormFieldOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldResponse");
	}
}

/**
 * Request model for GetFormFields operation.
 * Reads form fields from the document node.
 */
export class GetFormFieldsRequest implements RequestInterface {

    public constructor(init?: Partial< GetFormFieldsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/formfields"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getFormFields.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getFormFields.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldsResponse");
	}
}

/**
 * Request model for GetFormFieldsOnline operation.
 * Reads form fields from the document node.
 */
export class GetFormFieldsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetFormFieldsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/formfields"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getFormFieldsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getFormFieldsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldsResponse");
	}
}

/**
 * Request model for GetHeaderFooter operation.
 * Reads a HeaderFooter object from the document.
 */
export class GetHeaderFooterRequest implements RequestInterface {

    public constructor(init?: Partial< GetHeaderFooterRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the HeaderFooter object.
     */
    public headerFooterIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The list of HeaderFooter types.
     */
    public filterByType: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/headersfooters/{headerFooterIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "headerFooterIndex" + "}", (this.headerFooterIndex !== null && this.headerFooterIndex !== undefined) ? "/" + String(this.headerFooterIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getHeaderFooter.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getHeaderFooter.');
        }
        // verify required parameter 'this.headerFooterIndex' is not undefined
        if (this.headerFooterIndex === undefined) {
            throw new Error('Required parameter "this.headerFooterIndex" was undefined when calling getHeaderFooter.');
        }

        // verify required parameter 'this.headerFooterIndex' is not null
        if (this.headerFooterIndex === null) {
            throw new Error('Required parameter "this.headerFooterIndex" was null when calling getHeaderFooter.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFooterResponse");
	}
}

/**
 * Request model for GetHeaderFooterOfSection operation.
 * Reads a HeaderFooter object from the document section.
 */
export class GetHeaderFooterOfSectionRequest implements RequestInterface {

    public constructor(init?: Partial< GetHeaderFooterOfSectionRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the HeaderFooter object.
     */
    public headerFooterIndex: number;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The list of HeaderFooter types.
     */
    public filterByType: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}/headersfooters/{headerFooterIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "headerFooterIndex" + "}", (this.headerFooterIndex !== null && this.headerFooterIndex !== undefined) ? "/" + String(this.headerFooterIndex) : "")
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getHeaderFooterOfSection.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getHeaderFooterOfSection.');
        }
        // verify required parameter 'this.headerFooterIndex' is not undefined
        if (this.headerFooterIndex === undefined) {
            throw new Error('Required parameter "this.headerFooterIndex" was undefined when calling getHeaderFooterOfSection.');
        }

        // verify required parameter 'this.headerFooterIndex' is not null
        if (this.headerFooterIndex === null) {
            throw new Error('Required parameter "this.headerFooterIndex" was null when calling getHeaderFooterOfSection.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling getHeaderFooterOfSection.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling getHeaderFooterOfSection.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFooterResponse");
	}
}

/**
 * Request model for GetHeaderFooterOfSectionOnline operation.
 * Reads a HeaderFooter object from the document section.
 */
export class GetHeaderFooterOfSectionOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetHeaderFooterOfSectionOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the HeaderFooter object.
     */
    public headerFooterIndex: number;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The list of HeaderFooter types.
     */
    public filterByType: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/sections/{sectionIndex}/headersfooters/{headerFooterIndex}"
            .replace("/{" + "headerFooterIndex" + "}", (this.headerFooterIndex !== null && this.headerFooterIndex !== undefined) ? "/" + String(this.headerFooterIndex) : "")
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getHeaderFooterOfSectionOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getHeaderFooterOfSectionOnline.');
        }
        // verify required parameter 'this.headerFooterIndex' is not undefined
        if (this.headerFooterIndex === undefined) {
            throw new Error('Required parameter "this.headerFooterIndex" was undefined when calling getHeaderFooterOfSectionOnline.');
        }

        // verify required parameter 'this.headerFooterIndex' is not null
        if (this.headerFooterIndex === null) {
            throw new Error('Required parameter "this.headerFooterIndex" was null when calling getHeaderFooterOfSectionOnline.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling getHeaderFooterOfSectionOnline.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling getHeaderFooterOfSectionOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFooterResponse");
	}
}

/**
 * Request model for GetHeaderFooterOnline operation.
 * Reads a HeaderFooter object from the document.
 */
export class GetHeaderFooterOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetHeaderFooterOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the HeaderFooter object.
     */
    public headerFooterIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The list of HeaderFooter types.
     */
    public filterByType: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/headersfooters/{headerFooterIndex}"
            .replace("/{" + "headerFooterIndex" + "}", (this.headerFooterIndex !== null && this.headerFooterIndex !== undefined) ? "/" + String(this.headerFooterIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getHeaderFooterOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getHeaderFooterOnline.');
        }
        // verify required parameter 'this.headerFooterIndex' is not undefined
        if (this.headerFooterIndex === undefined) {
            throw new Error('Required parameter "this.headerFooterIndex" was undefined when calling getHeaderFooterOnline.');
        }

        // verify required parameter 'this.headerFooterIndex' is not null
        if (this.headerFooterIndex === null) {
            throw new Error('Required parameter "this.headerFooterIndex" was null when calling getHeaderFooterOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFooterResponse");
	}
}

/**
 * Request model for GetHeaderFooters operation.
 * Reads HeaderFooter objects from the document section.
 */
export class GetHeaderFootersRequest implements RequestInterface {

    public constructor(init?: Partial< GetHeaderFootersRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the section in the document tree.
     */
    public sectionPath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The list of HeaderFooter types.
     */
    public filterByType: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{sectionPath}/headersfooters"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getHeaderFooters.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getHeaderFooters.');
        }
        // verify required parameter 'this.sectionPath' is not undefined
        if (this.sectionPath === undefined) {
            throw new Error('Required parameter "this.sectionPath" was undefined when calling getHeaderFooters.');
        }

        // verify required parameter 'this.sectionPath' is not null
        if (this.sectionPath === null) {
            throw new Error('Required parameter "this.sectionPath" was null when calling getHeaderFooters.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFootersResponse");
	}
}

/**
 * Request model for GetHeaderFootersOnline operation.
 * Reads HeaderFooter objects from the document section.
 */
export class GetHeaderFootersOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetHeaderFootersOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the section in the document tree.
     */
    public sectionPath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The list of HeaderFooter types.
     */
    public filterByType: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{sectionPath}/headersfooters"
            .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getHeaderFootersOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getHeaderFootersOnline.');
        }
        // verify required parameter 'this.sectionPath' is not undefined
        if (this.sectionPath === undefined) {
            throw new Error('Required parameter "this.sectionPath" was undefined when calling getHeaderFootersOnline.');
        }

        // verify required parameter 'this.sectionPath' is not null
        if (this.sectionPath === null) {
            throw new Error('Required parameter "this.sectionPath" was null when calling getHeaderFootersOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "filterByType", this.filterByType, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFootersResponse");
	}
}

/**
 * Request model for GetInfo operation.
 * Returns application info.
 */
export class GetInfoRequest implements RequestInterface {

    public constructor(init?: Partial< GetInfoRequest >) {
        Object.assign(this, init);
    }


	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        const localVarPath = configuration.getApiBaseUrl() + "/words/info"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "InfoResponse");
	}
}

/**
 * Request model for GetList operation.
 * Reads a list from the document.
 */
export class GetListRequest implements RequestInterface {

    public constructor(init?: Partial< GetListRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The list Id.
     */
    public listId: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/lists/{listId}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getList.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getList.');
        }
        // verify required parameter 'this.listId' is not undefined
        if (this.listId === undefined) {
            throw new Error('Required parameter "this.listId" was undefined when calling getList.');
        }

        // verify required parameter 'this.listId' is not null
        if (this.listId === null) {
            throw new Error('Required parameter "this.listId" was null when calling getList.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListResponse");
	}
}

/**
 * Request model for GetListOnline operation.
 * Reads a list from the document.
 */
export class GetListOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetListOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The list Id.
     */
    public listId: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/lists/{listId}"
            .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getListOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getListOnline.');
        }
        // verify required parameter 'this.listId' is not undefined
        if (this.listId === undefined) {
            throw new Error('Required parameter "this.listId" was undefined when calling getListOnline.');
        }

        // verify required parameter 'this.listId' is not null
        if (this.listId === null) {
            throw new Error('Required parameter "this.listId" was null when calling getListOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListResponse");
	}
}

/**
 * Request model for GetLists operation.
 * Reads lists from the document.
 */
export class GetListsRequest implements RequestInterface {

    public constructor(init?: Partial< GetListsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/lists"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getLists.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getLists.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListsResponse");
	}
}

/**
 * Request model for GetListsOnline operation.
 * Reads lists from the document.
 */
export class GetListsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetListsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/lists"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getListsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getListsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListsResponse");
	}
}

/**
 * Request model for GetOfficeMathObject operation.
 * Reads an OfficeMath object from the document node.
 */
export class GetOfficeMathObjectRequest implements RequestInterface {

    public constructor(init?: Partial< GetOfficeMathObjectRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/OfficeMathObjects/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getOfficeMathObject.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getOfficeMathObject.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getOfficeMathObject.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getOfficeMathObject.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "OfficeMathObjectResponse");
	}
}

/**
 * Request model for GetOfficeMathObjectOnline operation.
 * Reads an OfficeMath object from the document node.
 */
export class GetOfficeMathObjectOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetOfficeMathObjectOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/OfficeMathObjects/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getOfficeMathObjectOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getOfficeMathObjectOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getOfficeMathObjectOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getOfficeMathObjectOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "OfficeMathObjectResponse");
	}
}

/**
 * Request model for GetOfficeMathObjects operation.
 * Reads OfficeMath objects from the document node.
 */
export class GetOfficeMathObjectsRequest implements RequestInterface {

    public constructor(init?: Partial< GetOfficeMathObjectsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/OfficeMathObjects"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getOfficeMathObjects.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getOfficeMathObjects.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "OfficeMathObjectsResponse");
	}
}

/**
 * Request model for GetOfficeMathObjectsOnline operation.
 * Reads OfficeMath objects from the document node.
 */
export class GetOfficeMathObjectsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetOfficeMathObjectsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/OfficeMathObjects"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getOfficeMathObjectsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getOfficeMathObjectsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "OfficeMathObjectsResponse");
	}
}

/**
 * Request model for GetParagraph operation.
 * Reads a paragraph from the document node.
 */
export class GetParagraphRequest implements RequestInterface {

    public constructor(init?: Partial< GetParagraphRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getParagraph.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getParagraph.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getParagraph.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getParagraph.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphResponse");
	}
}

/**
 * Request model for GetParagraphFormat operation.
 * Reads the formatting properties of a paragraph from the document node.
 */
export class GetParagraphFormatRequest implements RequestInterface {

    public constructor(init?: Partial< GetParagraphFormatRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/format"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getParagraphFormat.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getParagraphFormat.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getParagraphFormat.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getParagraphFormat.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphFormatResponse");
	}
}

/**
 * Request model for GetParagraphFormatOnline operation.
 * Reads the formatting properties of a paragraph from the document node.
 */
export class GetParagraphFormatOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetParagraphFormatOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs/{index}/format"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getParagraphFormatOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getParagraphFormatOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getParagraphFormatOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getParagraphFormatOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphFormatResponse");
	}
}

/**
 * Request model for GetParagraphListFormat operation.
 * Reads the formatting properties of a paragraph list from the document node.
 */
export class GetParagraphListFormatRequest implements RequestInterface {

    public constructor(init?: Partial< GetParagraphListFormatRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/listFormat"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getParagraphListFormat.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getParagraphListFormat.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getParagraphListFormat.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getParagraphListFormat.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphListFormatResponse");
	}
}

/**
 * Request model for GetParagraphListFormatOnline operation.
 * Reads the formatting properties of a paragraph list from the document node.
 */
export class GetParagraphListFormatOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetParagraphListFormatOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs/{index}/listFormat"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getParagraphListFormatOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getParagraphListFormatOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getParagraphListFormatOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getParagraphListFormatOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphListFormatResponse");
	}
}

/**
 * Request model for GetParagraphOnline operation.
 * Reads a paragraph from the document node.
 */
export class GetParagraphOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetParagraphOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getParagraphOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getParagraphOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getParagraphOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getParagraphOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphResponse");
	}
}

/**
 * Request model for GetParagraphs operation.
 * Reads paragraphs from the document node.
 */
export class GetParagraphsRequest implements RequestInterface {

    public constructor(init?: Partial< GetParagraphsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getParagraphs.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getParagraphs.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphLinkCollectionResponse");
	}
}

/**
 * Request model for GetParagraphsOnline operation.
 * Reads paragraphs from the document node.
 */
export class GetParagraphsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetParagraphsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getParagraphsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getParagraphsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphLinkCollectionResponse");
	}
}

/**
 * Request model for GetParagraphTabStops operation.
 * Reads paragraph tab stops from the document node.
 */
export class GetParagraphTabStopsRequest implements RequestInterface {

    public constructor(init?: Partial< GetParagraphTabStopsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/tabstops"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getParagraphTabStops.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getParagraphTabStops.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getParagraphTabStops.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getParagraphTabStops.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TabStopsResponse");
	}
}

/**
 * Request model for GetParagraphTabStopsOnline operation.
 * Reads paragraph tab stops from the document node.
 */
export class GetParagraphTabStopsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetParagraphTabStopsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs/{index}/tabstops"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getParagraphTabStopsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getParagraphTabStopsOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getParagraphTabStopsOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getParagraphTabStopsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TabStopsResponse");
	}
}

/**
 * Request model for GetPublicKey operation.
 * Get assymetric public key.
 */
export class GetPublicKeyRequest implements RequestInterface {

    public constructor(init?: Partial< GetPublicKeyRequest >) {
        Object.assign(this, init);
    }


	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        const localVarPath = configuration.getApiBaseUrl() + "/words/encryption/publickey"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "PublicKeyResponse");
	}
}

/**
 * Request model for GetRangeText operation.
 * Reads range text from the document.
 */
export class GetRangeTextRequest implements RequestInterface {

    public constructor(init?: Partial< GetRangeTextRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The range start identifier. Identifier examples: id0.0.0, page0.
     */
    public rangeStartIdentifier: string;

    /**
     * The range end identifier. Identifier examples: id1.0.0, id0.0.0:end, page1, page1:end, document:end.
     */
    public rangeEndIdentifier: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
            .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getRangeText.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getRangeText.');
        }
        // verify required parameter 'this.rangeStartIdentifier' is not undefined
        if (this.rangeStartIdentifier === undefined) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling getRangeText.');
        }

        // verify required parameter 'this.rangeStartIdentifier' is not null
        if (this.rangeStartIdentifier === null) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling getRangeText.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RangeTextResponse");
	}
}

/**
 * Request model for GetRangeTextOnline operation.
 * Reads range text from the document.
 */
export class GetRangeTextOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetRangeTextOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The range start identifier. Identifier examples: id0.0.0, page0.
     */
    public rangeStartIdentifier: string;

    /**
     * The range end identifier. Identifier examples: id1.0.0, id0.0.0:end, page1, page1:end, document:end.
     */
    public rangeEndIdentifier: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
            .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
            .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getRangeTextOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getRangeTextOnline.');
        }
        // verify required parameter 'this.rangeStartIdentifier' is not undefined
        if (this.rangeStartIdentifier === undefined) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling getRangeTextOnline.');
        }

        // verify required parameter 'this.rangeStartIdentifier' is not null
        if (this.rangeStartIdentifier === null) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling getRangeTextOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RangeTextResponse");
	}
}

/**
 * Request model for GetRun operation.
 * Reads a Run object from the paragraph.
 */
export class GetRunRequest implements RequestInterface {

    public constructor(init?: Partial< GetRunRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getRun.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getRun.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRun.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling getRun.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getRun.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getRun.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunResponse");
	}
}

/**
 * Request model for GetRunFont operation.
 * Reads the font properties of a Run object from the paragraph.
 */
export class GetRunFontRequest implements RequestInterface {

    public constructor(init?: Partial< GetRunFontRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs/{index}/font"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getRunFont.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getRunFont.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRunFont.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling getRunFont.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getRunFont.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getRunFont.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FontResponse");
	}
}

/**
 * Request model for GetRunFontOnline operation.
 * Reads the font properties of a Run object from the paragraph.
 */
export class GetRunFontOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetRunFontOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{paragraphPath}/runs/{index}/font"
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getRunFontOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getRunFontOnline.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRunFontOnline.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling getRunFontOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getRunFontOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getRunFontOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FontResponse");
	}
}

/**
 * Request model for GetRunOnline operation.
 * Reads a Run object from the paragraph.
 */
export class GetRunOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetRunOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{paragraphPath}/runs/{index}"
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getRunOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getRunOnline.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRunOnline.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling getRunOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getRunOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getRunOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunResponse");
	}
}

/**
 * Request model for GetRuns operation.
 * Reads Run objects from the paragraph.
 */
export class GetRunsRequest implements RequestInterface {

    public constructor(init?: Partial< GetRunsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getRuns.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getRuns.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRuns.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling getRuns.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunsResponse");
	}
}

/**
 * Request model for GetRunsOnline operation.
 * Reads Run objects from the paragraph.
 */
export class GetRunsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetRunsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{paragraphPath}/runs"
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getRunsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getRunsOnline.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling getRunsOnline.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling getRunsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunsResponse");
	}
}

/**
 * Request model for GetSection operation.
 * Reads a section from the document.
 */
export class GetSectionRequest implements RequestInterface {

    public constructor(init?: Partial< GetSectionRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getSection.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getSection.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling getSection.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling getSection.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionResponse");
	}
}

/**
 * Request model for GetSectionOnline operation.
 * Reads a section from the document.
 */
export class GetSectionOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetSectionOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/sections/{sectionIndex}"
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getSectionOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getSectionOnline.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling getSectionOnline.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling getSectionOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionResponse");
	}
}

/**
 * Request model for GetSectionPageSetup operation.
 * Reads the page setup of a section from the document.
 */
export class GetSectionPageSetupRequest implements RequestInterface {

    public constructor(init?: Partial< GetSectionPageSetupRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}/pageSetup"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getSectionPageSetup.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getSectionPageSetup.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling getSectionPageSetup.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling getSectionPageSetup.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionPageSetupResponse");
	}
}

/**
 * Request model for GetSectionPageSetupOnline operation.
 * Reads the page setup of a section from the document.
 */
export class GetSectionPageSetupOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetSectionPageSetupOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/sections/{sectionIndex}/pageSetup"
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getSectionPageSetupOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getSectionPageSetupOnline.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling getSectionPageSetupOnline.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling getSectionPageSetupOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionPageSetupResponse");
	}
}

/**
 * Request model for GetSections operation.
 * Reads sections from the document.
 */
export class GetSectionsRequest implements RequestInterface {

    public constructor(init?: Partial< GetSectionsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getSections.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getSections.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionLinkCollectionResponse");
	}
}

/**
 * Request model for GetSectionsOnline operation.
 * Reads sections from the document.
 */
export class GetSectionsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetSectionsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/sections"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getSectionsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getSectionsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionLinkCollectionResponse");
	}
}

/**
 * Request model for GetSignatures operation.
 * Gets signatures from the document.
 */
export class GetSignaturesRequest implements RequestInterface {

    public constructor(init?: Partial< GetSignaturesRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the Word document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/signatures"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getSignatures.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getSignatures.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SignatureCollectionResponse");
	}
}

/**
 * Request model for GetSignaturesOnline operation.
 * Gets signatures from the document.
 */
export class GetSignaturesOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetSignaturesOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/signatures"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getSignaturesOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getSignaturesOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SignatureCollectionResponse");
	}
}

/**
 * Request model for GetStructuredDocumentTag operation.
 * Reads a StructuredDocumentTag (SDT) from the document node.
 */
export class GetStructuredDocumentTagRequest implements RequestInterface {

    public constructor(init?: Partial< GetStructuredDocumentTagRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/sdt/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getStructuredDocumentTag.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getStructuredDocumentTag.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getStructuredDocumentTag.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getStructuredDocumentTag.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagResponse");
	}
}

/**
 * Request model for GetStructuredDocumentTagOnline operation.
 * Reads a StructuredDocumentTag (SDT) from the document node.
 */
export class GetStructuredDocumentTagOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetStructuredDocumentTagOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/sdt/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getStructuredDocumentTagOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getStructuredDocumentTagOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getStructuredDocumentTagOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getStructuredDocumentTagOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagResponse");
	}
}

/**
 * Request model for GetStructuredDocumentTags operation.
 * Reads StructuredDocumentTags (SDT) from the document node.
 */
export class GetStructuredDocumentTagsRequest implements RequestInterface {

    public constructor(init?: Partial< GetStructuredDocumentTagsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/sdt"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getStructuredDocumentTags.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getStructuredDocumentTags.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagsResponse");
	}
}

/**
 * Request model for GetStructuredDocumentTagsOnline operation.
 * Reads StructuredDocumentTags (SDT) from the document node.
 */
export class GetStructuredDocumentTagsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetStructuredDocumentTagsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/sdt"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getStructuredDocumentTagsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getStructuredDocumentTagsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagsResponse");
	}
}

/**
 * Request model for GetStyle operation.
 * Reads a style from the document.
 */
export class GetStyleRequest implements RequestInterface {

    public constructor(init?: Partial< GetStyleRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The name of the style.
     */
    public styleName: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles/{styleName}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "styleName" + "}", (this.styleName !== null && this.styleName !== undefined) ? "/" + String(this.styleName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getStyle.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getStyle.');
        }
        // verify required parameter 'this.styleName' is not undefined
        if (this.styleName === undefined) {
            throw new Error('Required parameter "this.styleName" was undefined when calling getStyle.');
        }

        // verify required parameter 'this.styleName' is not null
        if (this.styleName === null) {
            throw new Error('Required parameter "this.styleName" was null when calling getStyle.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
	}
}

/**
 * Request model for GetStyleFromDocumentElement operation.
 * Reads a style from the document node.
 */
export class GetStyleFromDocumentElementRequest implements RequestInterface {

    public constructor(init?: Partial< GetStyleFromDocumentElementRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree, that supports styles: ParagraphFormat, List, ListLevel, Table.
     */
    public styledNodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{styledNodePath}/style"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "styledNodePath" + "}", (this.styledNodePath !== null && this.styledNodePath !== undefined) ? "/" + String(this.styledNodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getStyleFromDocumentElement.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getStyleFromDocumentElement.');
        }
        // verify required parameter 'this.styledNodePath' is not undefined
        if (this.styledNodePath === undefined) {
            throw new Error('Required parameter "this.styledNodePath" was undefined when calling getStyleFromDocumentElement.');
        }

        // verify required parameter 'this.styledNodePath' is not null
        if (this.styledNodePath === null) {
            throw new Error('Required parameter "this.styledNodePath" was null when calling getStyleFromDocumentElement.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
	}
}

/**
 * Request model for GetStyleFromDocumentElementOnline operation.
 * Reads a style from the document node.
 */
export class GetStyleFromDocumentElementOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetStyleFromDocumentElementOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree, that supports styles: ParagraphFormat, List, ListLevel, Table.
     */
    public styledNodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{styledNodePath}/style"
            .replace("/{" + "styledNodePath" + "}", (this.styledNodePath !== null && this.styledNodePath !== undefined) ? "/" + String(this.styledNodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getStyleFromDocumentElementOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getStyleFromDocumentElementOnline.');
        }
        // verify required parameter 'this.styledNodePath' is not undefined
        if (this.styledNodePath === undefined) {
            throw new Error('Required parameter "this.styledNodePath" was undefined when calling getStyleFromDocumentElementOnline.');
        }

        // verify required parameter 'this.styledNodePath' is not null
        if (this.styledNodePath === null) {
            throw new Error('Required parameter "this.styledNodePath" was null when calling getStyleFromDocumentElementOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
	}
}

/**
 * Request model for GetStyleOnline operation.
 * Reads a style from the document.
 */
export class GetStyleOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetStyleOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The name of the style.
     */
    public styleName: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/styles/{styleName}"
            .replace("/{" + "styleName" + "}", (this.styleName !== null && this.styleName !== undefined) ? "/" + String(this.styleName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getStyleOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getStyleOnline.');
        }
        // verify required parameter 'this.styleName' is not undefined
        if (this.styleName === undefined) {
            throw new Error('Required parameter "this.styleName" was undefined when calling getStyleOnline.');
        }

        // verify required parameter 'this.styleName' is not null
        if (this.styleName === null) {
            throw new Error('Required parameter "this.styleName" was null when calling getStyleOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
	}
}

/**
 * Request model for GetStyles operation.
 * Reads styles from the document.
 */
export class GetStylesRequest implements RequestInterface {

    public constructor(init?: Partial< GetStylesRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getStyles.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getStyles.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StylesResponse");
	}
}

/**
 * Request model for GetStylesOnline operation.
 * Reads styles from the document.
 */
export class GetStylesOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetStylesOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/styles"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getStylesOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getStylesOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StylesResponse");
	}
}

/**
 * Request model for GetTable operation.
 * Reads a table from the document node.
 */
export class GetTableRequest implements RequestInterface {

    public constructor(init?: Partial< GetTableRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getTable.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getTable.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTable.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTable.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableResponse");
	}
}

/**
 * Request model for GetTableCell operation.
 * Reads a cell from the table row.
 */
export class GetTableCellRequest implements RequestInterface {

    public constructor(init?: Partial< GetTableCellRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the table row in the document tree.
     */
    public tableRowPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tableRowPath}/cells/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getTableCell.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getTableCell.');
        }
        // verify required parameter 'this.tableRowPath' is not undefined
        if (this.tableRowPath === undefined) {
            throw new Error('Required parameter "this.tableRowPath" was undefined when calling getTableCell.');
        }

        // verify required parameter 'this.tableRowPath' is not null
        if (this.tableRowPath === null) {
            throw new Error('Required parameter "this.tableRowPath" was null when calling getTableCell.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTableCell.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTableCell.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellResponse");
	}
}

/**
 * Request model for GetTableCellFormat operation.
 * Reads the formatting properties of a table cell.
 */
export class GetTableCellFormatRequest implements RequestInterface {

    public constructor(init?: Partial< GetTableCellFormatRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the table row in the document tree.
     */
    public tableRowPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tableRowPath}/cells/{index}/cellformat"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getTableCellFormat.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getTableCellFormat.');
        }
        // verify required parameter 'this.tableRowPath' is not undefined
        if (this.tableRowPath === undefined) {
            throw new Error('Required parameter "this.tableRowPath" was undefined when calling getTableCellFormat.');
        }

        // verify required parameter 'this.tableRowPath' is not null
        if (this.tableRowPath === null) {
            throw new Error('Required parameter "this.tableRowPath" was null when calling getTableCellFormat.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTableCellFormat.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTableCellFormat.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellFormatResponse");
	}
}

/**
 * Request model for GetTableCellFormatOnline operation.
 * Reads the formatting properties of a table cell.
 */
export class GetTableCellFormatOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetTableCellFormatOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the table row in the document tree.
     */
    public tableRowPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{tableRowPath}/cells/{index}/cellformat"
            .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getTableCellFormatOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getTableCellFormatOnline.');
        }
        // verify required parameter 'this.tableRowPath' is not undefined
        if (this.tableRowPath === undefined) {
            throw new Error('Required parameter "this.tableRowPath" was undefined when calling getTableCellFormatOnline.');
        }

        // verify required parameter 'this.tableRowPath' is not null
        if (this.tableRowPath === null) {
            throw new Error('Required parameter "this.tableRowPath" was null when calling getTableCellFormatOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTableCellFormatOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTableCellFormatOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellFormatResponse");
	}
}

/**
 * Request model for GetTableCellOnline operation.
 * Reads a cell from the table row.
 */
export class GetTableCellOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetTableCellOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the table row in the document tree.
     */
    public tableRowPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{tableRowPath}/cells/{index}"
            .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getTableCellOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getTableCellOnline.');
        }
        // verify required parameter 'this.tableRowPath' is not undefined
        if (this.tableRowPath === undefined) {
            throw new Error('Required parameter "this.tableRowPath" was undefined when calling getTableCellOnline.');
        }

        // verify required parameter 'this.tableRowPath' is not null
        if (this.tableRowPath === null) {
            throw new Error('Required parameter "this.tableRowPath" was null when calling getTableCellOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTableCellOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTableCellOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellResponse");
	}
}

/**
 * Request model for GetTableOnline operation.
 * Reads a table from the document node.
 */
export class GetTableOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetTableOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/tables/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getTableOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getTableOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTableOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTableOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableResponse");
	}
}

/**
 * Request model for GetTableProperties operation.
 * Reads properties of a table from the document node.
 */
export class GetTablePropertiesRequest implements RequestInterface {

    public constructor(init?: Partial< GetTablePropertiesRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables/{index}/properties"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getTableProperties.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getTableProperties.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTableProperties.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTableProperties.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TablePropertiesResponse");
	}
}

/**
 * Request model for GetTablePropertiesOnline operation.
 * Reads properties of a table from the document node.
 */
export class GetTablePropertiesOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetTablePropertiesOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/tables/{index}/properties"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getTablePropertiesOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getTablePropertiesOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTablePropertiesOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTablePropertiesOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TablePropertiesResponse");
	}
}

/**
 * Request model for GetTableRow operation.
 * Reads a row from the table.
 */
export class GetTableRowRequest implements RequestInterface {

    public constructor(init?: Partial< GetTableRowRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the table in the document tree.
     */
    public tablePath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tablePath}/rows/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getTableRow.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getTableRow.');
        }
        // verify required parameter 'this.tablePath' is not undefined
        if (this.tablePath === undefined) {
            throw new Error('Required parameter "this.tablePath" was undefined when calling getTableRow.');
        }

        // verify required parameter 'this.tablePath' is not null
        if (this.tablePath === null) {
            throw new Error('Required parameter "this.tablePath" was null when calling getTableRow.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTableRow.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTableRow.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowResponse");
	}
}

/**
 * Request model for GetTableRowFormat operation.
 * Reads the formatting properties of a table row.
 */
export class GetTableRowFormatRequest implements RequestInterface {

    public constructor(init?: Partial< GetTableRowFormatRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the table in the document tree.
     */
    public tablePath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tablePath}/rows/{index}/rowformat"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getTableRowFormat.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getTableRowFormat.');
        }
        // verify required parameter 'this.tablePath' is not undefined
        if (this.tablePath === undefined) {
            throw new Error('Required parameter "this.tablePath" was undefined when calling getTableRowFormat.');
        }

        // verify required parameter 'this.tablePath' is not null
        if (this.tablePath === null) {
            throw new Error('Required parameter "this.tablePath" was null when calling getTableRowFormat.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTableRowFormat.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTableRowFormat.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowFormatResponse");
	}
}

/**
 * Request model for GetTableRowFormatOnline operation.
 * Reads the formatting properties of a table row.
 */
export class GetTableRowFormatOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetTableRowFormatOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the table in the document tree.
     */
    public tablePath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{tablePath}/rows/{index}/rowformat"
            .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getTableRowFormatOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getTableRowFormatOnline.');
        }
        // verify required parameter 'this.tablePath' is not undefined
        if (this.tablePath === undefined) {
            throw new Error('Required parameter "this.tablePath" was undefined when calling getTableRowFormatOnline.');
        }

        // verify required parameter 'this.tablePath' is not null
        if (this.tablePath === null) {
            throw new Error('Required parameter "this.tablePath" was null when calling getTableRowFormatOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTableRowFormatOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTableRowFormatOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowFormatResponse");
	}
}

/**
 * Request model for GetTableRowOnline operation.
 * Reads a row from the table.
 */
export class GetTableRowOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetTableRowOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the table in the document tree.
     */
    public tablePath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{tablePath}/rows/{index}"
            .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getTableRowOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getTableRowOnline.');
        }
        // verify required parameter 'this.tablePath' is not undefined
        if (this.tablePath === undefined) {
            throw new Error('Required parameter "this.tablePath" was undefined when calling getTableRowOnline.');
        }

        // verify required parameter 'this.tablePath' is not null
        if (this.tablePath === null) {
            throw new Error('Required parameter "this.tablePath" was null when calling getTableRowOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling getTableRowOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling getTableRowOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowResponse");
	}
}

/**
 * Request model for GetTables operation.
 * Reads tables from the document node.
 */
export class GetTablesRequest implements RequestInterface {

    public constructor(init?: Partial< GetTablesRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling getTables.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling getTables.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableLinkCollectionResponse");
	}
}

/**
 * Request model for GetTablesOnline operation.
 * Reads tables from the document node.
 */
export class GetTablesOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< GetTablesOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/tables"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling getTablesOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling getTablesOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableLinkCollectionResponse");
	}
}

/**
 * Request model for InsertBookmark operation.
 * Inserts a new bookmark to the document.
 */
export class InsertBookmarkRequest implements RequestInterface {

    public constructor(init?: Partial< InsertBookmarkRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Bookmark to insert.
     */
    public bookmark: importedBookmarkInsert.BookmarkInsert;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertBookmark.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertBookmark.');
        }
        // verify required parameter 'this.bookmark' is not undefined
        if (this.bookmark === undefined) {
            throw new Error('Required parameter "this.bookmark" was undefined when calling insertBookmark.');
        }

        // verify required parameter 'this.bookmark' is not null
        if (this.bookmark === null) {
            throw new Error('Required parameter "this.bookmark" was null when calling insertBookmark.');
        }
        this.bookmark?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.bookmark !== undefined) {
            let _obj = ObjectSerializer.serialize(this.bookmark, this.bookmark.constructor.name === "Object" ? "importedBookmarkInsert.BookmarkInsert" : this.bookmark.constructor.name);
            formParams.push(['Bookmark', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarkResponse");
	}
}

/**
 * Request model for InsertBookmarkOnline operation.
 * Inserts a new bookmark to the document.
 */
export class InsertBookmarkOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertBookmarkOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Bookmark to insert.
     */
    public bookmark: importedBookmarkInsert.BookmarkInsert;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/bookmarks"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertBookmarkOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertBookmarkOnline.');
        }
        // verify required parameter 'this.bookmark' is not undefined
        if (this.bookmark === undefined) {
            throw new Error('Required parameter "this.bookmark" was undefined when calling insertBookmarkOnline.');
        }

        // verify required parameter 'this.bookmark' is not null
        if (this.bookmark === null) {
            throw new Error('Required parameter "this.bookmark" was null when calling insertBookmarkOnline.');
        }
        this.bookmark?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.bookmark !== undefined) {
            let _obj = ObjectSerializer.serialize(this.bookmark, this.bookmark.constructor.name === "Object" ? "importedBookmarkInsert.BookmarkInsert" : this.bookmark.constructor.name);
            formParams.push(['Bookmark', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertBookmarkOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "BookmarkResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertComment operation.
 * Inserts a new comment to the document.
 */
export class InsertCommentRequest implements RequestInterface {

    public constructor(init?: Partial< InsertCommentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Comment data.
     */
    public comment: importedCommentInsert.CommentInsert;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertComment.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertComment.');
        }
        // verify required parameter 'this.comment' is not undefined
        if (this.comment === undefined) {
            throw new Error('Required parameter "this.comment" was undefined when calling insertComment.');
        }

        // verify required parameter 'this.comment' is not null
        if (this.comment === null) {
            throw new Error('Required parameter "this.comment" was null when calling insertComment.');
        }
        this.comment?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.comment !== undefined) {
            let _obj = ObjectSerializer.serialize(this.comment, this.comment.constructor.name === "Object" ? "importedCommentInsert.CommentInsert" : this.comment.constructor.name);
            formParams.push(['Comment', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentResponse");
	}
}

/**
 * Request model for InsertCommentOnline operation.
 * Inserts a new comment to the document.
 */
export class InsertCommentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertCommentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Comment data.
     */
    public comment: importedCommentInsert.CommentInsert;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/comments"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertCommentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertCommentOnline.');
        }
        // verify required parameter 'this.comment' is not undefined
        if (this.comment === undefined) {
            throw new Error('Required parameter "this.comment" was undefined when calling insertCommentOnline.');
        }

        // verify required parameter 'this.comment' is not null
        if (this.comment === null) {
            throw new Error('Required parameter "this.comment" was null when calling insertCommentOnline.');
        }
        this.comment?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.comment !== undefined) {
            let _obj = ObjectSerializer.serialize(this.comment, this.comment.constructor.name === "Object" ? "importedCommentInsert.CommentInsert" : this.comment.constructor.name);
            formParams.push(['Comment', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertCommentOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "CommentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertCustomXmlPart operation.
 * Inserts a new custom xml part to the document.
 */
export class InsertCustomXmlPartRequest implements RequestInterface {

    public constructor(init?: Partial< InsertCustomXmlPartRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Custom xml part.
     */
    public customXmlPart: importedCustomXmlPartInsert.CustomXmlPartInsert;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertCustomXmlPart.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertCustomXmlPart.');
        }
        // verify required parameter 'this.customXmlPart' is not undefined
        if (this.customXmlPart === undefined) {
            throw new Error('Required parameter "this.customXmlPart" was undefined when calling insertCustomXmlPart.');
        }

        // verify required parameter 'this.customXmlPart' is not null
        if (this.customXmlPart === null) {
            throw new Error('Required parameter "this.customXmlPart" was null when calling insertCustomXmlPart.');
        }
        this.customXmlPart?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.customXmlPart !== undefined) {
            let _obj = ObjectSerializer.serialize(this.customXmlPart, this.customXmlPart.constructor.name === "Object" ? "importedCustomXmlPartInsert.CustomXmlPartInsert" : this.customXmlPart.constructor.name);
            formParams.push(['CustomXmlPart', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartResponse");
	}
}

/**
 * Request model for InsertCustomXmlPartOnline operation.
 * Inserts a new custom xml part to the document.
 */
export class InsertCustomXmlPartOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertCustomXmlPartOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Custom xml part.
     */
    public customXmlPart: importedCustomXmlPartInsert.CustomXmlPartInsert;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/customXmlParts"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertCustomXmlPartOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertCustomXmlPartOnline.');
        }
        // verify required parameter 'this.customXmlPart' is not undefined
        if (this.customXmlPart === undefined) {
            throw new Error('Required parameter "this.customXmlPart" was undefined when calling insertCustomXmlPartOnline.');
        }

        // verify required parameter 'this.customXmlPart' is not null
        if (this.customXmlPart === null) {
            throw new Error('Required parameter "this.customXmlPart" was null when calling insertCustomXmlPartOnline.');
        }
        this.customXmlPart?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.customXmlPart !== undefined) {
            let _obj = ObjectSerializer.serialize(this.customXmlPart, this.customXmlPart.constructor.name === "Object" ? "importedCustomXmlPartInsert.CustomXmlPartInsert" : this.customXmlPart.constructor.name);
            formParams.push(['CustomXmlPart', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertCustomXmlPartOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "CustomXmlPartResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertDrawingObject operation.
 * Inserts a new DrawingObject to the document node.
 */
export class InsertDrawingObjectRequest implements RequestInterface {

    public constructor(init?: Partial< InsertDrawingObjectRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Drawing object parameters.
     */
    public drawingObject: importedDrawingObjectInsert.DrawingObjectInsert;

    /**
     * File with image.
     */
    public imageFile: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertDrawingObject.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertDrawingObject.');
        }
        // verify required parameter 'this.drawingObject' is not undefined
        if (this.drawingObject === undefined) {
            throw new Error('Required parameter "this.drawingObject" was undefined when calling insertDrawingObject.');
        }

        // verify required parameter 'this.drawingObject' is not null
        if (this.drawingObject === null) {
            throw new Error('Required parameter "this.drawingObject" was null when calling insertDrawingObject.');
        }
        // verify required parameter 'this.imageFile' is not undefined
        if (this.imageFile === undefined) {
            throw new Error('Required parameter "this.imageFile" was undefined when calling insertDrawingObject.');
        }

        // verify required parameter 'this.imageFile' is not null
        if (this.imageFile === null) {
            throw new Error('Required parameter "this.imageFile" was null when calling insertDrawingObject.');
        }
        this.drawingObject?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.drawingObject !== undefined) {
            let _obj = ObjectSerializer.serialize(this.drawingObject, this.drawingObject.constructor.name === "Object" ? "importedDrawingObjectInsert.DrawingObjectInsert" : this.drawingObject.constructor.name);
            formParams.push(['DrawingObject', JSON.stringify(_obj), 'application/json']);
        }
        if (this.imageFile !== undefined) {
            formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectResponse");
	}
}

/**
 * Request model for InsertDrawingObjectOnline operation.
 * Inserts a new DrawingObject to the document node.
 */
export class InsertDrawingObjectOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertDrawingObjectOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Drawing object parameters.
     */
    public drawingObject: importedDrawingObjectInsert.DrawingObjectInsert;

    /**
     * File with image.
     */
    public imageFile: Readable;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/drawingObjects"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertDrawingObjectOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertDrawingObjectOnline.');
        }
        // verify required parameter 'this.drawingObject' is not undefined
        if (this.drawingObject === undefined) {
            throw new Error('Required parameter "this.drawingObject" was undefined when calling insertDrawingObjectOnline.');
        }

        // verify required parameter 'this.drawingObject' is not null
        if (this.drawingObject === null) {
            throw new Error('Required parameter "this.drawingObject" was null when calling insertDrawingObjectOnline.');
        }
        // verify required parameter 'this.imageFile' is not undefined
        if (this.imageFile === undefined) {
            throw new Error('Required parameter "this.imageFile" was undefined when calling insertDrawingObjectOnline.');
        }

        // verify required parameter 'this.imageFile' is not null
        if (this.imageFile === null) {
            throw new Error('Required parameter "this.imageFile" was null when calling insertDrawingObjectOnline.');
        }
        this.drawingObject?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.drawingObject !== undefined) {
            let _obj = ObjectSerializer.serialize(this.drawingObject, this.drawingObject.constructor.name === "Object" ? "importedDrawingObjectInsert.DrawingObjectInsert" : this.drawingObject.constructor.name);
            formParams.push(['DrawingObject', JSON.stringify(_obj), 'application/json']);
        }
        if (this.imageFile !== undefined) {
            formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertDrawingObjectOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DrawingObjectResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertField operation.
 * Inserts a new field to the document node.
 */
export class InsertFieldRequest implements RequestInterface {

    public constructor(init?: Partial< InsertFieldRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Field data.
     */
    public field: importedFieldInsert.FieldInsert;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertField.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertField.');
        }
        // verify required parameter 'this.field' is not undefined
        if (this.field === undefined) {
            throw new Error('Required parameter "this.field" was undefined when calling insertField.');
        }

        // verify required parameter 'this.field' is not null
        if (this.field === null) {
            throw new Error('Required parameter "this.field" was null when calling insertField.');
        }
        this.field?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.field !== undefined) {
            let _obj = ObjectSerializer.serialize(this.field, this.field.constructor.name === "Object" ? "importedFieldInsert.FieldInsert" : this.field.constructor.name);
            formParams.push(['Field', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldResponse");
	}
}

/**
 * Request model for InsertFieldOnline operation.
 * Inserts a new field to the document node.
 */
export class InsertFieldOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertFieldOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Field data.
     */
    public field: importedFieldInsert.FieldInsert;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/fields"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertFieldOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertFieldOnline.');
        }
        // verify required parameter 'this.field' is not undefined
        if (this.field === undefined) {
            throw new Error('Required parameter "this.field" was undefined when calling insertFieldOnline.');
        }

        // verify required parameter 'this.field' is not null
        if (this.field === null) {
            throw new Error('Required parameter "this.field" was null when calling insertFieldOnline.');
        }
        this.field?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.field !== undefined) {
            let _obj = ObjectSerializer.serialize(this.field, this.field.constructor.name === "Object" ? "importedFieldInsert.FieldInsert" : this.field.constructor.name);
            formParams.push(['Field', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertFieldOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "FieldResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertFootnote operation.
 * Inserts a new footnote to the document node.
 */
export class InsertFootnoteRequest implements RequestInterface {

    public constructor(init?: Partial< InsertFootnoteRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Footnote data.
     */
    public footnoteDto: importedFootnoteInsert.FootnoteInsert;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/footnotes"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertFootnote.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertFootnote.');
        }
        // verify required parameter 'this.footnoteDto' is not undefined
        if (this.footnoteDto === undefined) {
            throw new Error('Required parameter "this.footnoteDto" was undefined when calling insertFootnote.');
        }

        // verify required parameter 'this.footnoteDto' is not null
        if (this.footnoteDto === null) {
            throw new Error('Required parameter "this.footnoteDto" was null when calling insertFootnote.');
        }
        this.footnoteDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.footnoteDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.footnoteDto, this.footnoteDto.constructor.name === "Object" ? "importedFootnoteInsert.FootnoteInsert" : this.footnoteDto.constructor.name);
            formParams.push(['FootnoteDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnoteResponse");
	}
}

/**
 * Request model for InsertFootnoteOnline operation.
 * Inserts a new footnote to the document node.
 */
export class InsertFootnoteOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertFootnoteOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Footnote data.
     */
    public footnoteDto: importedFootnoteInsert.FootnoteInsert;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/footnotes"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertFootnoteOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertFootnoteOnline.');
        }
        // verify required parameter 'this.footnoteDto' is not undefined
        if (this.footnoteDto === undefined) {
            throw new Error('Required parameter "this.footnoteDto" was undefined when calling insertFootnoteOnline.');
        }

        // verify required parameter 'this.footnoteDto' is not null
        if (this.footnoteDto === null) {
            throw new Error('Required parameter "this.footnoteDto" was null when calling insertFootnoteOnline.');
        }
        this.footnoteDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.footnoteDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.footnoteDto, this.footnoteDto.constructor.name === "Object" ? "importedFootnoteInsert.FootnoteInsert" : this.footnoteDto.constructor.name);
            formParams.push(['FootnoteDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertFootnoteOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "FootnoteResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertFormField operation.
 * Inserts a new form field to the document node.
 */
export class InsertFormFieldRequest implements RequestInterface {

    public constructor(init?: Partial< InsertFormFieldRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * From field data.
     */
    public formField: importedFormField.FormField;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

    /**
     * The index of the node. A new form field will be inserted before the node with the specified node Id.
     */
    public insertBeforeNode: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/formfields"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertFormField.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertFormField.');
        }
        // verify required parameter 'this.formField' is not undefined
        if (this.formField === undefined) {
            throw new Error('Required parameter "this.formField" was undefined when calling insertFormField.');
        }

        // verify required parameter 'this.formField' is not null
        if (this.formField === null) {
            throw new Error('Required parameter "this.formField" was null when calling insertFormField.');
        }
        this.formField?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "insertBeforeNode", this.insertBeforeNode, _encryptor);
        if (this.formField !== undefined) {
            let _obj = ObjectSerializer.serialize(this.formField, this.formField.constructor.name === "Object" ? "importedFormField.FormField" : this.formField.constructor.name);
            formParams.push(['FormField', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldResponse");
	}
}

/**
 * Request model for InsertFormFieldOnline operation.
 * Inserts a new form field to the document node.
 */
export class InsertFormFieldOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertFormFieldOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * From field data.
     */
    public formField: importedFormField.FormField;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

    /**
     * The index of the node. A new form field will be inserted before the node with the specified node Id.
     */
    public insertBeforeNode: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/formfields"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertFormFieldOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertFormFieldOnline.');
        }
        // verify required parameter 'this.formField' is not undefined
        if (this.formField === undefined) {
            throw new Error('Required parameter "this.formField" was undefined when calling insertFormFieldOnline.');
        }

        // verify required parameter 'this.formField' is not null
        if (this.formField === null) {
            throw new Error('Required parameter "this.formField" was null when calling insertFormFieldOnline.');
        }
        this.formField?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "insertBeforeNode", this.insertBeforeNode, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.formField !== undefined) {
            let _obj = ObjectSerializer.serialize(this.formField, this.formField.constructor.name === "Object" ? "importedFormField.FormField" : this.formField.constructor.name);
            formParams.push(['FormField', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertFormFieldOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "FormFieldResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertHeaderFooter operation.
 * Inserts a new HeaderFooter object to the document section.
 */
export class InsertHeaderFooterRequest implements RequestInterface {

    public constructor(init?: Partial< InsertHeaderFooterRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the section in the document tree.
     */
    public sectionPath: string;

    /**
     * Type of header/footer.
     */
    public headerFooterType: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{sectionPath}/headersfooters"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertHeaderFooter.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertHeaderFooter.');
        }
        // verify required parameter 'this.sectionPath' is not undefined
        if (this.sectionPath === undefined) {
            throw new Error('Required parameter "this.sectionPath" was undefined when calling insertHeaderFooter.');
        }

        // verify required parameter 'this.sectionPath' is not null
        if (this.sectionPath === null) {
            throw new Error('Required parameter "this.sectionPath" was null when calling insertHeaderFooter.');
        }
        // verify required parameter 'this.headerFooterType' is not undefined
        if (this.headerFooterType === undefined) {
            throw new Error('Required parameter "this.headerFooterType" was undefined when calling insertHeaderFooter.');
        }

        // verify required parameter 'this.headerFooterType' is not null
        if (this.headerFooterType === null) {
            throw new Error('Required parameter "this.headerFooterType" was null when calling insertHeaderFooter.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.headerFooterType !== undefined) {
            formParams.push(['HeaderFooterType', this.headerFooterType, 'text/plain']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "HeaderFooterResponse");
	}
}

/**
 * Request model for InsertHeaderFooterOnline operation.
 * Inserts a new HeaderFooter object to the document section.
 */
export class InsertHeaderFooterOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertHeaderFooterOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the section in the document tree.
     */
    public sectionPath: string;

    /**
     * Type of header/footer.
     */
    public headerFooterType: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{sectionPath}/headersfooters"
            .replace("/{" + "sectionPath" + "}", (this.sectionPath !== null && this.sectionPath !== undefined) ? "/" + String(this.sectionPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertHeaderFooterOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertHeaderFooterOnline.');
        }
        // verify required parameter 'this.sectionPath' is not undefined
        if (this.sectionPath === undefined) {
            throw new Error('Required parameter "this.sectionPath" was undefined when calling insertHeaderFooterOnline.');
        }

        // verify required parameter 'this.sectionPath' is not null
        if (this.sectionPath === null) {
            throw new Error('Required parameter "this.sectionPath" was null when calling insertHeaderFooterOnline.');
        }
        // verify required parameter 'this.headerFooterType' is not undefined
        if (this.headerFooterType === undefined) {
            throw new Error('Required parameter "this.headerFooterType" was undefined when calling insertHeaderFooterOnline.');
        }

        // verify required parameter 'this.headerFooterType' is not null
        if (this.headerFooterType === null) {
            throw new Error('Required parameter "this.headerFooterType" was null when calling insertHeaderFooterOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.headerFooterType !== undefined) {
            formParams.push(['HeaderFooterType', this.headerFooterType, 'text/plain']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertHeaderFooterOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "HeaderFooterResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertList operation.
 * Inserts a new list to the document.
 */
export class InsertListRequest implements RequestInterface {

    public constructor(init?: Partial< InsertListRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * List object.
     */
    public listInsert: importedListInsert.ListInsert;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/lists"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertList.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertList.');
        }
        // verify required parameter 'this.listInsert' is not undefined
        if (this.listInsert === undefined) {
            throw new Error('Required parameter "this.listInsert" was undefined when calling insertList.');
        }

        // verify required parameter 'this.listInsert' is not null
        if (this.listInsert === null) {
            throw new Error('Required parameter "this.listInsert" was null when calling insertList.');
        }
        this.listInsert?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.listInsert !== undefined) {
            let _obj = ObjectSerializer.serialize(this.listInsert, this.listInsert.constructor.name === "Object" ? "importedListInsert.ListInsert" : this.listInsert.constructor.name);
            formParams.push(['ListInsert', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListResponse");
	}
}

/**
 * Request model for InsertListOnline operation.
 * Inserts a new list to the document.
 */
export class InsertListOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertListOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * List object.
     */
    public listInsert: importedListInsert.ListInsert;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/lists"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertListOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertListOnline.');
        }
        // verify required parameter 'this.listInsert' is not undefined
        if (this.listInsert === undefined) {
            throw new Error('Required parameter "this.listInsert" was undefined when calling insertListOnline.');
        }

        // verify required parameter 'this.listInsert' is not null
        if (this.listInsert === null) {
            throw new Error('Required parameter "this.listInsert" was null when calling insertListOnline.');
        }
        this.listInsert?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.listInsert !== undefined) {
            let _obj = ObjectSerializer.serialize(this.listInsert, this.listInsert.constructor.name === "Object" ? "importedListInsert.ListInsert" : this.listInsert.constructor.name);
            formParams.push(['ListInsert', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertListOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "ListResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertOrUpdateParagraphTabStop operation.
 * Inserts a new or updates an existing paragraph tab stop in the document node.
 */
export class InsertOrUpdateParagraphTabStopRequest implements RequestInterface {

    public constructor(init?: Partial< InsertOrUpdateParagraphTabStopRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * TabStopInsert dto.
     */
    public tabStopInsertDto: importedTabStopInsert.TabStopInsert;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/tabstops"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertOrUpdateParagraphTabStop.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertOrUpdateParagraphTabStop.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling insertOrUpdateParagraphTabStop.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling insertOrUpdateParagraphTabStop.');
        }
        // verify required parameter 'this.tabStopInsertDto' is not undefined
        if (this.tabStopInsertDto === undefined) {
            throw new Error('Required parameter "this.tabStopInsertDto" was undefined when calling insertOrUpdateParagraphTabStop.');
        }

        // verify required parameter 'this.tabStopInsertDto' is not null
        if (this.tabStopInsertDto === null) {
            throw new Error('Required parameter "this.tabStopInsertDto" was null when calling insertOrUpdateParagraphTabStop.');
        }
        this.tabStopInsertDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.tabStopInsertDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.tabStopInsertDto, this.tabStopInsertDto.constructor.name === "Object" ? "importedTabStopInsert.TabStopInsert" : this.tabStopInsertDto.constructor.name);
            formParams.push(['TabStopInsertDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TabStopsResponse");
	}
}

/**
 * Request model for InsertOrUpdateParagraphTabStopOnline operation.
 * Inserts a new or updates an existing paragraph tab stop in the document node.
 */
export class InsertOrUpdateParagraphTabStopOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertOrUpdateParagraphTabStopOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * TabStopInsert dto.
     */
    public tabStopInsertDto: importedTabStopInsert.TabStopInsert;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/paragraphs/{index}/tabstops"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertOrUpdateParagraphTabStopOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertOrUpdateParagraphTabStopOnline.');
        }
        // verify required parameter 'this.tabStopInsertDto' is not undefined
        if (this.tabStopInsertDto === undefined) {
            throw new Error('Required parameter "this.tabStopInsertDto" was undefined when calling insertOrUpdateParagraphTabStopOnline.');
        }

        // verify required parameter 'this.tabStopInsertDto' is not null
        if (this.tabStopInsertDto === null) {
            throw new Error('Required parameter "this.tabStopInsertDto" was null when calling insertOrUpdateParagraphTabStopOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling insertOrUpdateParagraphTabStopOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling insertOrUpdateParagraphTabStopOnline.');
        }
        this.tabStopInsertDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.tabStopInsertDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.tabStopInsertDto, this.tabStopInsertDto.constructor.name === "Object" ? "importedTabStopInsert.TabStopInsert" : this.tabStopInsertDto.constructor.name);
            formParams.push(['TabStopInsertDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertOrUpdateParagraphTabStopOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "TabStopsResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertPageNumbers operation.
 * Inserts page numbers to the document.
 */
export class InsertPageNumbersRequest implements RequestInterface {

    public constructor(init?: Partial< InsertPageNumbersRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Page number dto.
     */
    public pageNumber: importedPageNumber.PageNumber;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/PageNumbers"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertPageNumbers.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertPageNumbers.');
        }
        // verify required parameter 'this.pageNumber' is not undefined
        if (this.pageNumber === undefined) {
            throw new Error('Required parameter "this.pageNumber" was undefined when calling insertPageNumbers.');
        }

        // verify required parameter 'this.pageNumber' is not null
        if (this.pageNumber === null) {
            throw new Error('Required parameter "this.pageNumber" was null when calling insertPageNumbers.');
        }
        this.pageNumber?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.pageNumber !== undefined) {
            let _obj = ObjectSerializer.serialize(this.pageNumber, this.pageNumber.constructor.name === "Object" ? "importedPageNumber.PageNumber" : this.pageNumber.constructor.name);
            formParams.push(['PageNumber', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for InsertPageNumbersOnline operation.
 * Inserts page numbers to the document.
 */
export class InsertPageNumbersOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertPageNumbersOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Page number dto.
     */
    public pageNumber: importedPageNumber.PageNumber;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/PageNumbers"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertPageNumbersOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertPageNumbersOnline.');
        }
        // verify required parameter 'this.pageNumber' is not undefined
        if (this.pageNumber === undefined) {
            throw new Error('Required parameter "this.pageNumber" was undefined when calling insertPageNumbersOnline.');
        }

        // verify required parameter 'this.pageNumber' is not null
        if (this.pageNumber === null) {
            throw new Error('Required parameter "this.pageNumber" was null when calling insertPageNumbersOnline.');
        }
        this.pageNumber?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.pageNumber !== undefined) {
            let _obj = ObjectSerializer.serialize(this.pageNumber, this.pageNumber.constructor.name === "Object" ? "importedPageNumber.PageNumber" : this.pageNumber.constructor.name);
            formParams.push(['PageNumber', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertPageNumbersOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertParagraph operation.
 * Inserts a new paragraph to the document node.
 */
export class InsertParagraphRequest implements RequestInterface {

    public constructor(init?: Partial< InsertParagraphRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Paragraph data.
     */
    public paragraph: importedParagraphInsert.ParagraphInsert;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertParagraph.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertParagraph.');
        }
        // verify required parameter 'this.paragraph' is not undefined
        if (this.paragraph === undefined) {
            throw new Error('Required parameter "this.paragraph" was undefined when calling insertParagraph.');
        }

        // verify required parameter 'this.paragraph' is not null
        if (this.paragraph === null) {
            throw new Error('Required parameter "this.paragraph" was null when calling insertParagraph.');
        }
        this.paragraph?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.paragraph !== undefined) {
            let _obj = ObjectSerializer.serialize(this.paragraph, this.paragraph.constructor.name === "Object" ? "importedParagraphInsert.ParagraphInsert" : this.paragraph.constructor.name);
            formParams.push(['Paragraph', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphResponse");
	}
}

/**
 * Request model for InsertParagraphOnline operation.
 * Inserts a new paragraph to the document node.
 */
export class InsertParagraphOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertParagraphOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Paragraph data.
     */
    public paragraph: importedParagraphInsert.ParagraphInsert;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/paragraphs"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertParagraphOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertParagraphOnline.');
        }
        // verify required parameter 'this.paragraph' is not undefined
        if (this.paragraph === undefined) {
            throw new Error('Required parameter "this.paragraph" was undefined when calling insertParagraphOnline.');
        }

        // verify required parameter 'this.paragraph' is not null
        if (this.paragraph === null) {
            throw new Error('Required parameter "this.paragraph" was null when calling insertParagraphOnline.');
        }
        this.paragraph?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.paragraph !== undefined) {
            let _obj = ObjectSerializer.serialize(this.paragraph, this.paragraph.constructor.name === "Object" ? "importedParagraphInsert.ParagraphInsert" : this.paragraph.constructor.name);
            formParams.push(['Paragraph', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertParagraphOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "ParagraphResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertRun operation.
 * Inserts a new Run object to the paragraph.
 */
export class InsertRunRequest implements RequestInterface {

    public constructor(init?: Partial< InsertRunRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Run data.
     */
    public run: importedRunInsert.RunInsert;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertRun.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertRun.');
        }
        // verify required parameter 'this.run' is not undefined
        if (this.run === undefined) {
            throw new Error('Required parameter "this.run" was undefined when calling insertRun.');
        }

        // verify required parameter 'this.run' is not null
        if (this.run === null) {
            throw new Error('Required parameter "this.run" was null when calling insertRun.');
        }
        this.run?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.run !== undefined) {
            let _obj = ObjectSerializer.serialize(this.run, this.run.constructor.name === "Object" ? "importedRunInsert.RunInsert" : this.run.constructor.name);
            formParams.push(['Run', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunResponse");
	}
}

/**
 * Request model for InsertRunOnline operation.
 * Inserts a new Run object to the paragraph.
 */
export class InsertRunOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertRunOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Run data.
     */
    public run: importedRunInsert.RunInsert;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{paragraphPath}/runs"
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertRunOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertRunOnline.');
        }
        // verify required parameter 'this.run' is not undefined
        if (this.run === undefined) {
            throw new Error('Required parameter "this.run" was undefined when calling insertRunOnline.');
        }

        // verify required parameter 'this.run' is not null
        if (this.run === null) {
            throw new Error('Required parameter "this.run" was null when calling insertRunOnline.');
        }
        this.run?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.run !== undefined) {
            let _obj = ObjectSerializer.serialize(this.run, this.run.constructor.name === "Object" ? "importedRunInsert.RunInsert" : this.run.constructor.name);
            formParams.push(['Run', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertRunOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "RunResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertSection operation.
 * Inserts a section to the document.
 */
export class InsertSectionRequest implements RequestInterface {

    public constructor(init?: Partial< InsertSectionRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index to insert into.
     */
    public sectionIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertSection.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertSection.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling insertSection.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling insertSection.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for InsertSectionOnline operation.
 * Inserts a section to the document.
 */
export class InsertSectionOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertSectionOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index to insert into.
     */
    public sectionIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/sections/{sectionIndex}"
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertSectionOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertSectionOnline.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling insertSectionOnline.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling insertSectionOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for InsertStructuredDocumentTag operation.
 * Inserts a new StructuredDocumentTag (SDT) to the document node.
 */
export class InsertStructuredDocumentTagRequest implements RequestInterface {

    public constructor(init?: Partial< InsertStructuredDocumentTagRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Structured document tag parameters.
     */
    public structuredDocumentTag: importedStructuredDocumentTagInsert.StructuredDocumentTagInsert;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/sdt"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertStructuredDocumentTag.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertStructuredDocumentTag.');
        }
        // verify required parameter 'this.structuredDocumentTag' is not undefined
        if (this.structuredDocumentTag === undefined) {
            throw new Error('Required parameter "this.structuredDocumentTag" was undefined when calling insertStructuredDocumentTag.');
        }

        // verify required parameter 'this.structuredDocumentTag' is not null
        if (this.structuredDocumentTag === null) {
            throw new Error('Required parameter "this.structuredDocumentTag" was null when calling insertStructuredDocumentTag.');
        }
        this.structuredDocumentTag?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.structuredDocumentTag !== undefined) {
            let _obj = ObjectSerializer.serialize(this.structuredDocumentTag, this.structuredDocumentTag.constructor.name === "Object" ? "importedStructuredDocumentTagInsert.StructuredDocumentTagInsert" : this.structuredDocumentTag.constructor.name);
            formParams.push(['StructuredDocumentTag', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagResponse");
	}
}

/**
 * Request model for InsertStructuredDocumentTagOnline operation.
 * Inserts a new StructuredDocumentTag (SDT) to the document node.
 */
export class InsertStructuredDocumentTagOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertStructuredDocumentTagOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Structured document tag parameters.
     */
    public structuredDocumentTag: importedStructuredDocumentTagInsert.StructuredDocumentTagInsert;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/sdt"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertStructuredDocumentTagOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertStructuredDocumentTagOnline.');
        }
        // verify required parameter 'this.structuredDocumentTag' is not undefined
        if (this.structuredDocumentTag === undefined) {
            throw new Error('Required parameter "this.structuredDocumentTag" was undefined when calling insertStructuredDocumentTagOnline.');
        }

        // verify required parameter 'this.structuredDocumentTag' is not null
        if (this.structuredDocumentTag === null) {
            throw new Error('Required parameter "this.structuredDocumentTag" was null when calling insertStructuredDocumentTagOnline.');
        }
        this.structuredDocumentTag?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.structuredDocumentTag !== undefined) {
            let _obj = ObjectSerializer.serialize(this.structuredDocumentTag, this.structuredDocumentTag.constructor.name === "Object" ? "importedStructuredDocumentTagInsert.StructuredDocumentTagInsert" : this.structuredDocumentTag.constructor.name);
            formParams.push(['StructuredDocumentTag', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertStructuredDocumentTagOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "StructuredDocumentTagResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertStyle operation.
 * Inserts a new style to the document.
 */
export class InsertStyleRequest implements RequestInterface {

    public constructor(init?: Partial< InsertStyleRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Style to insert.
     */
    public styleInsert: importedStyleInsert.StyleInsert;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles/insert"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertStyle.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertStyle.');
        }
        // verify required parameter 'this.styleInsert' is not undefined
        if (this.styleInsert === undefined) {
            throw new Error('Required parameter "this.styleInsert" was undefined when calling insertStyle.');
        }

        // verify required parameter 'this.styleInsert' is not null
        if (this.styleInsert === null) {
            throw new Error('Required parameter "this.styleInsert" was null when calling insertStyle.');
        }
        this.styleInsert?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.styleInsert !== undefined) {
            let _obj = ObjectSerializer.serialize(this.styleInsert, this.styleInsert.constructor.name === "Object" ? "importedStyleInsert.StyleInsert" : this.styleInsert.constructor.name);
            formParams.push(['StyleInsert', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
	}
}

/**
 * Request model for InsertStyleOnline operation.
 * Inserts a new style to the document.
 */
export class InsertStyleOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertStyleOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Style to insert.
     */
    public styleInsert: importedStyleInsert.StyleInsert;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/styles/insert"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertStyleOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertStyleOnline.');
        }
        // verify required parameter 'this.styleInsert' is not undefined
        if (this.styleInsert === undefined) {
            throw new Error('Required parameter "this.styleInsert" was undefined when calling insertStyleOnline.');
        }

        // verify required parameter 'this.styleInsert' is not null
        if (this.styleInsert === null) {
            throw new Error('Required parameter "this.styleInsert" was null when calling insertStyleOnline.');
        }
        this.styleInsert?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.styleInsert !== undefined) {
            let _obj = ObjectSerializer.serialize(this.styleInsert, this.styleInsert.constructor.name === "Object" ? "importedStyleInsert.StyleInsert" : this.styleInsert.constructor.name);
            formParams.push(['StyleInsert', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertStyleOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "StyleResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertTable operation.
 * Inserts a new table to the document node.
 */
export class InsertTableRequest implements RequestInterface {

    public constructor(init?: Partial< InsertTableRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Table parameters.
     */
    public table: importedTableInsert.TableInsert;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertTable.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertTable.');
        }
        // verify required parameter 'this.table' is not undefined
        if (this.table === undefined) {
            throw new Error('Required parameter "this.table" was undefined when calling insertTable.');
        }

        // verify required parameter 'this.table' is not null
        if (this.table === null) {
            throw new Error('Required parameter "this.table" was null when calling insertTable.');
        }
        this.table?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.table !== undefined) {
            let _obj = ObjectSerializer.serialize(this.table, this.table.constructor.name === "Object" ? "importedTableInsert.TableInsert" : this.table.constructor.name);
            formParams.push(['Table', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableResponse");
	}
}

/**
 * Request model for InsertTableCell operation.
 * Inserts a new cell to the table row.
 */
export class InsertTableCellRequest implements RequestInterface {

    public constructor(init?: Partial< InsertTableCellRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Table cell parameters.
     */
    public cell: importedTableCellInsert.TableCellInsert;

    /**
     * The path to the table row in the document tree.
     */
    public tableRowPath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tableRowPath}/cells"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertTableCell.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertTableCell.');
        }
        // verify required parameter 'this.cell' is not undefined
        if (this.cell === undefined) {
            throw new Error('Required parameter "this.cell" was undefined when calling insertTableCell.');
        }

        // verify required parameter 'this.cell' is not null
        if (this.cell === null) {
            throw new Error('Required parameter "this.cell" was null when calling insertTableCell.');
        }
        this.cell?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.cell !== undefined) {
            let _obj = ObjectSerializer.serialize(this.cell, this.cell.constructor.name === "Object" ? "importedTableCellInsert.TableCellInsert" : this.cell.constructor.name);
            formParams.push(['Cell', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellResponse");
	}
}

/**
 * Request model for InsertTableCellOnline operation.
 * Inserts a new cell to the table row.
 */
export class InsertTableCellOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertTableCellOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Table cell parameters.
     */
    public cell: importedTableCellInsert.TableCellInsert;

    /**
     * The path to the table row in the document tree.
     */
    public tableRowPath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{tableRowPath}/cells"
            .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertTableCellOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertTableCellOnline.');
        }
        // verify required parameter 'this.cell' is not undefined
        if (this.cell === undefined) {
            throw new Error('Required parameter "this.cell" was undefined when calling insertTableCellOnline.');
        }

        // verify required parameter 'this.cell' is not null
        if (this.cell === null) {
            throw new Error('Required parameter "this.cell" was null when calling insertTableCellOnline.');
        }
        this.cell?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.cell !== undefined) {
            let _obj = ObjectSerializer.serialize(this.cell, this.cell.constructor.name === "Object" ? "importedTableCellInsert.TableCellInsert" : this.cell.constructor.name);
            formParams.push(['Cell', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertTableCellOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "TableCellResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertTableOnline operation.
 * Inserts a new table to the document node.
 */
export class InsertTableOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertTableOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Table parameters.
     */
    public table: importedTableInsert.TableInsert;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/tables"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertTableOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertTableOnline.');
        }
        // verify required parameter 'this.table' is not undefined
        if (this.table === undefined) {
            throw new Error('Required parameter "this.table" was undefined when calling insertTableOnline.');
        }

        // verify required parameter 'this.table' is not null
        if (this.table === null) {
            throw new Error('Required parameter "this.table" was null when calling insertTableOnline.');
        }
        this.table?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.table !== undefined) {
            let _obj = ObjectSerializer.serialize(this.table, this.table.constructor.name === "Object" ? "importedTableInsert.TableInsert" : this.table.constructor.name);
            formParams.push(['Table', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertTableOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "TableResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertTableRow operation.
 * Inserts a new row to the table.
 */
export class InsertTableRowRequest implements RequestInterface {

    public constructor(init?: Partial< InsertTableRowRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Table row parameters.
     */
    public row: importedTableRowInsert.TableRowInsert;

    /**
     * The path to the table in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/rows"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertTableRow.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertTableRow.');
        }
        // verify required parameter 'this.row' is not undefined
        if (this.row === undefined) {
            throw new Error('Required parameter "this.row" was undefined when calling insertTableRow.');
        }

        // verify required parameter 'this.row' is not null
        if (this.row === null) {
            throw new Error('Required parameter "this.row" was null when calling insertTableRow.');
        }
        this.row?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.row !== undefined) {
            let _obj = ObjectSerializer.serialize(this.row, this.row.constructor.name === "Object" ? "importedTableRowInsert.TableRowInsert" : this.row.constructor.name);
            formParams.push(['Row', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowResponse");
	}
}

/**
 * Request model for InsertTableRowOnline operation.
 * Inserts a new row to the table.
 */
export class InsertTableRowOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertTableRowOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Table row parameters.
     */
    public row: importedTableRowInsert.TableRowInsert;

    /**
     * The path to the table in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/{nodePath}/rows"
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertTableRowOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertTableRowOnline.');
        }
        // verify required parameter 'this.row' is not undefined
        if (this.row === undefined) {
            throw new Error('Required parameter "this.row" was undefined when calling insertTableRowOnline.');
        }

        // verify required parameter 'this.row' is not null
        if (this.row === null) {
            throw new Error('Required parameter "this.row" was null when calling insertTableRowOnline.');
        }
        this.row?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.row !== undefined) {
            let _obj = ObjectSerializer.serialize(this.row, this.row.constructor.name === "Object" ? "importedTableRowInsert.TableRowInsert" : this.row.constructor.name);
            formParams.push(['Row', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertTableRowOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "TableRowResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertWatermark operation.
 * Insert a watermark to the document.
 */
export class InsertWatermarkRequest implements RequestInterface {

    public constructor(init?: Partial< InsertWatermarkRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The watermark data.
     */
    public watermarkData: importedWatermarkDataBase.WatermarkDataBase;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/watermarks/insert"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertWatermark.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertWatermark.');
        }
        // verify required parameter 'this.watermarkData' is not undefined
        if (this.watermarkData === undefined) {
            throw new Error('Required parameter "this.watermarkData" was undefined when calling insertWatermark.');
        }

        // verify required parameter 'this.watermarkData' is not null
        if (this.watermarkData === null) {
            throw new Error('Required parameter "this.watermarkData" was null when calling insertWatermark.');
        }
        this.watermarkData?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.watermarkData !== undefined) {
            let _obj = ObjectSerializer.serialize(this.watermarkData, this.watermarkData.constructor.name === "Object" ? "importedWatermarkDataBase.WatermarkDataBase" : this.watermarkData.constructor.name);
            formParams.push(['WatermarkData', JSON.stringify(_obj), 'application/json']);
            this.watermarkData.collectFilesContent(filesContent);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for InsertWatermarkImage operation.
 * Inserts a new watermark image to the document.
 */
export class InsertWatermarkImageRequest implements RequestInterface {

    public constructor(init?: Partial< InsertWatermarkImageRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * File with image.
     */
    public imageFile: Readable;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

    /**
     * The rotation angle of the watermark.
     */
    public rotationAngle: number;

    /**
     * The filename of the image. If the parameter value is missing  the image data is expected in the request content.
     */
    public image: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/watermarks/images"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertWatermarkImage.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertWatermarkImage.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "rotationAngle", this.rotationAngle, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "image", this.image, _encryptor);
        if (this.imageFile !== undefined) {
            formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for InsertWatermarkImageOnline operation.
 * Inserts a new watermark image to the document.
 */
export class InsertWatermarkImageOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertWatermarkImageOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * File with image.
     */
    public imageFile: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

    /**
     * The rotation angle of the watermark.
     */
    public rotationAngle: number;

    /**
     * The filename of the image. If the parameter value is missing  the image data is expected in the request content.
     */
    public image: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/watermarks/images"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertWatermarkImageOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertWatermarkImageOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "rotationAngle", this.rotationAngle, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "image", this.image, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.imageFile !== undefined) {
            formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertWatermarkImageOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertWatermarkOnline operation.
 * Insert a watermark to the document.
 */
export class InsertWatermarkOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertWatermarkOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The watermark data.
     */
    public watermarkData: importedWatermarkDataBase.WatermarkDataBase;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/watermarks/insert"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertWatermarkOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertWatermarkOnline.');
        }
        // verify required parameter 'this.watermarkData' is not undefined
        if (this.watermarkData === undefined) {
            throw new Error('Required parameter "this.watermarkData" was undefined when calling insertWatermarkOnline.');
        }

        // verify required parameter 'this.watermarkData' is not null
        if (this.watermarkData === null) {
            throw new Error('Required parameter "this.watermarkData" was null when calling insertWatermarkOnline.');
        }
        this.watermarkData?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.watermarkData !== undefined) {
            let _obj = ObjectSerializer.serialize(this.watermarkData, this.watermarkData.constructor.name === "Object" ? "importedWatermarkDataBase.WatermarkDataBase" : this.watermarkData.constructor.name);
            formParams.push(['WatermarkData', JSON.stringify(_obj), 'application/json']);
            this.watermarkData.collectFilesContent(filesContent);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertWatermarkOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for InsertWatermarkText operation.
 * Inserts a new watermark text to the document.
 */
export class InsertWatermarkTextRequest implements RequestInterface {

    public constructor(init?: Partial< InsertWatermarkTextRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The watermark data.
     */
    public watermarkText: importedWatermarkText.WatermarkText;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/watermarks/texts"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling insertWatermarkText.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling insertWatermarkText.');
        }
        // verify required parameter 'this.watermarkText' is not undefined
        if (this.watermarkText === undefined) {
            throw new Error('Required parameter "this.watermarkText" was undefined when calling insertWatermarkText.');
        }

        // verify required parameter 'this.watermarkText' is not null
        if (this.watermarkText === null) {
            throw new Error('Required parameter "this.watermarkText" was null when calling insertWatermarkText.');
        }
        this.watermarkText?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.watermarkText !== undefined) {
            let _obj = ObjectSerializer.serialize(this.watermarkText, this.watermarkText.constructor.name === "Object" ? "importedWatermarkText.WatermarkText" : this.watermarkText.constructor.name);
            formParams.push(['WatermarkText', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for InsertWatermarkTextOnline operation.
 * Inserts a new watermark text to the document.
 */
export class InsertWatermarkTextOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< InsertWatermarkTextOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The watermark data.
     */
    public watermarkText: importedWatermarkText.WatermarkText;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/watermarks/texts"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling insertWatermarkTextOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling insertWatermarkTextOnline.');
        }
        // verify required parameter 'this.watermarkText' is not undefined
        if (this.watermarkText === undefined) {
            throw new Error('Required parameter "this.watermarkText" was undefined when calling insertWatermarkTextOnline.');
        }

        // verify required parameter 'this.watermarkText' is not null
        if (this.watermarkText === null) {
            throw new Error('Required parameter "this.watermarkText" was null when calling insertWatermarkTextOnline.');
        }
        this.watermarkText?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.watermarkText !== undefined) {
            let _obj = ObjectSerializer.serialize(this.watermarkText, this.watermarkText.constructor.name === "Object" ? "importedWatermarkText.WatermarkText" : this.watermarkText.constructor.name);
            formParams.push(['WatermarkText', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new InsertWatermarkTextOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for LinkHeaderFootersToPrevious operation.
 * Links headers / footers of the section to the previous one.
 */
export class LinkHeaderFootersToPreviousRequest implements RequestInterface {

    public constructor(init?: Partial< LinkHeaderFootersToPreviousRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

    /**
     * Linking mode.
     */
    public mode: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}/link"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling linkHeaderFootersToPrevious.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling linkHeaderFootersToPrevious.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling linkHeaderFootersToPrevious.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling linkHeaderFootersToPrevious.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "mode", this.mode, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for LoadWebDocument operation.
 * Downloads a document from the Web using URL and saves it to cloud storage in the specified format.
 */
export class LoadWebDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< LoadWebDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The properties of data downloading.
     */
    public data: importedLoadWebDocumentData.LoadWebDocumentData;

    /**
     * Original document storage.
     */
    public storage: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/loadWebDocument"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.data' is not undefined
        if (this.data === undefined) {
            throw new Error('Required parameter "this.data" was undefined when calling loadWebDocument.');
        }

        // verify required parameter 'this.data' is not null
        if (this.data === null) {
            throw new Error('Required parameter "this.data" was null when calling loadWebDocument.');
        }
        this.data?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        if (this.data !== undefined) {
            let _obj = ObjectSerializer.serialize(this.data, this.data.constructor.name === "Object" ? "importedLoadWebDocumentData.LoadWebDocumentData" : this.data.constructor.name);
            formParams.push(['Data', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SaveResponse");
	}
}

/**
 * Request model for LoadWebDocumentOnline operation.
 * Downloads a document from the Web using URL and saves it to cloud storage in the specified format.
 */
export class LoadWebDocumentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< LoadWebDocumentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The properties of data downloading.
     */
    public data: importedLoadWebDocumentData.LoadWebDocumentData;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        const localVarPath = configuration.getApiBaseUrl() + "/words/online/put/loadWebDocument"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.data' is not undefined
        if (this.data === undefined) {
            throw new Error('Required parameter "this.data" was undefined when calling loadWebDocumentOnline.');
        }

        // verify required parameter 'this.data' is not null
        if (this.data === null) {
            throw new Error('Required parameter "this.data" was null when calling loadWebDocumentOnline.');
        }
        this.data?.validate();

        if (this.data !== undefined) {
            let _obj = ObjectSerializer.serialize(this.data, this.data.constructor.name === "Object" ? "importedLoadWebDocumentData.LoadWebDocumentData" : this.data.constructor.name);
            formParams.push(['Data', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new LoadWebDocumentOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "SaveResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for MergeWithNext operation.
 * Merge the section with the next one.
 */
export class MergeWithNextRequest implements RequestInterface {

    public constructor(init?: Partial< MergeWithNextRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/merge/sections/{sectionIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling mergeWithNext.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling mergeWithNext.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling mergeWithNext.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling mergeWithNext.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for MergeWithNextOnline operation.
 * Merge the section with the next one.
 */
export class MergeWithNextOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< MergeWithNextOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/merge/sections/{sectionIndex}"
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling mergeWithNextOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling mergeWithNextOnline.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling mergeWithNextOnline.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling mergeWithNextOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for MoveFile operation.
 * Move file.
 */
export class MoveFileRequest implements RequestInterface {

    public constructor(init?: Partial< MoveFileRequest >) {
        Object.assign(this, init);
    }

    /**
     * Destination file path e.g. '/dest.ext'.
     */
    public destPath: string;

    /**
     * Source file's path e.g. '/Folder 1/file.ext' or '/Bucket/Folder 1/file.ext'.
     */
    public srcPath: string;

    /**
     * Source storage name.
     */
    public srcStorageName: string;

    /**
     * Destination storage name.
     */
    public destStorageName: string;

    /**
     * File version ID to move.
     */
    public versionId: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/storage/file/move/{srcPath}"
            .replace("/{" + "srcPath" + "}", (this.srcPath !== null && this.srcPath !== undefined) ? "/" + String(this.srcPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.destPath' is not undefined
        if (this.destPath === undefined) {
            throw new Error('Required parameter "this.destPath" was undefined when calling moveFile.');
        }

        // verify required parameter 'this.destPath' is not null
        if (this.destPath === null) {
            throw new Error('Required parameter "this.destPath" was null when calling moveFile.');
        }
        // verify required parameter 'this.srcPath' is not undefined
        if (this.srcPath === undefined) {
            throw new Error('Required parameter "this.srcPath" was undefined when calling moveFile.');
        }

        // verify required parameter 'this.srcPath' is not null
        if (this.srcPath === null) {
            throw new Error('Required parameter "this.srcPath" was null when calling moveFile.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "versionId", this.versionId, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for MoveFolder operation.
 * Move folder.
 */
export class MoveFolderRequest implements RequestInterface {

    public constructor(init?: Partial< MoveFolderRequest >) {
        Object.assign(this, init);
    }

    /**
     * Destination folder path to move to e.g '/dst'.
     */
    public destPath: string;

    /**
     * Source folder path e.g. /Folder1.
     */
    public srcPath: string;

    /**
     * Source storage name.
     */
    public srcStorageName: string;

    /**
     * Destination storage name.
     */
    public destStorageName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/storage/folder/move/{srcPath}"
            .replace("/{" + "srcPath" + "}", (this.srcPath !== null && this.srcPath !== undefined) ? "/" + String(this.srcPath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.destPath' is not undefined
        if (this.destPath === undefined) {
            throw new Error('Required parameter "this.destPath" was undefined when calling moveFolder.');
        }

        // verify required parameter 'this.destPath' is not null
        if (this.destPath === null) {
            throw new Error('Required parameter "this.destPath" was null when calling moveFolder.');
        }
        // verify required parameter 'this.srcPath' is not undefined
        if (this.srcPath === undefined) {
            throw new Error('Required parameter "this.srcPath" was undefined when calling moveFolder.');
        }

        // verify required parameter 'this.srcPath' is not null
        if (this.srcPath === null) {
            throw new Error('Required parameter "this.srcPath" was null when calling moveFolder.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destPath", this.destPath, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "srcStorageName", this.srcStorageName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destStorageName", this.destStorageName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for OptimizeDocument operation.
 * Applies document content optimization options, specific to a particular versions of Microsoft Word.
 */
export class OptimizeDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< OptimizeDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The document optimization options.
     */
    public options: importedOptimizationOptions.OptimizationOptions;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/compatibility/optimize"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling optimizeDocument.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling optimizeDocument.');
        }
        // verify required parameter 'this.options' is not undefined
        if (this.options === undefined) {
            throw new Error('Required parameter "this.options" was undefined when calling optimizeDocument.');
        }

        // verify required parameter 'this.options' is not null
        if (this.options === null) {
            throw new Error('Required parameter "this.options" was null when calling optimizeDocument.');
        }
        this.options?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.options !== undefined) {
            let _obj = ObjectSerializer.serialize(this.options, this.options.constructor.name === "Object" ? "importedOptimizationOptions.OptimizationOptions" : this.options.constructor.name);
            formParams.push(['Options', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for OptimizeDocumentOnline operation.
 * Applies document content optimization options, specific to a particular versions of Microsoft Word.
 */
export class OptimizeDocumentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< OptimizeDocumentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The document optimization options.
     */
    public options: importedOptimizationOptions.OptimizationOptions;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/compatibility/optimize"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling optimizeDocumentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling optimizeDocumentOnline.');
        }
        // verify required parameter 'this.options' is not undefined
        if (this.options === undefined) {
            throw new Error('Required parameter "this.options" was undefined when calling optimizeDocumentOnline.');
        }

        // verify required parameter 'this.options' is not null
        if (this.options === null) {
            throw new Error('Required parameter "this.options" was null when calling optimizeDocumentOnline.');
        }
        this.options?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.options !== undefined) {
            let _obj = ObjectSerializer.serialize(this.options, this.options.constructor.name === "Object" ? "importedOptimizationOptions.OptimizationOptions" : this.options.constructor.name);
            formParams.push(['Options', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return parseFilesCollection(_response, _headers);
	}
}

/**
 * Request model for ProtectDocument operation.
 * Changes the document protection. The previous protection will be overwritten if it exist.
 */
export class ProtectDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< ProtectDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Use ProtectionRequestV2 model to provide protection options.
     */
    public protectionRequest: importedProtectionRequestBase.ProtectionRequestBase;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/protection"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling protectDocument.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling protectDocument.');
        }
        // verify required parameter 'this.protectionRequest' is not undefined
        if (this.protectionRequest === undefined) {
            throw new Error('Required parameter "this.protectionRequest" was undefined when calling protectDocument.');
        }

        // verify required parameter 'this.protectionRequest' is not null
        if (this.protectionRequest === null) {
            throw new Error('Required parameter "this.protectionRequest" was null when calling protectDocument.');
        }
        this.protectionRequest?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.protectionRequest !== undefined) {
            let _obj = ObjectSerializer.serialize(this.protectionRequest, this.protectionRequest.constructor.name === "Object" ? "importedProtectionRequestBase.ProtectionRequestBase" : this.protectionRequest.constructor.name);
            formParams.push(['ProtectionRequest', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ProtectionDataResponse");
	}
}

/**
 * Request model for ProtectDocumentOnline operation.
 * Changes the document protection. The previous protection will be overwritten if it exist.
 */
export class ProtectDocumentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< ProtectDocumentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Use ProtectionRequestV2 model to provide protection options.
     */
    public protectionRequest: importedProtectionRequestBase.ProtectionRequestBase;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/protection"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling protectDocumentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling protectDocumentOnline.');
        }
        // verify required parameter 'this.protectionRequest' is not undefined
        if (this.protectionRequest === undefined) {
            throw new Error('Required parameter "this.protectionRequest" was undefined when calling protectDocumentOnline.');
        }

        // verify required parameter 'this.protectionRequest' is not null
        if (this.protectionRequest === null) {
            throw new Error('Required parameter "this.protectionRequest" was null when calling protectDocumentOnline.');
        }
        this.protectionRequest?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.protectionRequest !== undefined) {
            let _obj = ObjectSerializer.serialize(this.protectionRequest, this.protectionRequest.constructor.name === "Object" ? "importedProtectionRequestBase.ProtectionRequestBase" : this.protectionRequest.constructor.name);
            formParams.push(['ProtectionRequest', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new ProtectDocumentOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "ProtectionDataResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for RejectAllRevisions operation.
 * Rejects all revisions in the document.
 */
export class RejectAllRevisionsRequest implements RequestInterface {

    public constructor(init?: Partial< RejectAllRevisionsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/revisions/rejectAll"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling rejectAllRevisions.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling rejectAllRevisions.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RevisionsModificationResponse");
	}
}

/**
 * Request model for RejectAllRevisionsOnline operation.
 * Rejects all revisions in the document.
 */
export class RejectAllRevisionsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< RejectAllRevisionsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/revisions/rejectAll"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling rejectAllRevisionsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling rejectAllRevisionsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new RejectAllRevisionsOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "RevisionsModificationResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for RemoveAllSignatures operation.
 * Removes all signatures of the document.
 */
export class RemoveAllSignaturesRequest implements RequestInterface {

    public constructor(init?: Partial< RemoveAllSignaturesRequest >) {
        Object.assign(this, init);
    }

    /**
     * Name of the document with signatures.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/signatures"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling removeAllSignatures.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling removeAllSignatures.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SignatureCollectionResponse");
	}
}

/**
 * Request model for RemoveAllSignaturesOnline operation.
 * Removes all signatures of the document.
 */
export class RemoveAllSignaturesOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< RemoveAllSignaturesOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/signatures"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling removeAllSignaturesOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling removeAllSignaturesOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new RemoveAllSignaturesOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "SignatureCollectionResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for RemoveRange operation.
 * Removes a range from the document.
 */
export class RemoveRangeRequest implements RequestInterface {

    public constructor(init?: Partial< RemoveRangeRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The range start identifier. Identifier examples: id0.0.0, page0.
     */
    public rangeStartIdentifier: string;

    /**
     * The range end identifier. Identifier examples: id1.0.0, id0.0.0:end, page1, page1:end, document:end.
     */
    public rangeEndIdentifier: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
            .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling removeRange.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling removeRange.');
        }
        // verify required parameter 'this.rangeStartIdentifier' is not undefined
        if (this.rangeStartIdentifier === undefined) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling removeRange.');
        }

        // verify required parameter 'this.rangeStartIdentifier' is not null
        if (this.rangeStartIdentifier === null) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling removeRange.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for RemoveRangeOnline operation.
 * Removes a range from the document.
 */
export class RemoveRangeOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< RemoveRangeOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The range start identifier. Identifier examples: id0.0.0, page0.
     */
    public rangeStartIdentifier: string;

    /**
     * The range end identifier. Identifier examples: id1.0.0, id0.0.0:end, page1, page1:end, document:end.
     */
    public rangeEndIdentifier: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
            .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
            .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling removeRangeOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling removeRangeOnline.');
        }
        // verify required parameter 'this.rangeStartIdentifier' is not undefined
        if (this.rangeStartIdentifier === undefined) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling removeRangeOnline.');
        }

        // verify required parameter 'this.rangeStartIdentifier' is not null
        if (this.rangeStartIdentifier === null) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling removeRangeOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new RemoveRangeOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for RenderDrawingObject operation.
 * Renders a DrawingObject to the specified format.
 */
export class RenderDrawingObjectRequest implements RequestInterface {

    public constructor(init?: Partial< RenderDrawingObjectRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The destination format.
     */
    public format: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}/render"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling renderDrawingObject.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling renderDrawingObject.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling renderDrawingObject.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling renderDrawingObject.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling renderDrawingObject.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling renderDrawingObject.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for RenderDrawingObjectOnline operation.
 * Renders a DrawingObject to the specified format.
 */
export class RenderDrawingObjectOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< RenderDrawingObjectOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The destination format.
     */
    public format: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/drawingObjects/{index}/render"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling renderDrawingObjectOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling renderDrawingObjectOnline.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling renderDrawingObjectOnline.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling renderDrawingObjectOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling renderDrawingObjectOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling renderDrawingObjectOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for RenderMathObject operation.
 * Renders an OfficeMath object to the specified format.
 */
export class RenderMathObjectRequest implements RequestInterface {

    public constructor(init?: Partial< RenderMathObjectRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The destination format.
     */
    public format: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/OfficeMathObjects/{index}/render"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling renderMathObject.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling renderMathObject.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling renderMathObject.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling renderMathObject.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling renderMathObject.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling renderMathObject.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for RenderMathObjectOnline operation.
 * Renders an OfficeMath object to the specified format.
 */
export class RenderMathObjectOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< RenderMathObjectOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The destination format.
     */
    public format: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/OfficeMathObjects/{index}/render"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling renderMathObjectOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling renderMathObjectOnline.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling renderMathObjectOnline.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling renderMathObjectOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling renderMathObjectOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling renderMathObjectOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for RenderPage operation.
 * Renders a page to the specified format.
 */
export class RenderPageRequest implements RequestInterface {

    public constructor(init?: Partial< RenderPageRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the page.
     */
    public pageIndex: number;

    /**
     * The destination format.
     */
    public format: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/pages/{pageIndex}/render"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "pageIndex" + "}", (this.pageIndex !== null && this.pageIndex !== undefined) ? "/" + String(this.pageIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling renderPage.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling renderPage.');
        }
        // verify required parameter 'this.pageIndex' is not undefined
        if (this.pageIndex === undefined) {
            throw new Error('Required parameter "this.pageIndex" was undefined when calling renderPage.');
        }

        // verify required parameter 'this.pageIndex' is not null
        if (this.pageIndex === null) {
            throw new Error('Required parameter "this.pageIndex" was null when calling renderPage.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling renderPage.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling renderPage.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for RenderPageOnline operation.
 * Renders a page to the specified format.
 */
export class RenderPageOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< RenderPageOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the page.
     */
    public pageIndex: number;

    /**
     * The destination format.
     */
    public format: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/pages/{pageIndex}/render"
            .replace("/{" + "pageIndex" + "}", (this.pageIndex !== null && this.pageIndex !== undefined) ? "/" + String(this.pageIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling renderPageOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling renderPageOnline.');
        }
        // verify required parameter 'this.pageIndex' is not undefined
        if (this.pageIndex === undefined) {
            throw new Error('Required parameter "this.pageIndex" was undefined when calling renderPageOnline.');
        }

        // verify required parameter 'this.pageIndex' is not null
        if (this.pageIndex === null) {
            throw new Error('Required parameter "this.pageIndex" was null when calling renderPageOnline.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling renderPageOnline.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling renderPageOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for RenderParagraph operation.
 * Renders a paragraph to the specified format.
 */
export class RenderParagraphRequest implements RequestInterface {

    public constructor(init?: Partial< RenderParagraphRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The destination format.
     */
    public format: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/render"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling renderParagraph.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling renderParagraph.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling renderParagraph.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling renderParagraph.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling renderParagraph.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling renderParagraph.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for RenderParagraphOnline operation.
 * Renders a paragraph to the specified format.
 */
export class RenderParagraphOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< RenderParagraphOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The destination format.
     */
    public format: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/paragraphs/{index}/render"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling renderParagraphOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling renderParagraphOnline.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling renderParagraphOnline.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling renderParagraphOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling renderParagraphOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling renderParagraphOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for RenderTable operation.
 * Renders a table to the specified format.
 */
export class RenderTableRequest implements RequestInterface {

    public constructor(init?: Partial< RenderTableRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The destination format.
     */
    public format: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables/{index}/render"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling renderTable.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling renderTable.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling renderTable.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling renderTable.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling renderTable.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling renderTable.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for RenderTableOnline operation.
 * Renders a table to the specified format.
 */
export class RenderTableOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< RenderTableOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The destination format.
     */
    public format: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/{nodePath}/tables/{index}/render"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling renderTableOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling renderTableOnline.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling renderTableOnline.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling renderTableOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling renderTableOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling renderTableOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return _response;
	}
}

/**
 * Request model for ReplaceText operation.
 * Replaces text in the document.
 */
export class ReplaceTextRequest implements RequestInterface {

    public constructor(init?: Partial< ReplaceTextRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The replace operation settings.
     */
    public replaceText: importedReplaceTextParameters.ReplaceTextParameters;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/replaceText"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling replaceText.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling replaceText.');
        }
        // verify required parameter 'this.replaceText' is not undefined
        if (this.replaceText === undefined) {
            throw new Error('Required parameter "this.replaceText" was undefined when calling replaceText.');
        }

        // verify required parameter 'this.replaceText' is not null
        if (this.replaceText === null) {
            throw new Error('Required parameter "this.replaceText" was null when calling replaceText.');
        }
        this.replaceText?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.replaceText !== undefined) {
            let _obj = ObjectSerializer.serialize(this.replaceText, this.replaceText.constructor.name === "Object" ? "importedReplaceTextParameters.ReplaceTextParameters" : this.replaceText.constructor.name);
            formParams.push(['ReplaceText', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ReplaceTextResponse");
	}
}

/**
 * Request model for ReplaceTextOnline operation.
 * Replaces text in the document.
 */
export class ReplaceTextOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< ReplaceTextOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The replace operation settings.
     */
    public replaceText: importedReplaceTextParameters.ReplaceTextParameters;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/replaceText"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling replaceTextOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling replaceTextOnline.');
        }
        // verify required parameter 'this.replaceText' is not undefined
        if (this.replaceText === undefined) {
            throw new Error('Required parameter "this.replaceText" was undefined when calling replaceTextOnline.');
        }

        // verify required parameter 'this.replaceText' is not null
        if (this.replaceText === null) {
            throw new Error('Required parameter "this.replaceText" was null when calling replaceTextOnline.');
        }
        this.replaceText?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.replaceText !== undefined) {
            let _obj = ObjectSerializer.serialize(this.replaceText, this.replaceText.constructor.name === "Object" ? "importedReplaceTextParameters.ReplaceTextParameters" : this.replaceText.constructor.name);
            formParams.push(['ReplaceText', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new ReplaceTextOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "ReplaceTextResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for ReplaceWithText operation.
 * Replaces a range with text in the document.
 */
export class ReplaceWithTextRequest implements RequestInterface {

    public constructor(init?: Partial< ReplaceWithTextRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The range start identifier. Identifier examples: id0.0.0, page0.
     */
    public rangeStartIdentifier: string;

    /**
     * Model with text for replacement.
     */
    public rangeText: importedReplaceRange.ReplaceRange;

    /**
     * The range end identifier. Identifier examples: id1.0.0, id0.0.0:end, page1, page1:end, document:end.
     */
    public rangeEndIdentifier: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
            .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling replaceWithText.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling replaceWithText.');
        }
        // verify required parameter 'this.rangeStartIdentifier' is not undefined
        if (this.rangeStartIdentifier === undefined) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling replaceWithText.');
        }

        // verify required parameter 'this.rangeStartIdentifier' is not null
        if (this.rangeStartIdentifier === null) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling replaceWithText.');
        }
        // verify required parameter 'this.rangeText' is not undefined
        if (this.rangeText === undefined) {
            throw new Error('Required parameter "this.rangeText" was undefined when calling replaceWithText.');
        }

        // verify required parameter 'this.rangeText' is not null
        if (this.rangeText === null) {
            throw new Error('Required parameter "this.rangeText" was null when calling replaceWithText.');
        }
        this.rangeText?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.rangeText !== undefined) {
            let _obj = ObjectSerializer.serialize(this.rangeText, this.rangeText.constructor.name === "Object" ? "importedReplaceRange.ReplaceRange" : this.rangeText.constructor.name);
            formParams.push(['RangeText', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for ReplaceWithTextOnline operation.
 * Replaces a range with text in the document.
 */
export class ReplaceWithTextOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< ReplaceWithTextOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The range start identifier. Identifier examples: id0.0.0, page0.
     */
    public rangeStartIdentifier: string;

    /**
     * Model with text for replacement.
     */
    public rangeText: importedReplaceRange.ReplaceRange;

    /**
     * The range end identifier. Identifier examples: id1.0.0, id0.0.0:end, page1, page1:end, document:end.
     */
    public rangeEndIdentifier: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/range/{rangeStartIdentifier}/{rangeEndIdentifier}"
            .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
            .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling replaceWithTextOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling replaceWithTextOnline.');
        }
        // verify required parameter 'this.rangeStartIdentifier' is not undefined
        if (this.rangeStartIdentifier === undefined) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling replaceWithTextOnline.');
        }

        // verify required parameter 'this.rangeStartIdentifier' is not null
        if (this.rangeStartIdentifier === null) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling replaceWithTextOnline.');
        }
        // verify required parameter 'this.rangeText' is not undefined
        if (this.rangeText === undefined) {
            throw new Error('Required parameter "this.rangeText" was undefined when calling replaceWithTextOnline.');
        }

        // verify required parameter 'this.rangeText' is not null
        if (this.rangeText === null) {
            throw new Error('Required parameter "this.rangeText" was null when calling replaceWithTextOnline.');
        }
        this.rangeText?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.rangeText !== undefined) {
            let _obj = ObjectSerializer.serialize(this.rangeText, this.rangeText.constructor.name === "Object" ? "importedReplaceRange.ReplaceRange" : this.rangeText.constructor.name);
            formParams.push(['RangeText', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new ReplaceWithTextOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for ResetCache operation.
 * Clears the font cache.
 */
export class ResetCacheRequest implements RequestInterface {

    public constructor(init?: Partial< ResetCacheRequest >) {
        Object.assign(this, init);
    }


	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        const localVarPath = configuration.getApiBaseUrl() + "/words/fonts/cache"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return null;
	}
}

/**
 * Request model for SaveAs operation.
 * Converts a document in cloud storage to the specified format.
 */
export class SaveAsRequest implements RequestInterface {

    public constructor(init?: Partial< SaveAsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Save options.
     */
    public saveOptionsData: importedSaveOptionsData.SaveOptionsData;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/saveAs"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling saveAs.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling saveAs.');
        }
        // verify required parameter 'this.saveOptionsData' is not undefined
        if (this.saveOptionsData === undefined) {
            throw new Error('Required parameter "this.saveOptionsData" was undefined when calling saveAs.');
        }

        // verify required parameter 'this.saveOptionsData' is not null
        if (this.saveOptionsData === null) {
            throw new Error('Required parameter "this.saveOptionsData" was null when calling saveAs.');
        }
        this.saveOptionsData?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
        if (this.saveOptionsData !== undefined) {
            let _obj = ObjectSerializer.serialize(this.saveOptionsData, this.saveOptionsData.constructor.name === "Object" ? "importedSaveOptionsData.SaveOptionsData" : this.saveOptionsData.constructor.name);
            formParams.push(['SaveOptionsData', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SaveResponse");
	}
}

/**
 * Request model for SaveAsOnline operation.
 * Converts a document in cloud storage to the specified format.
 */
export class SaveAsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< SaveAsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Save options.
     */
    public saveOptionsData: importedSaveOptionsData.SaveOptionsData;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/saveAs"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling saveAsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling saveAsOnline.');
        }
        // verify required parameter 'this.saveOptionsData' is not undefined
        if (this.saveOptionsData === undefined) {
            throw new Error('Required parameter "this.saveOptionsData" was undefined when calling saveAsOnline.');
        }

        // verify required parameter 'this.saveOptionsData' is not null
        if (this.saveOptionsData === null) {
            throw new Error('Required parameter "this.saveOptionsData" was null when calling saveAsOnline.');
        }
        this.saveOptionsData?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.saveOptionsData !== undefined) {
            let _obj = ObjectSerializer.serialize(this.saveOptionsData, this.saveOptionsData.constructor.name === "Object" ? "importedSaveOptionsData.SaveOptionsData" : this.saveOptionsData.constructor.name);
            formParams.push(['SaveOptionsData', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new SaveAsOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "SaveResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for SaveAsRange operation.
 * Saves a range as a new document.
 */
export class SaveAsRangeRequest implements RequestInterface {

    public constructor(init?: Partial< SaveAsRangeRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The range start identifier. Identifier examples: id0.0.0, page0.
     */
    public rangeStartIdentifier: string;

    /**
     * Parameters of a new document.
     */
    public documentParameters: importedRangeDocument.RangeDocument;

    /**
     * The range end identifier. Identifier examples: id1.0.0, id0.0.0:end, page1, page1:end, document:end.
     */
    public rangeEndIdentifier: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/range/{rangeStartIdentifier}/{rangeEndIdentifier}/SaveAs"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
            .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling saveAsRange.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling saveAsRange.');
        }
        // verify required parameter 'this.rangeStartIdentifier' is not undefined
        if (this.rangeStartIdentifier === undefined) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling saveAsRange.');
        }

        // verify required parameter 'this.rangeStartIdentifier' is not null
        if (this.rangeStartIdentifier === null) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling saveAsRange.');
        }
        // verify required parameter 'this.documentParameters' is not undefined
        if (this.documentParameters === undefined) {
            throw new Error('Required parameter "this.documentParameters" was undefined when calling saveAsRange.');
        }

        // verify required parameter 'this.documentParameters' is not null
        if (this.documentParameters === null) {
            throw new Error('Required parameter "this.documentParameters" was null when calling saveAsRange.');
        }
        this.documentParameters?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.documentParameters !== undefined) {
            let _obj = ObjectSerializer.serialize(this.documentParameters, this.documentParameters.constructor.name === "Object" ? "importedRangeDocument.RangeDocument" : this.documentParameters.constructor.name);
            formParams.push(['DocumentParameters', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for SaveAsRangeOnline operation.
 * Saves a range as a new document.
 */
export class SaveAsRangeOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< SaveAsRangeOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The range start identifier. Identifier examples: id0.0.0, page0.
     */
    public rangeStartIdentifier: string;

    /**
     * Parameters of a new document.
     */
    public documentParameters: importedRangeDocument.RangeDocument;

    /**
     * The range end identifier. Identifier examples: id1.0.0, id0.0.0:end, page1, page1:end, document:end.
     */
    public rangeEndIdentifier: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/range/{rangeStartIdentifier}/{rangeEndIdentifier}/SaveAs"
            .replace("/{" + "rangeStartIdentifier" + "}", (this.rangeStartIdentifier !== null && this.rangeStartIdentifier !== undefined) ? "/" + String(this.rangeStartIdentifier) : "")
            .replace("/{" + "rangeEndIdentifier" + "}", (this.rangeEndIdentifier !== null && this.rangeEndIdentifier !== undefined) ? "/" + String(this.rangeEndIdentifier) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling saveAsRangeOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling saveAsRangeOnline.');
        }
        // verify required parameter 'this.rangeStartIdentifier' is not undefined
        if (this.rangeStartIdentifier === undefined) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was undefined when calling saveAsRangeOnline.');
        }

        // verify required parameter 'this.rangeStartIdentifier' is not null
        if (this.rangeStartIdentifier === null) {
            throw new Error('Required parameter "this.rangeStartIdentifier" was null when calling saveAsRangeOnline.');
        }
        // verify required parameter 'this.documentParameters' is not undefined
        if (this.documentParameters === undefined) {
            throw new Error('Required parameter "this.documentParameters" was undefined when calling saveAsRangeOnline.');
        }

        // verify required parameter 'this.documentParameters' is not null
        if (this.documentParameters === null) {
            throw new Error('Required parameter "this.documentParameters" was null when calling saveAsRangeOnline.');
        }
        this.documentParameters?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.documentParameters !== undefined) {
            let _obj = ObjectSerializer.serialize(this.documentParameters, this.documentParameters.constructor.name === "Object" ? "importedRangeDocument.RangeDocument" : this.documentParameters.constructor.name);
            formParams.push(['DocumentParameters', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new SaveAsRangeOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for SaveAsTiff operation.
 * Converts a document in cloud storage to TIFF format using detailed conversion settings.
 */
export class SaveAsTiffRequest implements RequestInterface {

    public constructor(init?: Partial< SaveAsTiffRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Tiff save options.
     */
    public saveOptions: importedTiffSaveOptionsData.TiffSaveOptionsData;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The flag indicating whether to use antialiasing.
     */
    public useAntiAliasing: boolean;

    /**
     * The flag indicating whether to use high quality.
     */
    public useHighQualityRendering: boolean;

    /**
     * The level of brightness for the generated images.
     */
    public imageBrightness: number;

    /**
     * The color mode for the generated images.
     */
    public imageColorMode: string;

    /**
     * The contrast for the generated images.
     */
    public imageContrast: number;

    /**
     * The images numeral format.
     */
    public numeralFormat: string;

    /**
     * The number of pages to render.
     */
    public pageCount: number;

    /**
     * The index of the page to start rendering.
     */
    public pageIndex: number;

    /**
     * The background image color.
     */
    public paperColor: string;

    /**
     * The pixel format of the generated images.
     */
    public pixelFormat: string;

    /**
     * The resolution of the generated images.
     */
    public resolution: number;

    /**
     * The zoom factor for the generated images.
     */
    public scale: number;

    /**
     * The compression tipe.
     */
    public tiffCompression: string;

    /**
     * The optional dml rendering mode. The default value is Fallback.
     */
    public dmlRenderingMode: string;

    /**
     * The optional dml effects rendering mode. The default value is Simplified.
     */
    public dmlEffectsRenderingMode: string;

    /**
     * The optional TIFF binarization method. Possible values are: FloydSteinbergDithering, Threshold.
     */
    public tiffBinarizationMethod: string;

    /**
     * The flag indicating whether to ZIP the output.
     */
    public zipOutput: boolean;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/saveAs/tiff"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling saveAsTiff.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling saveAsTiff.');
        }
        // verify required parameter 'this.saveOptions' is not undefined
        if (this.saveOptions === undefined) {
            throw new Error('Required parameter "this.saveOptions" was undefined when calling saveAsTiff.');
        }

        // verify required parameter 'this.saveOptions' is not null
        if (this.saveOptions === null) {
            throw new Error('Required parameter "this.saveOptions" was null when calling saveAsTiff.');
        }
        this.saveOptions?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "useAntiAliasing", this.useAntiAliasing, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "useHighQualityRendering", this.useHighQualityRendering, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "imageBrightness", this.imageBrightness, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "imageColorMode", this.imageColorMode, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "imageContrast", this.imageContrast, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "numeralFormat", this.numeralFormat, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "pageCount", this.pageCount, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "pageIndex", this.pageIndex, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "paperColor", this.paperColor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "pixelFormat", this.pixelFormat, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "resolution", this.resolution, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "scale", this.scale, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "tiffCompression", this.tiffCompression, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "dmlRenderingMode", this.dmlRenderingMode, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "dmlEffectsRenderingMode", this.dmlEffectsRenderingMode, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "tiffBinarizationMethod", this.tiffBinarizationMethod, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "zipOutput", this.zipOutput, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
        if (this.saveOptions !== undefined) {
            let _obj = ObjectSerializer.serialize(this.saveOptions, this.saveOptions.constructor.name === "Object" ? "importedTiffSaveOptionsData.TiffSaveOptionsData" : this.saveOptions.constructor.name);
            formParams.push(['SaveOptions', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SaveResponse");
	}
}

/**
 * Request model for SaveAsTiffOnline operation.
 * Converts a document in cloud storage to TIFF format using detailed conversion settings.
 */
export class SaveAsTiffOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< SaveAsTiffOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Tiff save options.
     */
    public saveOptions: importedTiffSaveOptionsData.TiffSaveOptionsData;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * The flag indicating whether to use antialiasing.
     */
    public useAntiAliasing: boolean;

    /**
     * The flag indicating whether to use high quality.
     */
    public useHighQualityRendering: boolean;

    /**
     * The level of brightness for the generated images.
     */
    public imageBrightness: number;

    /**
     * The color mode for the generated images.
     */
    public imageColorMode: string;

    /**
     * The contrast for the generated images.
     */
    public imageContrast: number;

    /**
     * The images numeral format.
     */
    public numeralFormat: string;

    /**
     * The number of pages to render.
     */
    public pageCount: number;

    /**
     * The index of the page to start rendering.
     */
    public pageIndex: number;

    /**
     * The background image color.
     */
    public paperColor: string;

    /**
     * The pixel format of the generated images.
     */
    public pixelFormat: string;

    /**
     * The resolution of the generated images.
     */
    public resolution: number;

    /**
     * The zoom factor for the generated images.
     */
    public scale: number;

    /**
     * The compression tipe.
     */
    public tiffCompression: string;

    /**
     * The optional dml rendering mode. The default value is Fallback.
     */
    public dmlRenderingMode: string;

    /**
     * The optional dml effects rendering mode. The default value is Simplified.
     */
    public dmlEffectsRenderingMode: string;

    /**
     * The optional TIFF binarization method. Possible values are: FloydSteinbergDithering, Threshold.
     */
    public tiffBinarizationMethod: string;

    /**
     * The flag indicating whether to ZIP the output.
     */
    public zipOutput: boolean;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/saveAs/tiff"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling saveAsTiffOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling saveAsTiffOnline.');
        }
        // verify required parameter 'this.saveOptions' is not undefined
        if (this.saveOptions === undefined) {
            throw new Error('Required parameter "this.saveOptions" was undefined when calling saveAsTiffOnline.');
        }

        // verify required parameter 'this.saveOptions' is not null
        if (this.saveOptions === null) {
            throw new Error('Required parameter "this.saveOptions" was null when calling saveAsTiffOnline.');
        }
        this.saveOptions?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "useAntiAliasing", this.useAntiAliasing, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "useHighQualityRendering", this.useHighQualityRendering, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "imageBrightness", this.imageBrightness, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "imageColorMode", this.imageColorMode, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "imageContrast", this.imageContrast, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "numeralFormat", this.numeralFormat, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "pageCount", this.pageCount, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "pageIndex", this.pageIndex, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "paperColor", this.paperColor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "pixelFormat", this.pixelFormat, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "resolution", this.resolution, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "scale", this.scale, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "tiffCompression", this.tiffCompression, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "dmlRenderingMode", this.dmlRenderingMode, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "dmlEffectsRenderingMode", this.dmlEffectsRenderingMode, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "tiffBinarizationMethod", this.tiffBinarizationMethod, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "zipOutput", this.zipOutput, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.saveOptions !== undefined) {
            let _obj = ObjectSerializer.serialize(this.saveOptions, this.saveOptions.constructor.name === "Object" ? "importedTiffSaveOptionsData.TiffSaveOptionsData" : this.saveOptions.constructor.name);
            formParams.push(['SaveOptions', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new SaveAsTiffOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "SaveResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for Search operation.
 * Searches text, specified by the regular expression, in the document.
 */
export class SearchRequest implements RequestInterface {

    public constructor(init?: Partial< SearchRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The regular expression used to find matches.
     */
    public pattern: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/search"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling search.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling search.');
        }
        // verify required parameter 'this.pattern' is not undefined
        if (this.pattern === undefined) {
            throw new Error('Required parameter "this.pattern" was undefined when calling search.');
        }

        // verify required parameter 'this.pattern' is not null
        if (this.pattern === null) {
            throw new Error('Required parameter "this.pattern" was null when calling search.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "pattern", this.pattern, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SearchResponse");
	}
}

/**
 * Request model for SearchOnline operation.
 * Searches text, specified by the regular expression, in the document.
 */
export class SearchOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< SearchOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The regular expression used to find matches.
     */
    public pattern: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/search"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling searchOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling searchOnline.');
        }
        // verify required parameter 'this.pattern' is not undefined
        if (this.pattern === undefined) {
            throw new Error('Required parameter "this.pattern" was undefined when calling searchOnline.');
        }

        // verify required parameter 'this.pattern' is not null
        if (this.pattern === null) {
            throw new Error('Required parameter "this.pattern" was null when calling searchOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "pattern", this.pattern, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SearchResponse");
	}
}

/**
 * Request model for SignDocument operation.
 * Signs the document with given certificate.
 */
export class SignDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< SignDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * Name of the document to sign.
     */
    public name: string;

    /**
     * certifate file path.
     */
    public certificatePath: string;

    /**
     * certificate password.
     */
    public certificatePassword: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/signatures"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling signDocument.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling signDocument.');
        }
        // verify required parameter 'this.certificatePath' is not undefined
        if (this.certificatePath === undefined) {
            throw new Error('Required parameter "this.certificatePath" was undefined when calling signDocument.');
        }

        // verify required parameter 'this.certificatePath' is not null
        if (this.certificatePath === null) {
            throw new Error('Required parameter "this.certificatePath" was null when calling signDocument.');
        }
        // verify required parameter 'this.certificatePassword' is not undefined
        if (this.certificatePassword === undefined) {
            throw new Error('Required parameter "this.certificatePassword" was undefined when calling signDocument.');
        }

        // verify required parameter 'this.certificatePassword' is not null
        if (this.certificatePassword === null) {
            throw new Error('Required parameter "this.certificatePassword" was null when calling signDocument.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "certificatePath", this.certificatePath, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "certificatePassword", this.certificatePassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "POST",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SignatureCollectionResponse");
	}
}

/**
 * Request model for SignDocumentOnline operation.
 * Signs the document with given certificate.
 */
export class SignDocumentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< SignDocumentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * certifate file path.
     */
    public certificatePath: string;

    /**
     * certificate password.
     */
    public certificatePassword: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/post/signatures"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling signDocumentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling signDocumentOnline.');
        }
        // verify required parameter 'this.certificatePath' is not undefined
        if (this.certificatePath === undefined) {
            throw new Error('Required parameter "this.certificatePath" was undefined when calling signDocumentOnline.');
        }

        // verify required parameter 'this.certificatePath' is not null
        if (this.certificatePath === null) {
            throw new Error('Required parameter "this.certificatePath" was null when calling signDocumentOnline.');
        }
        // verify required parameter 'this.certificatePassword' is not undefined
        if (this.certificatePassword === undefined) {
            throw new Error('Required parameter "this.certificatePassword" was undefined when calling signDocumentOnline.');
        }

        // verify required parameter 'this.certificatePassword' is not null
        if (this.certificatePassword === null) {
            throw new Error('Required parameter "this.certificatePassword" was null when calling signDocumentOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "certificatePath", this.certificatePath, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "certificatePassword", this.certificatePassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new SignDocumentOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "SignatureCollectionResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for SplitDocument operation.
 * Splits a document into parts and saves them in the specified format.
 */
export class SplitDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< SplitDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The format to split.
     */
    public format: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * The start page.
     */
    public from: number;

    /**
     * The end page.
     */
    public to: number;

    /**
     * The flag indicating whether to ZIP the output.
     */
    public zipOutput: boolean;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/split"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling splitDocument.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling splitDocument.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling splitDocument.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling splitDocument.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "from", this.from, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "to", this.to, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "zipOutput", this.zipOutput, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SplitDocumentResponse");
	}
}

/**
 * Request model for SplitDocumentOnline operation.
 * Splits a document into parts and saves them in the specified format.
 */
export class SplitDocumentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< SplitDocumentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The format to split.
     */
    public format: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * The start page.
     */
    public from: number;

    /**
     * The end page.
     */
    public to: number;

    /**
     * The flag indicating whether to ZIP the output.
     */
    public zipOutput: boolean;

    /**
     * Folder in filestorage with custom fonts.
     */
    public fontsLocation: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/split"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling splitDocumentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling splitDocumentOnline.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling splitDocumentOnline.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling splitDocumentOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "format", this.format, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "from", this.from, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "to", this.to, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "zipOutput", this.zipOutput, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "fontsLocation", this.fontsLocation, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new SplitDocumentOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "SplitDocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for TranslateNodeId operation.
 * Translate a node id to a node path.
 */
export class TranslateNodeIdRequest implements RequestInterface {

    public constructor(init?: Partial< TranslateNodeIdRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The node identifier. Identifier examples: id0.0.0.
     */
    public nodeId: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/translate/{nodeId}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "nodeId" + "}", (this.nodeId !== null && this.nodeId !== undefined) ? "/" + String(this.nodeId) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling translateNodeId.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling translateNodeId.');
        }
        // verify required parameter 'this.nodeId' is not undefined
        if (this.nodeId === undefined) {
            throw new Error('Required parameter "this.nodeId" was undefined when calling translateNodeId.');
        }

        // verify required parameter 'this.nodeId' is not null
        if (this.nodeId === null) {
            throw new Error('Required parameter "this.nodeId" was null when calling translateNodeId.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "GET",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TranslateNodeIdResponse");
	}
}

/**
 * Request model for TranslateNodeIdOnline operation.
 * Translate a node id to a node path.
 */
export class TranslateNodeIdOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< TranslateNodeIdOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The node identifier. Identifier examples: id0.0.0.
     */
    public nodeId: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/get/translate/{nodeId}"
            .replace("/{" + "nodeId" + "}", (this.nodeId !== null && this.nodeId !== undefined) ? "/" + String(this.nodeId) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling translateNodeIdOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling translateNodeIdOnline.');
        }
        // verify required parameter 'this.nodeId' is not undefined
        if (this.nodeId === undefined) {
            throw new Error('Required parameter "this.nodeId" was undefined when calling translateNodeIdOnline.');
        }

        // verify required parameter 'this.nodeId' is not null
        if (this.nodeId === null) {
            throw new Error('Required parameter "this.nodeId" was null when calling translateNodeIdOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TranslateNodeIdResponse");
	}
}

/**
 * Request model for UnprotectDocument operation.
 * Removes protection from the document.
 */
export class UnprotectDocumentRequest implements RequestInterface {

    public constructor(init?: Partial< UnprotectDocumentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/protection"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling unprotectDocument.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling unprotectDocument.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "DELETE",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ProtectionDataResponse");
	}
}

/**
 * Request model for UnprotectDocumentOnline operation.
 * Removes protection from the document.
 */
export class UnprotectDocumentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UnprotectDocumentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/delete/protection"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling unprotectDocumentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling unprotectDocumentOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UnprotectDocumentOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "ProtectionDataResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateBookmark operation.
 * Updates a bookmark in the document.
 */
export class UpdateBookmarkRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateBookmarkRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The name of the bookmark.
     */
    public bookmarkName: string;

    /**
     * Bookmark data.
     */
    public bookmarkData: importedBookmarkData.BookmarkData;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/bookmarks/{bookmarkName}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateBookmark.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateBookmark.');
        }
        // verify required parameter 'this.bookmarkName' is not undefined
        if (this.bookmarkName === undefined) {
            throw new Error('Required parameter "this.bookmarkName" was undefined when calling updateBookmark.');
        }

        // verify required parameter 'this.bookmarkName' is not null
        if (this.bookmarkName === null) {
            throw new Error('Required parameter "this.bookmarkName" was null when calling updateBookmark.');
        }
        // verify required parameter 'this.bookmarkData' is not undefined
        if (this.bookmarkData === undefined) {
            throw new Error('Required parameter "this.bookmarkData" was undefined when calling updateBookmark.');
        }

        // verify required parameter 'this.bookmarkData' is not null
        if (this.bookmarkData === null) {
            throw new Error('Required parameter "this.bookmarkData" was null when calling updateBookmark.');
        }
        this.bookmarkData?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.bookmarkData !== undefined) {
            let _obj = ObjectSerializer.serialize(this.bookmarkData, this.bookmarkData.constructor.name === "Object" ? "importedBookmarkData.BookmarkData" : this.bookmarkData.constructor.name);
            formParams.push(['BookmarkData', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BookmarkResponse");
	}
}

/**
 * Request model for UpdateBookmarkOnline operation.
 * Updates a bookmark in the document.
 */
export class UpdateBookmarkOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateBookmarkOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The name of the bookmark.
     */
    public bookmarkName: string;

    /**
     * Bookmark data.
     */
    public bookmarkData: importedBookmarkData.BookmarkData;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/bookmarks/{bookmarkName}"
            .replace("/{" + "bookmarkName" + "}", (this.bookmarkName !== null && this.bookmarkName !== undefined) ? "/" + String(this.bookmarkName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateBookmarkOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateBookmarkOnline.');
        }
        // verify required parameter 'this.bookmarkName' is not undefined
        if (this.bookmarkName === undefined) {
            throw new Error('Required parameter "this.bookmarkName" was undefined when calling updateBookmarkOnline.');
        }

        // verify required parameter 'this.bookmarkName' is not null
        if (this.bookmarkName === null) {
            throw new Error('Required parameter "this.bookmarkName" was null when calling updateBookmarkOnline.');
        }
        // verify required parameter 'this.bookmarkData' is not undefined
        if (this.bookmarkData === undefined) {
            throw new Error('Required parameter "this.bookmarkData" was undefined when calling updateBookmarkOnline.');
        }

        // verify required parameter 'this.bookmarkData' is not null
        if (this.bookmarkData === null) {
            throw new Error('Required parameter "this.bookmarkData" was null when calling updateBookmarkOnline.');
        }
        this.bookmarkData?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.bookmarkData !== undefined) {
            let _obj = ObjectSerializer.serialize(this.bookmarkData, this.bookmarkData.constructor.name === "Object" ? "importedBookmarkData.BookmarkData" : this.bookmarkData.constructor.name);
            formParams.push(['BookmarkData', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateBookmarkOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "BookmarkResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateBorder operation.
 * Updates a border in the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
export class UpdateBorderRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateBorderRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Border type.
     */
    public borderType: string;

    /**
     * Border properties.
     */
    public borderProperties: importedBorder.Border;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/borders/{borderType}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateBorder.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateBorder.');
        }
        // verify required parameter 'this.borderType' is not undefined
        if (this.borderType === undefined) {
            throw new Error('Required parameter "this.borderType" was undefined when calling updateBorder.');
        }

        // verify required parameter 'this.borderType' is not null
        if (this.borderType === null) {
            throw new Error('Required parameter "this.borderType" was null when calling updateBorder.');
        }
        // verify required parameter 'this.borderProperties' is not undefined
        if (this.borderProperties === undefined) {
            throw new Error('Required parameter "this.borderProperties" was undefined when calling updateBorder.');
        }

        // verify required parameter 'this.borderProperties' is not null
        if (this.borderProperties === null) {
            throw new Error('Required parameter "this.borderProperties" was null when calling updateBorder.');
        }
        this.borderProperties?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.borderProperties !== undefined) {
            let _obj = ObjectSerializer.serialize(this.borderProperties, this.borderProperties.constructor.name === "Object" ? "importedBorder.Border" : this.borderProperties.constructor.name);
            formParams.push(['BorderProperties', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "BorderResponse");
	}
}

/**
 * Request model for UpdateBorderOnline operation.
 * Updates a border in the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
export class UpdateBorderOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateBorderOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Border properties.
     */
    public borderProperties: importedBorder.Border;

    /**
     * Border type.
     */
    public borderType: string;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/borders/{borderType}"
            .replace("/{" + "borderType" + "}", (this.borderType !== null && this.borderType !== undefined) ? "/" + String(this.borderType) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateBorderOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateBorderOnline.');
        }
        // verify required parameter 'this.borderProperties' is not undefined
        if (this.borderProperties === undefined) {
            throw new Error('Required parameter "this.borderProperties" was undefined when calling updateBorderOnline.');
        }

        // verify required parameter 'this.borderProperties' is not null
        if (this.borderProperties === null) {
            throw new Error('Required parameter "this.borderProperties" was null when calling updateBorderOnline.');
        }
        // verify required parameter 'this.borderType' is not undefined
        if (this.borderType === undefined) {
            throw new Error('Required parameter "this.borderType" was undefined when calling updateBorderOnline.');
        }

        // verify required parameter 'this.borderType' is not null
        if (this.borderType === null) {
            throw new Error('Required parameter "this.borderType" was null when calling updateBorderOnline.');
        }
        this.borderProperties?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.borderProperties !== undefined) {
            let _obj = ObjectSerializer.serialize(this.borderProperties, this.borderProperties.constructor.name === "Object" ? "importedBorder.Border" : this.borderProperties.constructor.name);
            formParams.push(['BorderProperties', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateBorderOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "BorderResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateComment operation.
 * Updates a comment in the document.
 */
export class UpdateCommentRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateCommentRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the comment.
     */
    public commentIndex: number;

    /**
     * Comment data.
     */
    public comment: importedCommentUpdate.CommentUpdate;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/comments/{commentIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateComment.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateComment.');
        }
        // verify required parameter 'this.commentIndex' is not undefined
        if (this.commentIndex === undefined) {
            throw new Error('Required parameter "this.commentIndex" was undefined when calling updateComment.');
        }

        // verify required parameter 'this.commentIndex' is not null
        if (this.commentIndex === null) {
            throw new Error('Required parameter "this.commentIndex" was null when calling updateComment.');
        }
        // verify required parameter 'this.comment' is not undefined
        if (this.comment === undefined) {
            throw new Error('Required parameter "this.comment" was undefined when calling updateComment.');
        }

        // verify required parameter 'this.comment' is not null
        if (this.comment === null) {
            throw new Error('Required parameter "this.comment" was null when calling updateComment.');
        }
        this.comment?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.comment !== undefined) {
            let _obj = ObjectSerializer.serialize(this.comment, this.comment.constructor.name === "Object" ? "importedCommentUpdate.CommentUpdate" : this.comment.constructor.name);
            formParams.push(['Comment', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CommentResponse");
	}
}

/**
 * Request model for UpdateCommentOnline operation.
 * Updates a comment in the document.
 */
export class UpdateCommentOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateCommentOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the comment.
     */
    public commentIndex: number;

    /**
     * Comment data.
     */
    public comment: importedCommentUpdate.CommentUpdate;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/comments/{commentIndex}"
            .replace("/{" + "commentIndex" + "}", (this.commentIndex !== null && this.commentIndex !== undefined) ? "/" + String(this.commentIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateCommentOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateCommentOnline.');
        }
        // verify required parameter 'this.commentIndex' is not undefined
        if (this.commentIndex === undefined) {
            throw new Error('Required parameter "this.commentIndex" was undefined when calling updateCommentOnline.');
        }

        // verify required parameter 'this.commentIndex' is not null
        if (this.commentIndex === null) {
            throw new Error('Required parameter "this.commentIndex" was null when calling updateCommentOnline.');
        }
        // verify required parameter 'this.comment' is not undefined
        if (this.comment === undefined) {
            throw new Error('Required parameter "this.comment" was undefined when calling updateCommentOnline.');
        }

        // verify required parameter 'this.comment' is not null
        if (this.comment === null) {
            throw new Error('Required parameter "this.comment" was null when calling updateCommentOnline.');
        }
        this.comment?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.comment !== undefined) {
            let _obj = ObjectSerializer.serialize(this.comment, this.comment.constructor.name === "Object" ? "importedCommentUpdate.CommentUpdate" : this.comment.constructor.name);
            formParams.push(['Comment', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateCommentOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "CommentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateCustomXmlPart operation.
 * Updates the custom xml part in the document.
 */
export class UpdateCustomXmlPartRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateCustomXmlPartRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the custom xml part. This index is the number of the entry in the collection of custom xml parts, not the ID of the part.
     */
    public customXmlPartIndex: number;

    /**
     * Custom xml part.
     */
    public customXmlPart: importedCustomXmlPartUpdate.CustomXmlPartUpdate;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/customXmlParts/{customXmlPartIndex}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateCustomXmlPart.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateCustomXmlPart.');
        }
        // verify required parameter 'this.customXmlPartIndex' is not undefined
        if (this.customXmlPartIndex === undefined) {
            throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling updateCustomXmlPart.');
        }

        // verify required parameter 'this.customXmlPartIndex' is not null
        if (this.customXmlPartIndex === null) {
            throw new Error('Required parameter "this.customXmlPartIndex" was null when calling updateCustomXmlPart.');
        }
        // verify required parameter 'this.customXmlPart' is not undefined
        if (this.customXmlPart === undefined) {
            throw new Error('Required parameter "this.customXmlPart" was undefined when calling updateCustomXmlPart.');
        }

        // verify required parameter 'this.customXmlPart' is not null
        if (this.customXmlPart === null) {
            throw new Error('Required parameter "this.customXmlPart" was null when calling updateCustomXmlPart.');
        }
        this.customXmlPart?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.customXmlPart !== undefined) {
            let _obj = ObjectSerializer.serialize(this.customXmlPart, this.customXmlPart.constructor.name === "Object" ? "importedCustomXmlPartUpdate.CustomXmlPartUpdate" : this.customXmlPart.constructor.name);
            formParams.push(['CustomXmlPart', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "CustomXmlPartResponse");
	}
}

/**
 * Request model for UpdateCustomXmlPartOnline operation.
 * Updates the custom xml part in the document.
 */
export class UpdateCustomXmlPartOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateCustomXmlPartOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the custom xml part. This index is the number of the entry in the collection of custom xml parts, not the ID of the part.
     */
    public customXmlPartIndex: number;

    /**
     * Custom xml part.
     */
    public customXmlPart: importedCustomXmlPartUpdate.CustomXmlPartUpdate;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/customXmlParts/{customXmlPartIndex}"
            .replace("/{" + "customXmlPartIndex" + "}", (this.customXmlPartIndex !== null && this.customXmlPartIndex !== undefined) ? "/" + String(this.customXmlPartIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateCustomXmlPartOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateCustomXmlPartOnline.');
        }
        // verify required parameter 'this.customXmlPartIndex' is not undefined
        if (this.customXmlPartIndex === undefined) {
            throw new Error('Required parameter "this.customXmlPartIndex" was undefined when calling updateCustomXmlPartOnline.');
        }

        // verify required parameter 'this.customXmlPartIndex' is not null
        if (this.customXmlPartIndex === null) {
            throw new Error('Required parameter "this.customXmlPartIndex" was null when calling updateCustomXmlPartOnline.');
        }
        // verify required parameter 'this.customXmlPart' is not undefined
        if (this.customXmlPart === undefined) {
            throw new Error('Required parameter "this.customXmlPart" was undefined when calling updateCustomXmlPartOnline.');
        }

        // verify required parameter 'this.customXmlPart' is not null
        if (this.customXmlPart === null) {
            throw new Error('Required parameter "this.customXmlPart" was null when calling updateCustomXmlPartOnline.');
        }
        this.customXmlPart?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.customXmlPart !== undefined) {
            let _obj = ObjectSerializer.serialize(this.customXmlPart, this.customXmlPart.constructor.name === "Object" ? "importedCustomXmlPartUpdate.CustomXmlPartUpdate" : this.customXmlPart.constructor.name);
            formParams.push(['CustomXmlPart', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateCustomXmlPartOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "CustomXmlPartResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateDrawingObject operation.
 * Updates a DrawingObject in the document node.
 */
export class UpdateDrawingObjectRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateDrawingObjectRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Drawing object parameters.
     */
    public drawingObject: importedDrawingObjectUpdate.DrawingObjectUpdate;

    /**
     * File with image.
     */
    public imageFile: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/drawingObjects/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateDrawingObject.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateDrawingObject.');
        }
        // verify required parameter 'this.drawingObject' is not undefined
        if (this.drawingObject === undefined) {
            throw new Error('Required parameter "this.drawingObject" was undefined when calling updateDrawingObject.');
        }

        // verify required parameter 'this.drawingObject' is not null
        if (this.drawingObject === null) {
            throw new Error('Required parameter "this.drawingObject" was null when calling updateDrawingObject.');
        }
        // verify required parameter 'this.imageFile' is not undefined
        if (this.imageFile === undefined) {
            throw new Error('Required parameter "this.imageFile" was undefined when calling updateDrawingObject.');
        }

        // verify required parameter 'this.imageFile' is not null
        if (this.imageFile === null) {
            throw new Error('Required parameter "this.imageFile" was null when calling updateDrawingObject.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateDrawingObject.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateDrawingObject.');
        }
        this.drawingObject?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.drawingObject !== undefined) {
            let _obj = ObjectSerializer.serialize(this.drawingObject, this.drawingObject.constructor.name === "Object" ? "importedDrawingObjectUpdate.DrawingObjectUpdate" : this.drawingObject.constructor.name);
            formParams.push(['DrawingObject', JSON.stringify(_obj), 'application/json']);
        }
        if (this.imageFile !== undefined) {
            formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DrawingObjectResponse");
	}
}

/**
 * Request model for UpdateDrawingObjectOnline operation.
 * Updates a DrawingObject in the document node.
 */
export class UpdateDrawingObjectOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateDrawingObjectOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Drawing object parameters.
     */
    public drawingObject: importedDrawingObjectUpdate.DrawingObjectUpdate;

    /**
     * File with image.
     */
    public imageFile: Readable;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/drawingObjects/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateDrawingObjectOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateDrawingObjectOnline.');
        }
        // verify required parameter 'this.drawingObject' is not undefined
        if (this.drawingObject === undefined) {
            throw new Error('Required parameter "this.drawingObject" was undefined when calling updateDrawingObjectOnline.');
        }

        // verify required parameter 'this.drawingObject' is not null
        if (this.drawingObject === null) {
            throw new Error('Required parameter "this.drawingObject" was null when calling updateDrawingObjectOnline.');
        }
        // verify required parameter 'this.imageFile' is not undefined
        if (this.imageFile === undefined) {
            throw new Error('Required parameter "this.imageFile" was undefined when calling updateDrawingObjectOnline.');
        }

        // verify required parameter 'this.imageFile' is not null
        if (this.imageFile === null) {
            throw new Error('Required parameter "this.imageFile" was null when calling updateDrawingObjectOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateDrawingObjectOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateDrawingObjectOnline.');
        }
        this.drawingObject?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.drawingObject !== undefined) {
            let _obj = ObjectSerializer.serialize(this.drawingObject, this.drawingObject.constructor.name === "Object" ? "importedDrawingObjectUpdate.DrawingObjectUpdate" : this.drawingObject.constructor.name);
            formParams.push(['DrawingObject', JSON.stringify(_obj), 'application/json']);
        }
        if (this.imageFile !== undefined) {
            formParams.push(['ImageFile', this.imageFile, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateDrawingObjectOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DrawingObjectResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateField operation.
 * Updates a field in the document node.
 */
export class UpdateFieldRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateFieldRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Field data.
     */
    public field: importedFieldUpdate.FieldUpdate;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/fields/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateField.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateField.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateField.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateField.');
        }
        // verify required parameter 'this.field' is not undefined
        if (this.field === undefined) {
            throw new Error('Required parameter "this.field" was undefined when calling updateField.');
        }

        // verify required parameter 'this.field' is not null
        if (this.field === null) {
            throw new Error('Required parameter "this.field" was null when calling updateField.');
        }
        this.field?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.field !== undefined) {
            let _obj = ObjectSerializer.serialize(this.field, this.field.constructor.name === "Object" ? "importedFieldUpdate.FieldUpdate" : this.field.constructor.name);
            formParams.push(['Field', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FieldResponse");
	}
}

/**
 * Request model for UpdateFieldOnline operation.
 * Updates a field in the document node.
 */
export class UpdateFieldOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateFieldOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Field data.
     */
    public field: importedFieldUpdate.FieldUpdate;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/fields/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateFieldOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateFieldOnline.');
        }
        // verify required parameter 'this.field' is not undefined
        if (this.field === undefined) {
            throw new Error('Required parameter "this.field" was undefined when calling updateFieldOnline.');
        }

        // verify required parameter 'this.field' is not null
        if (this.field === null) {
            throw new Error('Required parameter "this.field" was null when calling updateFieldOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateFieldOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateFieldOnline.');
        }
        this.field?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.field !== undefined) {
            let _obj = ObjectSerializer.serialize(this.field, this.field.constructor.name === "Object" ? "importedFieldUpdate.FieldUpdate" : this.field.constructor.name);
            formParams.push(['Field', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateFieldOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "FieldResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateFields operation.
 * Reevaluates field values in the document.
 */
export class UpdateFieldsRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateFieldsRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/updateFields"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateFields.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateFields.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "DocumentResponse");
	}
}

/**
 * Request model for UpdateFieldsOnline operation.
 * Reevaluates field values in the document.
 */
export class UpdateFieldsOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateFieldsOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/updateFields"
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateFieldsOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateFieldsOnline.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateFieldsOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "DocumentResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateFootnote operation.
 * Updates a footnote in the document node.
 */
export class UpdateFootnoteRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateFootnoteRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Footnote data.
     */
    public footnoteDto: importedFootnoteUpdate.FootnoteUpdate;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/footnotes/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateFootnote.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateFootnote.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateFootnote.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateFootnote.');
        }
        // verify required parameter 'this.footnoteDto' is not undefined
        if (this.footnoteDto === undefined) {
            throw new Error('Required parameter "this.footnoteDto" was undefined when calling updateFootnote.');
        }

        // verify required parameter 'this.footnoteDto' is not null
        if (this.footnoteDto === null) {
            throw new Error('Required parameter "this.footnoteDto" was null when calling updateFootnote.');
        }
        this.footnoteDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.footnoteDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.footnoteDto, this.footnoteDto.constructor.name === "Object" ? "importedFootnoteUpdate.FootnoteUpdate" : this.footnoteDto.constructor.name);
            formParams.push(['FootnoteDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FootnoteResponse");
	}
}

/**
 * Request model for UpdateFootnoteOnline operation.
 * Updates a footnote in the document node.
 */
export class UpdateFootnoteOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateFootnoteOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Footnote data.
     */
    public footnoteDto: importedFootnoteUpdate.FootnoteUpdate;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/footnotes/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateFootnoteOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateFootnoteOnline.');
        }
        // verify required parameter 'this.footnoteDto' is not undefined
        if (this.footnoteDto === undefined) {
            throw new Error('Required parameter "this.footnoteDto" was undefined when calling updateFootnoteOnline.');
        }

        // verify required parameter 'this.footnoteDto' is not null
        if (this.footnoteDto === null) {
            throw new Error('Required parameter "this.footnoteDto" was null when calling updateFootnoteOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateFootnoteOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateFootnoteOnline.');
        }
        this.footnoteDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.footnoteDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.footnoteDto, this.footnoteDto.constructor.name === "Object" ? "importedFootnoteUpdate.FootnoteUpdate" : this.footnoteDto.constructor.name);
            formParams.push(['FootnoteDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateFootnoteOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "FootnoteResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateFormField operation.
 * Updates a form field in the document node.
 */
export class UpdateFormFieldRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateFormFieldRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * From field data.
     */
    public formField: importedFormField.FormField;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/formfields/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateFormField.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateFormField.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateFormField.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateFormField.');
        }
        // verify required parameter 'this.formField' is not undefined
        if (this.formField === undefined) {
            throw new Error('Required parameter "this.formField" was undefined when calling updateFormField.');
        }

        // verify required parameter 'this.formField' is not null
        if (this.formField === null) {
            throw new Error('Required parameter "this.formField" was null when calling updateFormField.');
        }
        this.formField?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.formField !== undefined) {
            let _obj = ObjectSerializer.serialize(this.formField, this.formField.constructor.name === "Object" ? "importedFormField.FormField" : this.formField.constructor.name);
            formParams.push(['FormField', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FormFieldResponse");
	}
}

/**
 * Request model for UpdateFormFieldOnline operation.
 * Updates a form field in the document node.
 */
export class UpdateFormFieldOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateFormFieldOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * From field data.
     */
    public formField: importedFormField.FormField;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/formfields/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateFormFieldOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateFormFieldOnline.');
        }
        // verify required parameter 'this.formField' is not undefined
        if (this.formField === undefined) {
            throw new Error('Required parameter "this.formField" was undefined when calling updateFormFieldOnline.');
        }

        // verify required parameter 'this.formField' is not null
        if (this.formField === null) {
            throw new Error('Required parameter "this.formField" was null when calling updateFormFieldOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateFormFieldOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateFormFieldOnline.');
        }
        this.formField?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.formField !== undefined) {
            let _obj = ObjectSerializer.serialize(this.formField, this.formField.constructor.name === "Object" ? "importedFormField.FormField" : this.formField.constructor.name);
            formParams.push(['FormField', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateFormFieldOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "FormFieldResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateList operation.
 * Updates a list in the document.
 */
export class UpdateListRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateListRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The list Id.
     */
    public listId: number;

    /**
     * List object.
     */
    public listUpdate: importedListUpdate.ListUpdate;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/lists/{listId}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateList.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateList.');
        }
        // verify required parameter 'this.listId' is not undefined
        if (this.listId === undefined) {
            throw new Error('Required parameter "this.listId" was undefined when calling updateList.');
        }

        // verify required parameter 'this.listId' is not null
        if (this.listId === null) {
            throw new Error('Required parameter "this.listId" was null when calling updateList.');
        }
        // verify required parameter 'this.listUpdate' is not undefined
        if (this.listUpdate === undefined) {
            throw new Error('Required parameter "this.listUpdate" was undefined when calling updateList.');
        }

        // verify required parameter 'this.listUpdate' is not null
        if (this.listUpdate === null) {
            throw new Error('Required parameter "this.listUpdate" was null when calling updateList.');
        }
        this.listUpdate?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.listUpdate !== undefined) {
            let _obj = ObjectSerializer.serialize(this.listUpdate, this.listUpdate.constructor.name === "Object" ? "importedListUpdate.ListUpdate" : this.listUpdate.constructor.name);
            formParams.push(['ListUpdate', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListResponse");
	}
}

/**
 * Request model for UpdateListLevel operation.
 * Updates the level of a List element in the document.
 */
export class UpdateListLevelRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateListLevelRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The list Id.
     */
    public listId: number;

    /**
     * The list level.
     */
    public listLevel: number;

    /**
     * List object.
     */
    public listUpdate: importedListLevelUpdate.ListLevelUpdate;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/lists/{listId}/listLevels/{listLevel}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
            .replace("/{" + "listLevel" + "}", (this.listLevel !== null && this.listLevel !== undefined) ? "/" + String(this.listLevel) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateListLevel.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateListLevel.');
        }
        // verify required parameter 'this.listId' is not undefined
        if (this.listId === undefined) {
            throw new Error('Required parameter "this.listId" was undefined when calling updateListLevel.');
        }

        // verify required parameter 'this.listId' is not null
        if (this.listId === null) {
            throw new Error('Required parameter "this.listId" was null when calling updateListLevel.');
        }
        // verify required parameter 'this.listLevel' is not undefined
        if (this.listLevel === undefined) {
            throw new Error('Required parameter "this.listLevel" was undefined when calling updateListLevel.');
        }

        // verify required parameter 'this.listLevel' is not null
        if (this.listLevel === null) {
            throw new Error('Required parameter "this.listLevel" was null when calling updateListLevel.');
        }
        // verify required parameter 'this.listUpdate' is not undefined
        if (this.listUpdate === undefined) {
            throw new Error('Required parameter "this.listUpdate" was undefined when calling updateListLevel.');
        }

        // verify required parameter 'this.listUpdate' is not null
        if (this.listUpdate === null) {
            throw new Error('Required parameter "this.listUpdate" was null when calling updateListLevel.');
        }
        this.listUpdate?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.listUpdate !== undefined) {
            let _obj = ObjectSerializer.serialize(this.listUpdate, this.listUpdate.constructor.name === "Object" ? "importedListLevelUpdate.ListLevelUpdate" : this.listUpdate.constructor.name);
            formParams.push(['ListUpdate', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ListResponse");
	}
}

/**
 * Request model for UpdateListLevelOnline operation.
 * Updates the level of a List element in the document.
 */
export class UpdateListLevelOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateListLevelOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The list Id.
     */
    public listId: number;

    /**
     * List object.
     */
    public listUpdate: importedListLevelUpdate.ListLevelUpdate;

    /**
     * The list level.
     */
    public listLevel: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/lists/{listId}/listLevels/{listLevel}"
            .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
            .replace("/{" + "listLevel" + "}", (this.listLevel !== null && this.listLevel !== undefined) ? "/" + String(this.listLevel) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateListLevelOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateListLevelOnline.');
        }
        // verify required parameter 'this.listId' is not undefined
        if (this.listId === undefined) {
            throw new Error('Required parameter "this.listId" was undefined when calling updateListLevelOnline.');
        }

        // verify required parameter 'this.listId' is not null
        if (this.listId === null) {
            throw new Error('Required parameter "this.listId" was null when calling updateListLevelOnline.');
        }
        // verify required parameter 'this.listUpdate' is not undefined
        if (this.listUpdate === undefined) {
            throw new Error('Required parameter "this.listUpdate" was undefined when calling updateListLevelOnline.');
        }

        // verify required parameter 'this.listUpdate' is not null
        if (this.listUpdate === null) {
            throw new Error('Required parameter "this.listUpdate" was null when calling updateListLevelOnline.');
        }
        // verify required parameter 'this.listLevel' is not undefined
        if (this.listLevel === undefined) {
            throw new Error('Required parameter "this.listLevel" was undefined when calling updateListLevelOnline.');
        }

        // verify required parameter 'this.listLevel' is not null
        if (this.listLevel === null) {
            throw new Error('Required parameter "this.listLevel" was null when calling updateListLevelOnline.');
        }
        this.listUpdate?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.listUpdate !== undefined) {
            let _obj = ObjectSerializer.serialize(this.listUpdate, this.listUpdate.constructor.name === "Object" ? "importedListLevelUpdate.ListLevelUpdate" : this.listUpdate.constructor.name);
            formParams.push(['ListUpdate', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateListLevelOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "ListResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateListOnline operation.
 * Updates a list in the document.
 */
export class UpdateListOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateListOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The list Id.
     */
    public listId: number;

    /**
     * List object.
     */
    public listUpdate: importedListUpdate.ListUpdate;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/lists/{listId}"
            .replace("/{" + "listId" + "}", (this.listId !== null && this.listId !== undefined) ? "/" + String(this.listId) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateListOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateListOnline.');
        }
        // verify required parameter 'this.listId' is not undefined
        if (this.listId === undefined) {
            throw new Error('Required parameter "this.listId" was undefined when calling updateListOnline.');
        }

        // verify required parameter 'this.listId' is not null
        if (this.listId === null) {
            throw new Error('Required parameter "this.listId" was null when calling updateListOnline.');
        }
        // verify required parameter 'this.listUpdate' is not undefined
        if (this.listUpdate === undefined) {
            throw new Error('Required parameter "this.listUpdate" was undefined when calling updateListOnline.');
        }

        // verify required parameter 'this.listUpdate' is not null
        if (this.listUpdate === null) {
            throw new Error('Required parameter "this.listUpdate" was null when calling updateListOnline.');
        }
        this.listUpdate?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.listUpdate !== undefined) {
            let _obj = ObjectSerializer.serialize(this.listUpdate, this.listUpdate.constructor.name === "Object" ? "importedListUpdate.ListUpdate" : this.listUpdate.constructor.name);
            formParams.push(['ListUpdate', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateListOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "ListResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateParagraphFormat operation.
 * Updates the formatting properties of a paragraph in the document node.
 */
export class UpdateParagraphFormatRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateParagraphFormatRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Dto for paragraph format update.
     */
    public paragraphFormatDto: importedParagraphFormatUpdate.ParagraphFormatUpdate;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/format"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateParagraphFormat.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateParagraphFormat.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateParagraphFormat.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateParagraphFormat.');
        }
        // verify required parameter 'this.paragraphFormatDto' is not undefined
        if (this.paragraphFormatDto === undefined) {
            throw new Error('Required parameter "this.paragraphFormatDto" was undefined when calling updateParagraphFormat.');
        }

        // verify required parameter 'this.paragraphFormatDto' is not null
        if (this.paragraphFormatDto === null) {
            throw new Error('Required parameter "this.paragraphFormatDto" was null when calling updateParagraphFormat.');
        }
        this.paragraphFormatDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.paragraphFormatDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.paragraphFormatDto, this.paragraphFormatDto.constructor.name === "Object" ? "importedParagraphFormatUpdate.ParagraphFormatUpdate" : this.paragraphFormatDto.constructor.name);
            formParams.push(['ParagraphFormatDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphFormatResponse");
	}
}

/**
 * Request model for UpdateParagraphFormatOnline operation.
 * Updates the formatting properties of a paragraph in the document node.
 */
export class UpdateParagraphFormatOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateParagraphFormatOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Dto for paragraph format update.
     */
    public paragraphFormatDto: importedParagraphFormatUpdate.ParagraphFormatUpdate;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/paragraphs/{index}/format"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateParagraphFormatOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateParagraphFormatOnline.');
        }
        // verify required parameter 'this.paragraphFormatDto' is not undefined
        if (this.paragraphFormatDto === undefined) {
            throw new Error('Required parameter "this.paragraphFormatDto" was undefined when calling updateParagraphFormatOnline.');
        }

        // verify required parameter 'this.paragraphFormatDto' is not null
        if (this.paragraphFormatDto === null) {
            throw new Error('Required parameter "this.paragraphFormatDto" was null when calling updateParagraphFormatOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateParagraphFormatOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateParagraphFormatOnline.');
        }
        this.paragraphFormatDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.paragraphFormatDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.paragraphFormatDto, this.paragraphFormatDto.constructor.name === "Object" ? "importedParagraphFormatUpdate.ParagraphFormatUpdate" : this.paragraphFormatDto.constructor.name);
            formParams.push(['ParagraphFormatDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateParagraphFormatOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "ParagraphFormatResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateParagraphListFormat operation.
 * Updates the formatting properties of a paragraph list in the document node.
 */
export class UpdateParagraphListFormatRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateParagraphListFormatRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * ListFormatUpdate dto.
     */
    public listFormatDto: importedListFormatUpdate.ListFormatUpdate;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/paragraphs/{index}/listFormat"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateParagraphListFormat.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateParagraphListFormat.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateParagraphListFormat.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateParagraphListFormat.');
        }
        // verify required parameter 'this.listFormatDto' is not undefined
        if (this.listFormatDto === undefined) {
            throw new Error('Required parameter "this.listFormatDto" was undefined when calling updateParagraphListFormat.');
        }

        // verify required parameter 'this.listFormatDto' is not null
        if (this.listFormatDto === null) {
            throw new Error('Required parameter "this.listFormatDto" was null when calling updateParagraphListFormat.');
        }
        this.listFormatDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.listFormatDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.listFormatDto, this.listFormatDto.constructor.name === "Object" ? "importedListFormatUpdate.ListFormatUpdate" : this.listFormatDto.constructor.name);
            formParams.push(['ListFormatDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "ParagraphListFormatResponse");
	}
}

/**
 * Request model for UpdateParagraphListFormatOnline operation.
 * Updates the formatting properties of a paragraph list in the document node.
 */
export class UpdateParagraphListFormatOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateParagraphListFormatOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * ListFormatUpdate dto.
     */
    public listFormatDto: importedListFormatUpdate.ListFormatUpdate;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/paragraphs/{index}/listFormat"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateParagraphListFormatOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateParagraphListFormatOnline.');
        }
        // verify required parameter 'this.listFormatDto' is not undefined
        if (this.listFormatDto === undefined) {
            throw new Error('Required parameter "this.listFormatDto" was undefined when calling updateParagraphListFormatOnline.');
        }

        // verify required parameter 'this.listFormatDto' is not null
        if (this.listFormatDto === null) {
            throw new Error('Required parameter "this.listFormatDto" was null when calling updateParagraphListFormatOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateParagraphListFormatOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateParagraphListFormatOnline.');
        }
        this.listFormatDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.listFormatDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.listFormatDto, this.listFormatDto.constructor.name === "Object" ? "importedListFormatUpdate.ListFormatUpdate" : this.listFormatDto.constructor.name);
            formParams.push(['ListFormatDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateParagraphListFormatOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "ParagraphListFormatResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateRun operation.
 * Updates a Run object in the paragraph.
 */
export class UpdateRunRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateRunRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Run data.
     */
    public run: importedRunUpdate.RunUpdate;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateRun.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateRun.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling updateRun.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling updateRun.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateRun.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateRun.');
        }
        // verify required parameter 'this.run' is not undefined
        if (this.run === undefined) {
            throw new Error('Required parameter "this.run" was undefined when calling updateRun.');
        }

        // verify required parameter 'this.run' is not null
        if (this.run === null) {
            throw new Error('Required parameter "this.run" was null when calling updateRun.');
        }
        this.run?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.run !== undefined) {
            let _obj = ObjectSerializer.serialize(this.run, this.run.constructor.name === "Object" ? "importedRunUpdate.RunUpdate" : this.run.constructor.name);
            formParams.push(['Run', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "RunResponse");
	}
}

/**
 * Request model for UpdateRunFont operation.
 * Updates the font properties of a Run object in the paragraph.
 */
export class UpdateRunFontRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateRunFontRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Font dto object.
     */
    public fontDto: importedFont.Font;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{paragraphPath}/runs/{index}/font"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateRunFont.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateRunFont.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling updateRunFont.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling updateRunFont.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateRunFont.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateRunFont.');
        }
        // verify required parameter 'this.fontDto' is not undefined
        if (this.fontDto === undefined) {
            throw new Error('Required parameter "this.fontDto" was undefined when calling updateRunFont.');
        }

        // verify required parameter 'this.fontDto' is not null
        if (this.fontDto === null) {
            throw new Error('Required parameter "this.fontDto" was null when calling updateRunFont.');
        }
        this.fontDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.fontDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.fontDto, this.fontDto.constructor.name === "Object" ? "importedFont.Font" : this.fontDto.constructor.name);
            formParams.push(['FontDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FontResponse");
	}
}

/**
 * Request model for UpdateRunFontOnline operation.
 * Updates the font properties of a Run object in the paragraph.
 */
export class UpdateRunFontOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateRunFontOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Font dto object.
     */
    public fontDto: importedFont.Font;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{paragraphPath}/runs/{index}/font"
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateRunFontOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateRunFontOnline.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling updateRunFontOnline.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling updateRunFontOnline.');
        }
        // verify required parameter 'this.fontDto' is not undefined
        if (this.fontDto === undefined) {
            throw new Error('Required parameter "this.fontDto" was undefined when calling updateRunFontOnline.');
        }

        // verify required parameter 'this.fontDto' is not null
        if (this.fontDto === null) {
            throw new Error('Required parameter "this.fontDto" was null when calling updateRunFontOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateRunFontOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateRunFontOnline.');
        }
        this.fontDto?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.fontDto !== undefined) {
            let _obj = ObjectSerializer.serialize(this.fontDto, this.fontDto.constructor.name === "Object" ? "importedFont.Font" : this.fontDto.constructor.name);
            formParams.push(['FontDto', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateRunFontOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "FontResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateRunOnline operation.
 * Updates a Run object in the paragraph.
 */
export class UpdateRunOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateRunOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the paragraph in the document tree.
     */
    public paragraphPath: string;

    /**
     * Run data.
     */
    public run: importedRunUpdate.RunUpdate;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{paragraphPath}/runs/{index}"
            .replace("/{" + "paragraphPath" + "}", (this.paragraphPath !== null && this.paragraphPath !== undefined) ? "/" + String(this.paragraphPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateRunOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateRunOnline.');
        }
        // verify required parameter 'this.paragraphPath' is not undefined
        if (this.paragraphPath === undefined) {
            throw new Error('Required parameter "this.paragraphPath" was undefined when calling updateRunOnline.');
        }

        // verify required parameter 'this.paragraphPath' is not null
        if (this.paragraphPath === null) {
            throw new Error('Required parameter "this.paragraphPath" was null when calling updateRunOnline.');
        }
        // verify required parameter 'this.run' is not undefined
        if (this.run === undefined) {
            throw new Error('Required parameter "this.run" was undefined when calling updateRunOnline.');
        }

        // verify required parameter 'this.run' is not null
        if (this.run === null) {
            throw new Error('Required parameter "this.run" was null when calling updateRunOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateRunOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateRunOnline.');
        }
        this.run?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.run !== undefined) {
            let _obj = ObjectSerializer.serialize(this.run, this.run.constructor.name === "Object" ? "importedRunUpdate.RunUpdate" : this.run.constructor.name);
            formParams.push(['Run', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateRunOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "RunResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateSectionPageSetup operation.
 * Updates the page setup of a section in the document.
 */
export class UpdateSectionPageSetupRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateSectionPageSetupRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Page setup properties dto.
     */
    public pageSetup: importedPageSetup.PageSetup;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/sections/{sectionIndex}/pageSetup"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateSectionPageSetup.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateSectionPageSetup.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling updateSectionPageSetup.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling updateSectionPageSetup.');
        }
        // verify required parameter 'this.pageSetup' is not undefined
        if (this.pageSetup === undefined) {
            throw new Error('Required parameter "this.pageSetup" was undefined when calling updateSectionPageSetup.');
        }

        // verify required parameter 'this.pageSetup' is not null
        if (this.pageSetup === null) {
            throw new Error('Required parameter "this.pageSetup" was null when calling updateSectionPageSetup.');
        }
        this.pageSetup?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.pageSetup !== undefined) {
            let _obj = ObjectSerializer.serialize(this.pageSetup, this.pageSetup.constructor.name === "Object" ? "importedPageSetup.PageSetup" : this.pageSetup.constructor.name);
            formParams.push(['PageSetup', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "SectionPageSetupResponse");
	}
}

/**
 * Request model for UpdateSectionPageSetupOnline operation.
 * Updates the page setup of a section in the document.
 */
export class UpdateSectionPageSetupOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateSectionPageSetupOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The index of the section.
     */
    public sectionIndex: number;

    /**
     * Page setup properties dto.
     */
    public pageSetup: importedPageSetup.PageSetup;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/sections/{sectionIndex}/pageSetup"
            .replace("/{" + "sectionIndex" + "}", (this.sectionIndex !== null && this.sectionIndex !== undefined) ? "/" + String(this.sectionIndex) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateSectionPageSetupOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateSectionPageSetupOnline.');
        }
        // verify required parameter 'this.sectionIndex' is not undefined
        if (this.sectionIndex === undefined) {
            throw new Error('Required parameter "this.sectionIndex" was undefined when calling updateSectionPageSetupOnline.');
        }

        // verify required parameter 'this.sectionIndex' is not null
        if (this.sectionIndex === null) {
            throw new Error('Required parameter "this.sectionIndex" was null when calling updateSectionPageSetupOnline.');
        }
        // verify required parameter 'this.pageSetup' is not undefined
        if (this.pageSetup === undefined) {
            throw new Error('Required parameter "this.pageSetup" was undefined when calling updateSectionPageSetupOnline.');
        }

        // verify required parameter 'this.pageSetup' is not null
        if (this.pageSetup === null) {
            throw new Error('Required parameter "this.pageSetup" was null when calling updateSectionPageSetupOnline.');
        }
        this.pageSetup?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.pageSetup !== undefined) {
            let _obj = ObjectSerializer.serialize(this.pageSetup, this.pageSetup.constructor.name === "Object" ? "importedPageSetup.PageSetup" : this.pageSetup.constructor.name);
            formParams.push(['PageSetup', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateSectionPageSetupOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "SectionPageSetupResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateStructuredDocumentTag operation.
 * Updates a StructuredDocumentTag (SDT) in the document node.
 */
export class UpdateStructuredDocumentTagRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateStructuredDocumentTagRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Structured document tag parameters.
     */
    public structuredDocumentTag: importedStructuredDocumentTagUpdate.StructuredDocumentTagUpdate;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/sdt/{index}"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateStructuredDocumentTag.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateStructuredDocumentTag.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateStructuredDocumentTag.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateStructuredDocumentTag.');
        }
        // verify required parameter 'this.structuredDocumentTag' is not undefined
        if (this.structuredDocumentTag === undefined) {
            throw new Error('Required parameter "this.structuredDocumentTag" was undefined when calling updateStructuredDocumentTag.');
        }

        // verify required parameter 'this.structuredDocumentTag' is not null
        if (this.structuredDocumentTag === null) {
            throw new Error('Required parameter "this.structuredDocumentTag" was null when calling updateStructuredDocumentTag.');
        }
        this.structuredDocumentTag?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.structuredDocumentTag !== undefined) {
            let _obj = ObjectSerializer.serialize(this.structuredDocumentTag, this.structuredDocumentTag.constructor.name === "Object" ? "importedStructuredDocumentTagUpdate.StructuredDocumentTagUpdate" : this.structuredDocumentTag.constructor.name);
            formParams.push(['StructuredDocumentTag', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StructuredDocumentTagResponse");
	}
}

/**
 * Request model for UpdateStructuredDocumentTagOnline operation.
 * Updates a StructuredDocumentTag (SDT) in the document node.
 */
export class UpdateStructuredDocumentTagOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateStructuredDocumentTagOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * Structured document tag parameters.
     */
    public structuredDocumentTag: importedStructuredDocumentTagUpdate.StructuredDocumentTagUpdate;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/sdt/{index}"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateStructuredDocumentTagOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateStructuredDocumentTagOnline.');
        }
        // verify required parameter 'this.structuredDocumentTag' is not undefined
        if (this.structuredDocumentTag === undefined) {
            throw new Error('Required parameter "this.structuredDocumentTag" was undefined when calling updateStructuredDocumentTagOnline.');
        }

        // verify required parameter 'this.structuredDocumentTag' is not null
        if (this.structuredDocumentTag === null) {
            throw new Error('Required parameter "this.structuredDocumentTag" was null when calling updateStructuredDocumentTagOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateStructuredDocumentTagOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateStructuredDocumentTagOnline.');
        }
        this.structuredDocumentTag?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.structuredDocumentTag !== undefined) {
            let _obj = ObjectSerializer.serialize(this.structuredDocumentTag, this.structuredDocumentTag.constructor.name === "Object" ? "importedStructuredDocumentTagUpdate.StructuredDocumentTagUpdate" : this.structuredDocumentTag.constructor.name);
            formParams.push(['StructuredDocumentTag', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateStructuredDocumentTagOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "StructuredDocumentTagResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateStyle operation.
 * Updates a style in the document.
 */
export class UpdateStyleRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateStyleRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The name of the style.
     */
    public styleName: string;

    /**
     * Style properties to update.
     */
    public styleUpdate: importedStyleUpdate.StyleUpdate;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/styles/{styleName}/update"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "styleName" + "}", (this.styleName !== null && this.styleName !== undefined) ? "/" + String(this.styleName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateStyle.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateStyle.');
        }
        // verify required parameter 'this.styleName' is not undefined
        if (this.styleName === undefined) {
            throw new Error('Required parameter "this.styleName" was undefined when calling updateStyle.');
        }

        // verify required parameter 'this.styleName' is not null
        if (this.styleName === null) {
            throw new Error('Required parameter "this.styleName" was null when calling updateStyle.');
        }
        // verify required parameter 'this.styleUpdate' is not undefined
        if (this.styleUpdate === undefined) {
            throw new Error('Required parameter "this.styleUpdate" was undefined when calling updateStyle.');
        }

        // verify required parameter 'this.styleUpdate' is not null
        if (this.styleUpdate === null) {
            throw new Error('Required parameter "this.styleUpdate" was null when calling updateStyle.');
        }
        this.styleUpdate?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.styleUpdate !== undefined) {
            let _obj = ObjectSerializer.serialize(this.styleUpdate, this.styleUpdate.constructor.name === "Object" ? "importedStyleUpdate.StyleUpdate" : this.styleUpdate.constructor.name);
            formParams.push(['StyleUpdate', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "StyleResponse");
	}
}

/**
 * Request model for UpdateStyleOnline operation.
 * Updates a style in the document.
 */
export class UpdateStyleOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateStyleOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The name of the style.
     */
    public styleName: string;

    /**
     * Style properties to update.
     */
    public styleUpdate: importedStyleUpdate.StyleUpdate;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/styles/{styleName}/update"
            .replace("/{" + "styleName" + "}", (this.styleName !== null && this.styleName !== undefined) ? "/" + String(this.styleName) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateStyleOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateStyleOnline.');
        }
        // verify required parameter 'this.styleName' is not undefined
        if (this.styleName === undefined) {
            throw new Error('Required parameter "this.styleName" was undefined when calling updateStyleOnline.');
        }

        // verify required parameter 'this.styleName' is not null
        if (this.styleName === null) {
            throw new Error('Required parameter "this.styleName" was null when calling updateStyleOnline.');
        }
        // verify required parameter 'this.styleUpdate' is not undefined
        if (this.styleUpdate === undefined) {
            throw new Error('Required parameter "this.styleUpdate" was undefined when calling updateStyleOnline.');
        }

        // verify required parameter 'this.styleUpdate' is not null
        if (this.styleUpdate === null) {
            throw new Error('Required parameter "this.styleUpdate" was null when calling updateStyleOnline.');
        }
        this.styleUpdate?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.styleUpdate !== undefined) {
            let _obj = ObjectSerializer.serialize(this.styleUpdate, this.styleUpdate.constructor.name === "Object" ? "importedStyleUpdate.StyleUpdate" : this.styleUpdate.constructor.name);
            formParams.push(['StyleUpdate', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateStyleOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "StyleResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateTableCellFormat operation.
 * Updates the formatting properties of a cell in the table row.
 */
export class UpdateTableCellFormatRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateTableCellFormatRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the table row in the document tree.
     */
    public tableRowPath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The properties.
     */
    public format: importedTableCellFormat.TableCellFormat;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tableRowPath}/cells/{index}/cellformat"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateTableCellFormat.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateTableCellFormat.');
        }
        // verify required parameter 'this.tableRowPath' is not undefined
        if (this.tableRowPath === undefined) {
            throw new Error('Required parameter "this.tableRowPath" was undefined when calling updateTableCellFormat.');
        }

        // verify required parameter 'this.tableRowPath' is not null
        if (this.tableRowPath === null) {
            throw new Error('Required parameter "this.tableRowPath" was null when calling updateTableCellFormat.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateTableCellFormat.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateTableCellFormat.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling updateTableCellFormat.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling updateTableCellFormat.');
        }
        this.format?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.format !== undefined) {
            let _obj = ObjectSerializer.serialize(this.format, this.format.constructor.name === "Object" ? "importedTableCellFormat.TableCellFormat" : this.format.constructor.name);
            formParams.push(['Format', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableCellFormatResponse");
	}
}

/**
 * Request model for UpdateTableCellFormatOnline operation.
 * Updates the formatting properties of a cell in the table row.
 */
export class UpdateTableCellFormatOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateTableCellFormatOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the table row in the document tree.
     */
    public tableRowPath: string;

    /**
     * The properties.
     */
    public format: importedTableCellFormat.TableCellFormat;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{tableRowPath}/cells/{index}/cellformat"
            .replace("/{" + "tableRowPath" + "}", (this.tableRowPath !== null && this.tableRowPath !== undefined) ? "/" + String(this.tableRowPath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateTableCellFormatOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateTableCellFormatOnline.');
        }
        // verify required parameter 'this.tableRowPath' is not undefined
        if (this.tableRowPath === undefined) {
            throw new Error('Required parameter "this.tableRowPath" was undefined when calling updateTableCellFormatOnline.');
        }

        // verify required parameter 'this.tableRowPath' is not null
        if (this.tableRowPath === null) {
            throw new Error('Required parameter "this.tableRowPath" was null when calling updateTableCellFormatOnline.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling updateTableCellFormatOnline.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling updateTableCellFormatOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateTableCellFormatOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateTableCellFormatOnline.');
        }
        this.format?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.format !== undefined) {
            let _obj = ObjectSerializer.serialize(this.format, this.format.constructor.name === "Object" ? "importedTableCellFormat.TableCellFormat" : this.format.constructor.name);
            formParams.push(['Format', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateTableCellFormatOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "TableCellFormatResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateTableProperties operation.
 * Updates properties of a table in the document node.
 */
export class UpdateTablePropertiesRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateTablePropertiesRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The properties.
     */
    public properties: importedTableProperties.TableProperties;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{nodePath}/tables/{index}/properties"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateTableProperties.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateTableProperties.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateTableProperties.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateTableProperties.');
        }
        // verify required parameter 'this.properties' is not undefined
        if (this.properties === undefined) {
            throw new Error('Required parameter "this.properties" was undefined when calling updateTableProperties.');
        }

        // verify required parameter 'this.properties' is not null
        if (this.properties === null) {
            throw new Error('Required parameter "this.properties" was null when calling updateTableProperties.');
        }
        this.properties?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.properties !== undefined) {
            let _obj = ObjectSerializer.serialize(this.properties, this.properties.constructor.name === "Object" ? "importedTableProperties.TableProperties" : this.properties.constructor.name);
            formParams.push(['Properties', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TablePropertiesResponse");
	}
}

/**
 * Request model for UpdateTablePropertiesOnline operation.
 * Updates properties of a table in the document node.
 */
export class UpdateTablePropertiesOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateTablePropertiesOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The properties.
     */
    public properties: importedTableProperties.TableProperties;

    /**
     * Object index.
     */
    public index: number;

    /**
     * The path to the node in the document tree.
     */
    public nodePath: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{nodePath}/tables/{index}/properties"
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("/{" + "nodePath" + "}", (this.nodePath !== null && this.nodePath !== undefined) ? "/" + String(this.nodePath) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateTablePropertiesOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateTablePropertiesOnline.');
        }
        // verify required parameter 'this.properties' is not undefined
        if (this.properties === undefined) {
            throw new Error('Required parameter "this.properties" was undefined when calling updateTablePropertiesOnline.');
        }

        // verify required parameter 'this.properties' is not null
        if (this.properties === null) {
            throw new Error('Required parameter "this.properties" was null when calling updateTablePropertiesOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateTablePropertiesOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateTablePropertiesOnline.');
        }
        this.properties?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.properties !== undefined) {
            let _obj = ObjectSerializer.serialize(this.properties, this.properties.constructor.name === "Object" ? "importedTableProperties.TableProperties" : this.properties.constructor.name);
            formParams.push(['Properties', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateTablePropertiesOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "TablePropertiesResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UpdateTableRowFormat operation.
 * Updates the formatting properties of a table row.
 */
export class UpdateTableRowFormatRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateTableRowFormatRequest >) {
        Object.assign(this, init);
    }

    /**
     * The filename of the input document.
     */
    public name: string;

    /**
     * The path to the table in the document tree.
     */
    public tablePath: string;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Table row format.
     */
    public format: importedTableRowFormat.TableRowFormat;

    /**
     * Original document folder.
     */
    public folder: string;

    /**
     * Original document storage.
     */
    public storage: string;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/{name}/{tablePath}/rows/{index}/rowformat"
            .replace("/{" + "name" + "}", (this.name !== null && this.name !== undefined) ? "/" + String(this.name) : "")
            .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.name' is not undefined
        if (this.name === undefined) {
            throw new Error('Required parameter "this.name" was undefined when calling updateTableRowFormat.');
        }

        // verify required parameter 'this.name' is not null
        if (this.name === null) {
            throw new Error('Required parameter "this.name" was null when calling updateTableRowFormat.');
        }
        // verify required parameter 'this.tablePath' is not undefined
        if (this.tablePath === undefined) {
            throw new Error('Required parameter "this.tablePath" was undefined when calling updateTableRowFormat.');
        }

        // verify required parameter 'this.tablePath' is not null
        if (this.tablePath === null) {
            throw new Error('Required parameter "this.tablePath" was null when calling updateTableRowFormat.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateTableRowFormat.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateTableRowFormat.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling updateTableRowFormat.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling updateTableRowFormat.');
        }
        this.format?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "folder", this.folder, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storage", this.storage, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.format !== undefined) {
            let _obj = ObjectSerializer.serialize(this.format, this.format.constructor.name === "Object" ? "importedTableRowFormat.TableRowFormat" : this.format.constructor.name);
            formParams.push(['Format', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "TableRowFormatResponse");
	}
}

/**
 * Request model for UpdateTableRowFormatOnline operation.
 * Updates the formatting properties of a table row.
 */
export class UpdateTableRowFormatOnlineRequest implements RequestInterface {

    public constructor(init?: Partial< UpdateTableRowFormatOnlineRequest >) {
        Object.assign(this, init);
    }

    /**
     * The document.
     */
    public document: Readable;

    /**
     * The path to the table in the document tree.
     */
    public tablePath: string;

    /**
     * Table row format.
     */
    public format: importedTableRowFormat.TableRowFormat;

    /**
     * Object index.
     */
    public index: number;

    /**
     * Encoding that will be used to load an HTML (or TXT) document if the encoding is not specified in HTML.
     */
    public loadEncoding: string;

    /**
     * Password of protected Word document. Use the parameter to pass a password via SDK. SDK encrypts it automatically. We don't recommend to use the parameter to pass a plain password for direct call of API.
     */
    public password: string;

    /**
     * Password of protected Word document. Use the parameter to pass an encrypted password for direct calls of API. See SDK code for encyption details.
     */
    public encryptedPassword: string;

    /**
     * The value indicates whether OpenType support is on.
     */
    public openTypeSupport: boolean;

    /**
     * Result path of the document after the operation. If this parameter is omitted then result of the operation will be saved as the source document.
     */
    public destFileName: string;

    /**
     * Initials of the author to use for revisions.If you set this parameter and then make some changes to the document programmatically, save the document and later open the document in MS Word you will see these changes as revisions.
     */
    public revisionAuthor: string;

    /**
     * The date and time to use for revisions.
     */
    public revisionDateTime: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/online/put/{tablePath}/rows/{index}/rowformat"
            .replace("/{" + "tablePath" + "}", (this.tablePath !== null && this.tablePath !== undefined) ? "/" + String(this.tablePath) : "")
            .replace("/{" + "index" + "}", (this.index !== null && this.index !== undefined) ? "/" + String(this.index) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.document' is not undefined
        if (this.document === undefined) {
            throw new Error('Required parameter "this.document" was undefined when calling updateTableRowFormatOnline.');
        }

        // verify required parameter 'this.document' is not null
        if (this.document === null) {
            throw new Error('Required parameter "this.document" was null when calling updateTableRowFormatOnline.');
        }
        // verify required parameter 'this.tablePath' is not undefined
        if (this.tablePath === undefined) {
            throw new Error('Required parameter "this.tablePath" was undefined when calling updateTableRowFormatOnline.');
        }

        // verify required parameter 'this.tablePath' is not null
        if (this.tablePath === null) {
            throw new Error('Required parameter "this.tablePath" was null when calling updateTableRowFormatOnline.');
        }
        // verify required parameter 'this.format' is not undefined
        if (this.format === undefined) {
            throw new Error('Required parameter "this.format" was undefined when calling updateTableRowFormatOnline.');
        }

        // verify required parameter 'this.format' is not null
        if (this.format === null) {
            throw new Error('Required parameter "this.format" was null when calling updateTableRowFormatOnline.');
        }
        // verify required parameter 'this.index' is not undefined
        if (this.index === undefined) {
            throw new Error('Required parameter "this.index" was undefined when calling updateTableRowFormatOnline.');
        }

        // verify required parameter 'this.index' is not null
        if (this.index === null) {
            throw new Error('Required parameter "this.index" was null when calling updateTableRowFormatOnline.');
        }
        this.format?.validate();

        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "loadEncoding", this.loadEncoding, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "password", this.password, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "encryptedPassword", this.encryptedPassword, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "openTypeSupport", this.openTypeSupport, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "destFileName", this.destFileName, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionAuthor", this.revisionAuthor, _encryptor);
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "revisionDateTime", this.revisionDateTime, _encryptor);
        if (this.document !== undefined) {
            formParams.push(['Document', this.document, 'application/octet-stream']);
        }
        if (this.format !== undefined) {
            let _obj = ObjectSerializer.serialize(this.format, this.format.constructor.name === "Object" ? "importedTableRowFormat.TableRowFormat" : this.format.constructor.name);
            formParams.push(['Format', JSON.stringify(_obj), 'application/json']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        const result = new UpdateTableRowFormatOnlineResponse();
        const boundary = getBoundary(_headers);
        const parts = parseMultipart(_response, boundary);
        result.model = ObjectSerializer.deserialize(JSON.parse(findMultipartElement(parts, "Model").body.toString()), "TableRowFormatResponse");


        const partDocument = findMultipartElement(parts, "Document");
        result.document = parseFilesCollection(partDocument.body, partDocument.headers);

        return result;
	}
}

/**
 * Request model for UploadFile operation.
 * Upload file.
 */
export class UploadFileRequest implements RequestInterface {

    public constructor(init?: Partial< UploadFileRequest >) {
        Object.assign(this, init);
    }

    /**
     * File to upload.
     */
    public fileContent: Readable;

    /**
     * Path where to upload including filename and extension e.g. /file.ext or /Folder 1/file.ext
     * If the content is multipart and path does not contains the file name it tries to get them from filename parameter
     * from Content-Disposition header.
     */
    public path: string;

    /**
     * Storage name.
     */
    public storageName: string;

	/**
	 * create the requst options for this request
	 * @param configuration a configuration for the request
	 * @param data encryptor 
	 */
	public async createRequestOptions(configuration: Configuration, _encryptor: Encryptor) : Promise<request.OptionsWithUri> {
        let localVarPath = configuration.getApiBaseUrl() + "/words/storage/file/{path}"
            .replace("/{" + "path" + "}", (this.path !== null && this.path !== undefined) ? "/" + String(this.path) : "")
            .replace("//", "/");
        var queryParameters: any = {};
        var headerParams: any = {};
        var formParams: any = [];
        var filesContent: any = [];
        // verify required parameter 'this.fileContent' is not undefined
        if (this.fileContent === undefined) {
            throw new Error('Required parameter "this.fileContent" was undefined when calling uploadFile.');
        }

        // verify required parameter 'this.fileContent' is not null
        if (this.fileContent === null) {
            throw new Error('Required parameter "this.fileContent" was null when calling uploadFile.');
        }
        // verify required parameter 'this.path' is not undefined
        if (this.path === undefined) {
            throw new Error('Required parameter "this.path" was undefined when calling uploadFile.');
        }

        // verify required parameter 'this.path' is not null
        if (this.path === null) {
            throw new Error('Required parameter "this.path" was null when calling uploadFile.');
        }
        localVarPath = await addQueryParameterToUrl(localVarPath, queryParameters, "storageName", this.storageName, _encryptor);
        if (this.fileContent !== undefined) {
            formParams.push(['FileContent', this.fileContent, 'application/octet-stream']);
        }

        for (let fileContent of filesContent) {
            await fileContent.encryptPassword(_encryptor);
            if (fileContent.getSource() == FileReference.SourceEnum.Request) {
                formParams.push([fileContent.getReference(), fileContent.getContent(), 'application/octet-stream']);
            }
        }

        const requestOptions: request.Options = {
            method: "PUT",
            qs: queryParameters,
            headers: headerParams,
            uri: localVarPath,
        };

        if (formParams.length == 1) {
            let formFirstParam = formParams[0];
            requestOptions.body = formFirstParam[1];
            requestOptions.headers["Content-Type"] = formFirstParam[2];
        }
        else if (formParams.length > 1) {
            const requestParts = [];
            for (let formParam of formParams) {
                requestParts.push({
                    'Content-Type': formParam[2],
                    'Content-Disposition': 'form-data; name="' + formParam[0] + '"',
                    body: formParam[1],
                });
            }

            requestOptions.headers["Content-Type"] = 'multipart/form-data';
            requestOptions.multipart = requestParts;
        }

        return Promise.resolve(requestOptions);
    }

	/**
	 * create response from string
	 */
	createResponse(_response: Buffer, _headers: http.IncomingHttpHeaders): any {
        return ObjectSerializer.deserialize(JSON.parse(_response.toString()), "FilesUploadResult");
	}
}

/**
 * Response model for AcceptAllRevisionsOnline operation.
 * Accepts all revisions in the document.
 */
export class AcceptAllRevisionsOnlineResponse {
    /**
     * The REST response with a result of the modification operations for the revisions collection (now these are acceptAll and rejectAll).
     */
    public model: importedRevisionsModificationResponse.RevisionsModificationResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for AppendDocumentOnline operation.
 * Appends documents to the original document.
 */
export class AppendDocumentOnlineResponse {
    /**
     * The REST response with a document description.
     */
    public model: importedDocumentResponse.DocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for ApplyStyleToDocumentElementOnline operation.
 * Applies a style to the document node.
 */
export class ApplyStyleToDocumentElementOnlineResponse {
    /**
     * The base class for all responses.
     */
    public model: importedWordsResponse.WordsResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for CompareDocumentOnline operation.
 * Compares two documents.
 */
export class CompareDocumentOnlineResponse {
    /**
     * The REST response with a document description.
     */
    public model: importedDocumentResponse.DocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for CompressDocumentOnline operation.
 * Compress and resize images inside the document.
 * The default settings allows to reduce the size of the document without any visible degradation of images quality.
 */
export class CompressDocumentOnlineResponse {
    /**
     * The REST response of compressed document.
     */
    public model: importedCompressResponse.CompressResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for CopyStyleOnline operation.
 * Makes a copy of the style in the document.
 */
export class CopyStyleOnlineResponse {
    /**
     * The REST response with a style.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/styles/{0}" REST API requests.
     */
    public model: importedStyleResponse.StyleResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for CreateOrUpdateDocumentPropertyOnline operation.
 * Adds a new or updates an existing document property.
 */
export class CreateOrUpdateDocumentPropertyOnlineResponse {
    /**
     * The REST response with a document property.
     * This response should be returned by the service when handling: GET documentProperties/{propertyName}.
     */
    public model: importedDocumentPropertyResponse.DocumentPropertyResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for DeleteAllParagraphTabStopsOnline operation.
 * Removes paragraph tab stops from the document node.
 */
export class DeleteAllParagraphTabStopsOnlineResponse {
    /**
     * The REST response with an array of tab stops.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/tabstops" REST API requests.
     */
    public model: importedTabStopsResponse.TabStopsResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for DeleteBorderOnline operation.
 * Removes a border from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
export class DeleteBorderOnlineResponse {
    /**
     * The REST response with a border.
     * This response is returned by the Service when handling "GET {nodeWithBorders}/borders" REST API requests.
     */
    public model: importedBorderResponse.BorderResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for DeleteBordersOnline operation.
 * Removes borders from the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
export class DeleteBordersOnlineResponse {
    /**
     * The REST response with a collection of borders.
     * This response is returned by the Service when handling "GET {nodeWithBorders}/borders" REST API requests.
     */
    public model: importedBordersResponse.BordersResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for DeleteParagraphListFormatOnline operation.
 * Removes the formatting properties of a paragraph list from the document node.
 */
export class DeleteParagraphListFormatOnlineResponse {
    /**
     * The REST response with a list format for a paragraph.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/listFormat" REST API requests.
     */
    public model: importedParagraphListFormatResponse.ParagraphListFormatResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for DeleteParagraphTabStopOnline operation.
 * Removes a paragraph tab stop from the document node.
 */
export class DeleteParagraphTabStopOnlineResponse {
    /**
     * The REST response with an array of tab stops.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/tabstops" REST API requests.
     */
    public model: importedTabStopsResponse.TabStopsResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for DeleteWatermarkOnline operation.
 * Removes a watermark from the document.
 */
export class DeleteWatermarkOnlineResponse {
    /**
     * The REST response with a document description.
     */
    public model: importedDocumentResponse.DocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertBookmarkOnline operation.
 * Inserts a new bookmark to the document.
 */
export class InsertBookmarkOnlineResponse {
    /**
     * The REST response with a bookmark.
     * This response should be returned by the service when handling: GET bookmarks/{bookmarkName}.
     */
    public model: importedBookmarkResponse.BookmarkResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertCommentOnline operation.
 * Inserts a new comment to the document.
 */
export class InsertCommentOnlineResponse {
    /**
     * The REST response with a comment.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/comments/0" REST API requests.
     */
    public model: importedCommentResponse.CommentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertCustomXmlPartOnline operation.
 * Inserts a new custom xml part to the document.
 */
export class InsertCustomXmlPartOnlineResponse {
    /**
     * The REST response with a custom xml part.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/customXmlParts/0" REST API requests.
     */
    public model: importedCustomXmlPartResponse.CustomXmlPartResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertDrawingObjectOnline operation.
 * Inserts a new DrawingObject to the document node.
 */
export class InsertDrawingObjectOnlineResponse {
    /**
     * The REST response with a DrawingObject.
     */
    public model: importedDrawingObjectResponse.DrawingObjectResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertFieldOnline operation.
 * Inserts a new field to the document node.
 */
export class InsertFieldOnlineResponse {
    /**
     * The REST response with a field.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/fields/{1}" REST API requests.
     */
    public model: importedFieldResponse.FieldResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertFootnoteOnline operation.
 * Inserts a new footnote to the document node.
 */
export class InsertFootnoteOnlineResponse {
    /**
     * The REST response with a footnote.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/footnote/0" REST API requests.
     */
    public model: importedFootnoteResponse.FootnoteResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertFormFieldOnline operation.
 * Inserts a new form field to the document node.
 */
export class InsertFormFieldOnlineResponse {
    /**
     * The REST response with a form field.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/form fields/{1}" REST API requests.
     */
    public model: importedFormFieldResponse.FormFieldResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertHeaderFooterOnline operation.
 * Inserts a new HeaderFooter object to the document section.
 */
export class InsertHeaderFooterOnlineResponse {
    /**
     * The REST response with a HeaderFooter.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/headersfooters/{0}" REST API requests.
     */
    public model: importedHeaderFooterResponse.HeaderFooterResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertListOnline operation.
 * Inserts a new list to the document.
 */
export class InsertListOnlineResponse {
    /**
     * The REST response with a list information.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/lists/{n}" REST API requests.
     */
    public model: importedListResponse.ListResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertOrUpdateParagraphTabStopOnline operation.
 * Inserts a new or updates an existing paragraph tab stop in the document node.
 */
export class InsertOrUpdateParagraphTabStopOnlineResponse {
    /**
     * The REST response with an array of tab stops.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/tabstops" REST API requests.
     */
    public model: importedTabStopsResponse.TabStopsResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertPageNumbersOnline operation.
 * Inserts page numbers to the document.
 */
export class InsertPageNumbersOnlineResponse {
    /**
     * The REST response with a document description.
     */
    public model: importedDocumentResponse.DocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertParagraphOnline operation.
 * Inserts a new paragraph to the document node.
 */
export class InsertParagraphOnlineResponse {
    /**
     * The REST response with a paragraph.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}" REST API requests.
     */
    public model: importedParagraphResponse.ParagraphResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertRunOnline operation.
 * Inserts a new Run object to the paragraph.
 */
export class InsertRunOnlineResponse {
    /**
     * The REST response with a Run element.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/runs/{1}" REST API requests.
     */
    public model: importedRunResponse.RunResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertStructuredDocumentTagOnline operation.
 * Inserts a new StructuredDocumentTag (SDT) to the document node.
 */
export class InsertStructuredDocumentTagOnlineResponse {
    /**
     * The REST response with a StructuredDocumentTag.
     */
    public model: importedStructuredDocumentTagResponse.StructuredDocumentTagResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertStyleOnline operation.
 * Inserts a new style to the document.
 */
export class InsertStyleOnlineResponse {
    /**
     * The REST response with a style.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/styles/{0}" REST API requests.
     */
    public model: importedStyleResponse.StyleResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertTableCellOnline operation.
 * Inserts a new cell to the table row.
 */
export class InsertTableCellOnlineResponse {
    /**
     * The REST response with a table cell.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/tables/{0}" REST API requests.
     */
    public model: importedTableCellResponse.TableCellResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertTableOnline operation.
 * Inserts a new table to the document node.
 */
export class InsertTableOnlineResponse {
    /**
     * The REST response with a table.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/tables/{0}" REST API requests.
     */
    public model: importedTableResponse.TableResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertTableRowOnline operation.
 * Inserts a new row to the table.
 */
export class InsertTableRowOnlineResponse {
    /**
     * The REST response with a table row.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/tables/{0}" REST API requests.
     */
    public model: importedTableRowResponse.TableRowResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertWatermarkImageOnline operation.
 * Inserts a new watermark image to the document.
 */
export class InsertWatermarkImageOnlineResponse {
    /**
     * The REST response with a document description.
     */
    public model: importedDocumentResponse.DocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertWatermarkOnline operation.
 * Insert a watermark to the document.
 */
export class InsertWatermarkOnlineResponse {
    /**
     * The REST response with a document description.
     */
    public model: importedDocumentResponse.DocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for InsertWatermarkTextOnline operation.
 * Inserts a new watermark text to the document.
 */
export class InsertWatermarkTextOnlineResponse {
    /**
     * The REST response with a document description.
     */
    public model: importedDocumentResponse.DocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for LoadWebDocumentOnline operation.
 * Downloads a document from the Web using URL and saves it to cloud storage in the specified format.
 */
export class LoadWebDocumentOnlineResponse {
    /**
     * The REST response with a save result.
     */
    public model: importedSaveResponse.SaveResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for ProtectDocumentOnline operation.
 * Changes the document protection. The previous protection will be overwritten if it exist.
 */
export class ProtectDocumentOnlineResponse {
    /**
     * The REST response with data on document's protection.
     */
    public model: importedProtectionDataResponse.ProtectionDataResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for RejectAllRevisionsOnline operation.
 * Rejects all revisions in the document.
 */
export class RejectAllRevisionsOnlineResponse {
    /**
     * The REST response with a result of the modification operations for the revisions collection (now these are acceptAll and rejectAll).
     */
    public model: importedRevisionsModificationResponse.RevisionsModificationResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for RemoveAllSignaturesOnline operation.
 * Removes all signatures of the document.
 */
export class RemoveAllSignaturesOnlineResponse {
    /**
     * The REST response with a document signature collection.
     * This response is returned by the Service when handling any "https://api.aspose.cloud/v4.0/words/Test.doc/signatures" REST API requests.
     */
    public model: importedSignatureCollectionResponse.SignatureCollectionResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for RemoveRangeOnline operation.
 * Removes a range from the document.
 */
export class RemoveRangeOnlineResponse {
    /**
     * The REST response with a document description.
     */
    public model: importedDocumentResponse.DocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for ReplaceTextOnline operation.
 * Replaces text in the document.
 */
export class ReplaceTextOnlineResponse {
    /**
     * The REST response with a number of occurrences of the captured text in the document.
     */
    public model: importedReplaceTextResponse.ReplaceTextResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for ReplaceWithTextOnline operation.
 * Replaces a range with text in the document.
 */
export class ReplaceWithTextOnlineResponse {
    /**
     * The REST response with a document description.
     */
    public model: importedDocumentResponse.DocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for SaveAsOnline operation.
 * Converts a document in cloud storage to the specified format.
 */
export class SaveAsOnlineResponse {
    /**
     * The REST response with a save result.
     */
    public model: importedSaveResponse.SaveResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for SaveAsRangeOnline operation.
 * Saves a range as a new document.
 */
export class SaveAsRangeOnlineResponse {
    /**
     * The REST response with a document description.
     */
    public model: importedDocumentResponse.DocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for SaveAsTiffOnline operation.
 * Converts a document in cloud storage to TIFF format using detailed conversion settings.
 */
export class SaveAsTiffOnlineResponse {
    /**
     * The REST response with a save result.
     */
    public model: importedSaveResponse.SaveResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for SignDocumentOnline operation.
 * Signs the document with given certificate.
 */
export class SignDocumentOnlineResponse {
    /**
     * The REST response with a document signature collection.
     * This response is returned by the Service when handling any "https://api.aspose.cloud/v4.0/words/Test.doc/signatures" REST API requests.
     */
    public model: importedSignatureCollectionResponse.SignatureCollectionResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for SplitDocumentOnline operation.
 * Splits a document into parts and saves them in the specified format.
 */
export class SplitDocumentOnlineResponse {
    /**
     * The REST response with a result of document splitting.
     * This response should be returned by the service when handling: POST /{name}/split.
     */
    public model: importedSplitDocumentResponse.SplitDocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UnprotectDocumentOnline operation.
 * Removes protection from the document.
 */
export class UnprotectDocumentOnlineResponse {
    /**
     * The REST response with data on document's protection.
     */
    public model: importedProtectionDataResponse.ProtectionDataResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateBookmarkOnline operation.
 * Updates a bookmark in the document.
 */
export class UpdateBookmarkOnlineResponse {
    /**
     * The REST response with a bookmark.
     * This response should be returned by the service when handling: GET bookmarks/{bookmarkName}.
     */
    public model: importedBookmarkResponse.BookmarkResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateBorderOnline operation.
 * Updates a border in the document node.
 * The 'nodePath' parameter should refer to a paragraph, a cell or a row.
 */
export class UpdateBorderOnlineResponse {
    /**
     * The REST response with a border.
     * This response is returned by the Service when handling "GET {nodeWithBorders}/borders" REST API requests.
     */
    public model: importedBorderResponse.BorderResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateCommentOnline operation.
 * Updates a comment in the document.
 */
export class UpdateCommentOnlineResponse {
    /**
     * The REST response with a comment.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/comments/0" REST API requests.
     */
    public model: importedCommentResponse.CommentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateCustomXmlPartOnline operation.
 * Updates the custom xml part in the document.
 */
export class UpdateCustomXmlPartOnlineResponse {
    /**
     * The REST response with a custom xml part.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/customXmlParts/0" REST API requests.
     */
    public model: importedCustomXmlPartResponse.CustomXmlPartResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateDrawingObjectOnline operation.
 * Updates a DrawingObject in the document node.
 */
export class UpdateDrawingObjectOnlineResponse {
    /**
     * The REST response with a DrawingObject.
     */
    public model: importedDrawingObjectResponse.DrawingObjectResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateFieldOnline operation.
 * Updates a field in the document node.
 */
export class UpdateFieldOnlineResponse {
    /**
     * The REST response with a field.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/fields/{1}" REST API requests.
     */
    public model: importedFieldResponse.FieldResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateFieldsOnline operation.
 * Reevaluates field values in the document.
 */
export class UpdateFieldsOnlineResponse {
    /**
     * The REST response with a document description.
     */
    public model: importedDocumentResponse.DocumentResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateFootnoteOnline operation.
 * Updates a footnote in the document node.
 */
export class UpdateFootnoteOnlineResponse {
    /**
     * The REST response with a footnote.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/footnote/0" REST API requests.
     */
    public model: importedFootnoteResponse.FootnoteResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateFormFieldOnline operation.
 * Updates a form field in the document node.
 */
export class UpdateFormFieldOnlineResponse {
    /**
     * The REST response with a form field.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/form fields/{1}" REST API requests.
     */
    public model: importedFormFieldResponse.FormFieldResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateListLevelOnline operation.
 * Updates the level of a List element in the document.
 */
export class UpdateListLevelOnlineResponse {
    /**
     * The REST response with a list information.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/lists/{n}" REST API requests.
     */
    public model: importedListResponse.ListResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateListOnline operation.
 * Updates a list in the document.
 */
export class UpdateListOnlineResponse {
    /**
     * The REST response with a list information.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/lists/{n}" REST API requests.
     */
    public model: importedListResponse.ListResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateParagraphFormatOnline operation.
 * Updates the formatting properties of a paragraph in the document node.
 */
export class UpdateParagraphFormatOnlineResponse {
    /**
     * The REST response with the formatting properties of a paragraph.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/format" REST API requests.
     */
    public model: importedParagraphFormatResponse.ParagraphFormatResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateParagraphListFormatOnline operation.
 * Updates the formatting properties of a paragraph list in the document node.
 */
export class UpdateParagraphListFormatOnlineResponse {
    /**
     * The REST response with a list format for a paragraph.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/listFormat" REST API requests.
     */
    public model: importedParagraphListFormatResponse.ParagraphListFormatResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateRunFontOnline operation.
 * Updates the font properties of a Run object in the paragraph.
 */
export class UpdateRunFontOnlineResponse {
    /**
     * The REST response with a font.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/runs/{1}/font" REST API requests.
     */
    public model: importedFontResponse.FontResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateRunOnline operation.
 * Updates a Run object in the paragraph.
 */
export class UpdateRunOnlineResponse {
    /**
     * The REST response with a Run element.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/paragraphs/{0}/runs/{1}" REST API requests.
     */
    public model: importedRunResponse.RunResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateSectionPageSetupOnline operation.
 * Updates the page setup of a section in the document.
 */
export class UpdateSectionPageSetupOnlineResponse {
    /**
     * The REST response with a page setup of a section.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/sections/{0}/PageSetup" REST API requests.
     */
    public model: importedSectionPageSetupResponse.SectionPageSetupResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateStructuredDocumentTagOnline operation.
 * Updates a StructuredDocumentTag (SDT) in the document node.
 */
export class UpdateStructuredDocumentTagOnlineResponse {
    /**
     * The REST response with a StructuredDocumentTag.
     */
    public model: importedStructuredDocumentTagResponse.StructuredDocumentTagResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateStyleOnline operation.
 * Updates a style in the document.
 */
export class UpdateStyleOnlineResponse {
    /**
     * The REST response with a style.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/styles/{0}" REST API requests.
     */
    public model: importedStyleResponse.StyleResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateTableCellFormatOnline operation.
 * Updates the formatting properties of a cell in the table row.
 */
export class UpdateTableCellFormatOnlineResponse {
    /**
     * The REST response with the formatting properties of a table cell.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/tables/{0}/rows/{1}/cells/{2}/cellformat" REST API requests.
     */
    public model: importedTableCellFormatResponse.TableCellFormatResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateTablePropertiesOnline operation.
 * Updates properties of a table in the document node.
 */
export class UpdateTablePropertiesOnlineResponse {
    /**
     * The REST response with a table.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/tables/{0}/properties" REST API requests.
     */
    public model: importedTablePropertiesResponse.TablePropertiesResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}

/**
 * Response model for UpdateTableRowFormatOnline operation.
 * Updates the formatting properties of a table row.
 */
export class UpdateTableRowFormatOnlineResponse {
    /**
     * The REST response with the formatting properties of a table row.
     * This response is returned by the Service when handling "GET https://api.aspose.cloud/v4.0/words/Test.doc/tables/{0}/rows/{1}/rowformat" REST API requests.
     */
    public model: importedTableRowFormatResponse.TableRowFormatResponse;

    /**
     * The document after modification.
     */
    public document: Map<string, Buffer>;
}
